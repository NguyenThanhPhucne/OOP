export const quizData = [
  {
    id: 1,
    question: "What is Java described as in the context of object-oriented programming?",
    options: [
      "A partially object-oriented programming language where some elements are procedural.",
      "A fully object-oriented programming language where everything revolves around classes and objects.",
      "A functional programming language focused on functions and immutability.",
      "A scripting language primarily used for web development.",
    ],
    correctAnswer: "B",
    explanation: "Java is a fully object-oriented programming language where everything revolves around classes and objects.",
    source: "Page 2 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 2,
    question: "What does an object represent in Java?",
    options: [
      "A blueprint for creating classes.",
      "A real-world entity with attributes and methods.",
      "A method that performs actions.",
      "A variable that stores data.",
    ],
    correctAnswer: "B",
    explanation: "An object represents a real-world entity and has two main components.",
    source: "Page 3 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 3,
    question: "What are the two main components of an object?",
    options: [
      "Classes and instances.",
      "Attributes (data) and Methods (behavior).",
      "Constructors and destructors.",
      "Fields and parameters.",
    ],
    correctAnswer: "B",
    explanation: "Attributes (data): Properties that describe the object (e.g., color, weight); Methods (behavior): Actions that the object can perform (e.g., drive(), brake()).",
    source: "Page 3 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 4,
    question: "According to the example, what is a car as an object with?",
    options: [
      "Attributes: speed, fuel; Methods: accelerate, stop.",
      "Attributes: weight, color; Methods: drive, brake.",
      "Attributes: model, year; Methods: start, park.",
      "Attributes: size, shape; Methods: move, turn.",
    ],
    correctAnswer: "B",
    explanation: "Example: A car is an object with: Attributes: weight, color; Methods: drive, brake.",
    source: "Page 3 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 5,
    question: "What is a class in Java?",
    options: [
      "An instance of an object.",
      "A blueprint for creating objects that defines the structure and behavior of objects.",
      "A method that initializes objects.",
      "A variable that holds object references.",
    ],
    correctAnswer: "B",
    explanation: "A class is a blueprint for creating objects that defines the structure and behavior of objects.",
    source: "Page 4 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 6,
    question: "What does a class serve as for objects?",
    options: [
      "A runtime environment for execution.",
      "A template from which objects are created (instantiated).",
      "A storage for global variables.",
      "A container for static methods only.",
    ],
    correctAnswer: "B",
    explanation: "Serves as a template from which objects are created (instantiated).",
    source: "Page 4 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 7,
    question: "How should one think of a class and an object?",
    options: [
      "Class as a real instance, object as a template.",
      "Class as a template, and an object as a real instance based on that template.",
      "Both as the same entity.",
      "Class as behavior, object as data.",
    ],
    correctAnswer: "B",
    explanation: "Think of a class as a template, and an object as a real instance based on that template.",
    source: "Page 4 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 8,
    question: "What is a class defined as in the context of creating one in Java?",
    options: [
      "An instance created with new.",
      "A blueprint for creating objects.",
      "A method inside an object.",
      "A variable declaration.",
    ],
    correctAnswer: "B",
    explanation: "A class is a blueprint for creating objects.",
    source: "Page 5 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 9,
    question: "What does a class group into a single unit?",
    options: [
      "Only methods.",
      "Variables (attributes) and methods (behaviors).",
      "Only variables.",
      "Constructors and destructors.",
    ],
    correctAnswer: "B",
    explanation: "It groups variables (attributes) and methods (behaviors) into a single unit.",
    source: "Page 5 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 10,
    question: "What keyword is used to define a class in Java?",
    options: [
      "object",
      "instance",
      "class",
      "new",
    ],
    correctAnswer: "C",
    explanation: "Use the keyword class to define a class in Java.",
    source: "Page 5 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 11,
    question: "In the example code below, what is this demonstrating? public class Main { int x = 5; }",
    options: [
      "Creating an object.",
      "Defining a class with an attribute.",
      "Calling a method.",
      "Initializing a constructor.",
    ],
    correctAnswer: "B",
    explanation: "Example showing class definition.",
    source: "Page 6 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 12,
    question: "In the example public class Main { int x = 5; }, what is Main?",
    options: [
      "The value of the attribute.",
      "The name of the class.",
      "The keyword for the attribute.",
      "The object instance.",
    ],
    correctAnswer: "B",
    explanation: "Main is the name of the class.",
    source: "Page 6 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 13,
    question: "In the example public class Main { int x = 5; }, what is x?",
    options: [
      "The class name.",
      "An integer variable (attribute) with the value 5.",
      "A method.",
      "A constructor parameter.",
    ],
    correctAnswer: "B",
    explanation: "x is an integer variable (attribute) with the value 5.",
    source: "Page 6 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 14,
    question: "In the explanation, what does each object created from Main have?",
    options: [
      "Shared copy of x.",
      "Its own copy of x.",
      "No copy of x.",
      "Static reference to x.",
    ],
    correctAnswer: "B",
    explanation: "Each object created from Main will have its own copy of x.",
    source: "Page 6 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 15,
    question: "What is an object in Java?",
    options: [
      "A blueprint for classes.",
      "Created from a class using the new keyword.",
      "A static method.",
      "A global function.",
    ],
    correctAnswer: "B",
    explanation: "In Java, an object is created from a class using the new keyword.",
    source: "Page 7 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 16,
    question: "What is an object described as?",
    options: [
      "A class definition.",
      "An instance of a class — it has its own copy of the class's variables and methods.",
      "A shared resource.",
      "A parameter list.",
    ],
    correctAnswer: "B",
    explanation: "An object is an instance of a class — it has its own copy of the class's variables and methods.",
    source: "Page 7 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 17,
    question: "What is the syntax to create an object?",
    options: [
      "ClassName objectName();",
      "ClassName objectName = new ClassName();",
      "new ClassName objectName;",
      "objectName = ClassName.new();",
    ],
    correctAnswer: "B",
    explanation: "Syntax: ClassName objectName = new ClassName();.",
    source: "Page 7 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 18,
    question: "In the example code below, what is this demonstrating? public class Main { int x = 5; public static void main(String[] args) { Main myObj = new Main(); System.out.println(myObj.x); } }",
    options: [
      "Defining a class only.",
      "Creating an object and accessing its attribute.",
      "Multiple classes.",
      "Static methods.",
    ],
    correctAnswer: "B",
    explanation: "Example showing object creation and attribute access.",
    source: "Page 7 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 19,
    question: "In the example, what does Main myObj = new Main(); do?",
    options: [
      "Defines a method.",
      "Creates a new object named myObj.",
      "Prints the value.",
      "Modifies the class.",
    ],
    correctAnswer: "B",
    explanation: "Main myObj = new Main(); creates a new object named myObj.",
    source: "Page 7 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 20,
    question: "In the example, what does myObj.x do?",
    options: [
      "Creates the object.",
      "Accesses the x attribute of the object.",
      "Calls a method.",
      "Changes the value.",
    ],
    correctAnswer: "B",
    explanation: "myObj.x accesses the x attribute of the object.",
    source: "Page 7 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 21,
    question: "What is the output of the example code for creating an object?",
    options: [
      "null",
      "0",
      "5",
      "Error",
    ],
    correctAnswer: "C",
    explanation: "Output: 5.",
    source: "Page 7 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 22,
    question: "What can you do with the same class in Java?",
    options: [
      "Create only one object.",
      "Create multiple independent objects from the same class.",
      "Share all attributes.",
      "Define global functions.",
    ],
    correctAnswer: "B",
    explanation: "You can create multiple independent objects from the same class.",
    source: "Page 8 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 23,
    question: "What does each object have in multiple objects from the same class?",
    options: [
      "Shared fields and methods.",
      "Its own copy of fields and methods.",
      "No fields.",
      "Static copies only.",
    ],
    correctAnswer: "B",
    explanation: "Each object has its own copy of fields and methods.",
    source: "Page 8 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 24,
    question: "In the example code below, what is the output? public class Main { int x = 5; public static void main(String[] args) { Main myObj1 = new Main(); // Object 1 Main myObj2 = new Main(); // Object 2 System.out.println(myObj1.x); System.out.println(myObj2.x); } }",
    options: [
      "5 and 0",
      "5 and 5",
      "Error",
      "null and null",
    ],
    correctAnswer: "B",
    explanation: "System.out.println(myObj1.x); // Output: 5; System.out.println(myObj2.x); // Output: 5.",
    source: "Page 8 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 25,
    question: "In the example, what are myObj1 and myObj2?",
    options: [
      "The same object.",
      "Separate objects.",
      "Methods.",
      "Classes.",
    ],
    correctAnswer: "B",
    explanation: "myObj1 and myObj2 are separate objects.",
    source: "Page 8 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 26,
    question: "In the example, what does each object contain?",
    options: [
      "Shared variable x.",
      "Its own copy of variable x.",
      "No variable x.",
      "Static variable x.",
    ],
    correctAnswer: "B",
    explanation: "Each object contains its own copy of variable x.",
    source: "Page 8 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 27,
    question: "What happens when changing one object's state in multiple objects?",
    options: [
      "It affects all objects.",
      "Does not affect the other.",
      "Causes an error.",
      "Shares the change.",
    ],
    correctAnswer: "B",
    explanation: "Changing one object's state does not affect the other.",
    source: "Page 8 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 28,
    question: "What does Java allow in terms of classes and objects?",
    options: [
      "Creating an object in one class and accessing it from another class.",
      "Only single class usage.",
      "No object access across classes.",
      "Global objects only.",
    ],
    correctAnswer: "A",
    explanation: "Java allows creating an object in one class and accessing it from another class.",
    source: "Page 9 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 29,
    question: "What does using multiple classes help with?",
    options: [
      "Disorganize code.",
      "Organize code: One class holds attributes and methods, the other contains the main() method for execution.",
      "Prevent compilation.",
      "Share global functions.",
    ],
    correctAnswer: "B",
    explanation: "This approach helps organize code: One class holds attributes and methods; The other class contains the main() method for execution.",
    source: "Page 9 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 30,
    question: "What is the file structure example for multiple classes?",
    options: [
      "All in one file.",
      "Main.java — defines the class and its data; Second.java — contains the main() method and uses the Main class.",
      "No separate files.",
      "Only public files.",
    ],
    correctAnswer: "B",
    explanation: "Main.java — defines the class and its data; Second.java — contains the main() method and uses the Main class.",
    source: "Page 10 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 31,
    question: "In Main.java: public class Main { int x = 5; }, what is this?",
    options: [
      "The execution file.",
      "Defines the class and its data.",
      "Contains main().",
      "Accesses the object.",
    ],
    correctAnswer: "B",
    explanation: "Main.java example showing class definition.",
    source: "Page 10 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 32,
    question: "In Second.java below, what is this? class Second { public static void main(String[] args) { Main myObj = new Main(); System.out.println(myObj.x); } }",
    options: [
      "Defines attributes.",
      "Contains the main() method and uses the Main class.",
      "Creates a class only.",
      "Modifies x.",
    ],
    correctAnswer: "B",
    explanation: "Second.java example showing main() method usage.",
    source: "Page 10 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 33,
    question: "What are the commands for compilation and execution in multiple classes example?",
    options: [
      "javac Second.java; java Main",
      "javac Main.java; javac Second.java; java Second",
      "java Main; java Second",
      "javac all.java; java all",
    ],
    correctAnswer: "B",
    explanation: "javac Main.java; javac Second.java; java Second.",
    source: "Page 10 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 34,
    question: "What is the output of the multiple classes example?",
    options: [
      "0",
      "5",
      "Error",
      "null",
    ],
    correctAnswer: "B",
    explanation: "Output: 5.",
    source: "Page 10 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 35,
    question: "What must be true for the .java files in multiple classes?",
    options: [
      "In different directories.",
      "Both .java files must be in the same directory.",
      "No directory required.",
      "In separate projects.",
    ],
    correctAnswer: "B",
    explanation: "Both .java files must be in the same directory.",
    source: "Page 10 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 36,
    question: "What must the file name match if the class is declared public?",
    options: [
      "The method name.",
      "The class name.",
      "The object name.",
      "The attribute name.",
    ],
    correctAnswer: "B",
    explanation: "The file name must match the class name if the class is declared public.",
    source: "Page 10 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 37,
    question: "What are class attributes in Java?",
    options: [
      "Methods defined inside methods.",
      "Variables defined inside a class but outside any method.",
      "Constructors.",
      "Static functions.",
    ],
    correctAnswer: "B",
    explanation: "In Java, class attributes are variables defined inside a class but outside any method.",
    source: "Page 11 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 38,
    question: "What do attributes represent?",
    options: [
      "The behavior of an object.",
      "The state (data) of an object.",
      "The initialization.",
      "The execution.",
    ],
    correctAnswer: "B",
    explanation: "They represent the state (data) of an object.",
    source: "Page 11 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 39,
    question: "What are class attributes also known as?",
    options: [
      "Methods or behaviors.",
      "Fields or instance variables.",
      "Parameters or arguments.",
      "Classes or objects.",
    ],
    correctAnswer: "B",
    explanation: "Also known as fields or instance variables.",
    source: "Page 11 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 40,
    question: "In the explanation, what are x and y?",
    options: [
      "Methods of the class Main.",
      "Attributes of the class Main.",
      "Objects.",
      "Constructors.",
    ],
    correctAnswer: "B",
    explanation: "x and y are attributes of the class Main.",
    source: "Page 11 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 41,
    question: "What will each object of Main have?",
    options: [
      "Shared attributes.",
      "Its own copy of these attributes.",
      "No attributes.",
      "Static attributes.",
    ],
    correctAnswer: "B",
    explanation: "Each object of Main will have its own copy of these attributes.",
    source: "Page 11 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 42,
    question: "How are attributes accessed?",
    options: [
      "Using className.attributeName.",
      "Using objectName.attributeName (e.g., myObj.x).",
      "Using method calls only.",
      "Using new keyword.",
    ],
    correctAnswer: "B",
    explanation: "Attributes are accessed using objectName.attributeName (e.g., myObj.x).",
    source: "Page 11 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 43,
    question: "In the example: public class Main { int x = 5; int y = 3; }, what does this show?",
    options: [
      "Methods declaration.",
      "Attributes x and y.",
      "Object creation.",
      "Constructor.",
    ],
    correctAnswer: "B",
    explanation: "Example showing class attributes.",
    source: "Page 11 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 44,
    question: "What can attributes have?",
    options: [
      "Only public modifiers.",
      "Access modifiers: public, private, or protected.",
      "No modifiers.",
      "Static only.",
    ],
    correctAnswer: "B",
    explanation: "Attributes can have access modifiers: public, private, or protected.",
    source: "Page 11 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 45,
    question: "What can be given to attributes when declared?",
    options: [
      "No values.",
      "Default values.",
      "Only null.",
      "Methods.",
    ],
    correctAnswer: "B",
    explanation: "They can be given default values when declared.",
    source: "Page 11 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 46,
    question: "What can you do with an attribute's value after an object is created?",
    options: [
      "Cannot modify it.",
      "Modify the value of an attribute.",
      "Delete it.",
      "Make it static.",
    ],
    correctAnswer: "B",
    explanation: "You can modify the value of an attribute after an object is created.",
    source: "Page 12 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 47,
    question: "What operator is used to access and update the attribute?",
    options: [
      "Colon operator.",
      "Dot operator.",
      "Arrow operator.",
      "Comma operator.",
    ],
    correctAnswer: "B",
    explanation: "Use the dot operator to access and update the attribute.",
    source: "Page 12 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 48,
    question: "In the example code below, what is the output? public class Main { int x; public static void main(String[] args) { Main myObj = new Main(); myObj.x = 40; System.out.println(myObj.x); } }",
    options: [
      "0",
      "5",
      "40",
      "null",
    ],
    correctAnswer: "C",
    explanation: "System.out.println(myObj.x); // Output: 40.",
    source: "Page 12 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 49,
    question: "In the example, what does myObj.x = 40; do?",
    options: [
      "Creates the object.",
      "Assigns a new value to the attribute x.",
      "Prints the value.",
      "Defines the class.",
    ],
    correctAnswer: "B",
    explanation: "myObj.x = 40; assigns a new value to the attribute x.",
    source: "Page 12 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 50,
    question: "What is the value updated for in modifying attributes?",
    options: [
      "All objects.",
      "Specifically for the object myObj.",
      "The class.",
      "Static fields.",
    ],
    correctAnswer: "B",
    explanation: "The value is updated specifically for the object myObj.",
    source: "Page 12 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 51,
    question: "What does modifying an attribute affect?",
    options: [
      "All objects.",
      "Only that particular object.",
      "The class definition.",
      "No effect.",
    ],
    correctAnswer: "B",
    explanation: "Modifying an attribute only affects that particular object.",
    source: "Page 12 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 52,
    question: "What does each object have regarding attributes?",
    options: [
      "Shared copies.",
      "Its own independent copy of the attributes.",
      "No copies.",
      "Global copies.",
    ],
    correctAnswer: "B",
    explanation: "Each object has its own independent copy of the attributes.",
    source: "Page 12 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 53,
    question: "What can you do with default attribute values after object creation?",
    options: [
      "Cannot override.",
      "Override default attribute values.",
      "Delete them.",
      "Make them final.",
    ],
    correctAnswer: "B",
    explanation: "You can override default attribute values after object creation.",
    source: "Page 13 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 54,
    question: "What operator is used to assign a new value in overriding?",
    options: [
      "Equals operator.",
      "Dot operator (.).",
      "Plus operator.",
      "Arrow operator.",
    ],
    correctAnswer: "B",
    explanation: "Use the dot operator (.) to assign a new value.",
    source: "Page 13 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 55,
    question: "In the example code below, what is the output? public class Main { int x = 10; public static void main(String[] args) { Main myObj = new Main(); myObj.x = 25; System.out.println(myObj.x); } }",
    options: [
      "10",
      "25",
      "0",
      "Error",
    ],
    correctAnswer: "B",
    explanation: "System.out.println(myObj.x); // Output: 25.",
    source: "Page 13 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 56,
    question: "In the example, what was the attribute x initially set to?",
    options: [
      "25",
      "10",
      "0",
      "null",
    ],
    correctAnswer: "B",
    explanation: "The attribute x was initially set to 10.",
    source: "Page 13 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 57,
    question: "In the example, what happens with myObj.x = 25;?",
    options: [
      "It is initialized.",
      "It is overridden.",
      "It causes error.",
      "It remains 10.",
    ],
    correctAnswer: "B",
    explanation: "It is overridden with myObj.x = 25;.",
    source: "Page 13 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 58,
    question: "What does overriding affect?",
    options: [
      "The class definition.",
      "Only the specific object (myObj) and not the class definition.",
      "All objects.",
      "Static variables.",
    ],
    correctAnswer: "B",
    explanation: "Overriding affects only the specific object (myObj) and not the class definition.",
    source: "Page 13 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 59,
    question: "What is a common way to customize object state at runtime?",
    options: [
      "Using constructors only.",
      "Overriding.",
      "Final keyword.",
      "Static methods.",
    ],
    correctAnswer: "B",
    explanation: "This is a common way to customize object state at runtime.",
    source: "Page 13 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 60,
    question: "How do you make an attribute constant and unchangeable?",
    options: [
      "Declare it with public.",
      "Declare it with the final keyword.",
      "Use static.",
      "Use private.",
    ],
    correctAnswer: "B",
    explanation: "To make an attribute constant and unchangeable, declare it with the final keyword.",
    source: "Page 14 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 61,
    question: "What must happen with a final variable?",
    options: [
      "Assigned multiple times.",
      "Assigned once, and cannot be modified later.",
      "Not assigned.",
      "Assigned in methods only.",
    ],
    correctAnswer: "B",
    explanation: "A final variable must be assigned once, and cannot be modified later.",
    source: "Page 14 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 62,
    question: "In the example code below, what happens when trying to assign myObj.x = 25;? public class Main { final int x = 10; public static void main(String[] args) { Main myObj = new Main(); myObj.x = 25; // What happens here? System.out.println(myObj.x); } }",
    options: [
      "It succeeds.",
      "Error: cannot assign a value to a final variable.",
      "Prints 25.",
      "Prints 10 and changes.",
    ],
    correctAnswer: "B",
    explanation: "myObj.x = 25; // Error: cannot assign a value to a final variable.",
    source: "Page 14 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 63,
    question: "In the example, what does final int x = 10; create?",
    options: [
      "A variable.",
      "A constant.",
      "A method.",
      "An object.",
    ],
    correctAnswer: "B",
    explanation: "final int x = 10; creates a constant.",
    source: "Page 14 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 64,
    question: "What happens when attempting to assign a new value to x?",
    options: [
      "It updates.",
      "Causes a compile-time error.",
      "Runtime error.",
      "No effect.",
    ],
    correctAnswer: "B",
    explanation: "Attempting to assign a new value to x causes a compile-time error.",
    source: "Page 14 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 65,
    question: "What is final useful for?",
    options: [
      "Changing values.",
      "Values that should never change (e.g., PI = 3.14159).",
      "Temporary variables.",
      "Method parameters.",
    ],
    correctAnswer: "B",
    explanation: "final is useful for values that should never change (e.g., PI = 3.14159).",
    source: "Page 14 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 66,
    question: "What is final in Java?",
    options: [
      "A keyword for methods only.",
      "A modifier.",
      "A data type.",
      "An access level.",
    ],
    correctAnswer: "B",
    explanation: "final is a modifier in Java.",
    source: "Page 14 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 67,
    question: "When will you learn more about modifiers like public, static, and final?",
    options: [
      "In this chapter.",
      "In later chapters.",
      "Not mentioned.",
      "In previous chapters.",
    ],
    correctAnswer: "B",
    explanation: "You will learn more about modifiers like public, static, and final in later chapters.",
    source: "Page 14 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 68,
    question: "When creating multiple objects from the same class, what does each object have?",
    options: [
      "Shared copies of the class attributes.",
      "Its own copy of the class attributes.",
      "No attributes.",
      "Global attributes.",
    ],
    correctAnswer: "B",
    explanation: "When you create multiple objects from the same class, each object has its own copy of the class attributes.",
    source: "Page 15 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 69,
    question: "What happens when modifying the attribute in one object?",
    options: [
      "Affects all objects.",
      "Does not affect the other.",
      "Causes shared change.",
      "Errors out.",
    ],
    correctAnswer: "B",
    explanation: "Modifying the attribute in one object does not affect the other.",
    source: "Page 15 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 70,
    question: "In the example code below, what are the outputs? public class Main { int x = 5; public static void main(String[] args) { Main myObj1 = new Main(); // Object 1 Main myObj2 = new Main(); // Object 2 myObj2.x = 25; System.out.println(myObj1.x); System.out.println(myObj2.x); } }",
    options: [
      "25 and 25",
      "5 and 25",
      "5 and 5",
      "25 and 5",
    ],
    correctAnswer: "B",
    explanation: "System.out.println(myObj1.x); // Outputs 5; System.out.println(myObj2.x); // Outputs 25.",
    source: "Page 15 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 71,
    question: "In the example, what are myObj1 and myObj2?",
    options: [
      "The same.",
      "Two separate objects.",
      "Methods.",
      "Classes.",
    ],
    correctAnswer: "B",
    explanation: "myObj1 and myObj2 are two separate objects.",
    source: "Page 15 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 72,
    question: "In the example, where is x changed?",
    options: [
      "In myObj1.",
      "Only in myObj2.",
      "In both.",
      "In none.",
    ],
    correctAnswer: "B",
    explanation: "x is changed only in myObj2.",
    source: "Page 15 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 73,
    question: "What does each object do with its state?",
    options: [
      "Shares it.",
      "Maintains its own independent state.",
      "Loses it.",
      "Copies from others.",
    ],
    correctAnswer: "B",
    explanation: "Each object maintains its own independent state.",
    source: "Page 15 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 74,
    question: "What is this behavior essential in?",
    options: [
      "Procedural programming.",
      "Object-oriented programming.",
      "Functional programming.",
      "Scripting.",
    ],
    correctAnswer: "B",
    explanation: "This behavior is essential in object-oriented programming.",
    source: "Page 15 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 75,
    question: "What does it allow different objects to do?",
    options: [
      "Behave the same.",
      "Behave differently, even if created from the same class.",
      "Share behavior.",
      "Not behave.",
    ],
    correctAnswer: "B",
    explanation: "It allows different objects to behave differently, even if created from the same class.",
    source: "Page 15 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 76,
    question: "What can a Java class have?",
    options: [
      "Only one attribute.",
      "Multiple attributes of different data types.",
      "No attributes.",
      "Only string attributes.",
    ],
    correctAnswer: "B",
    explanation: "A Java class can have multiple attributes of different data types.",
    source: "Page 16 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 77,
    question: "What do these attributes define?",
    options: [
      "The behavior only.",
      "The state and identity of each object.",
      "The methods.",
      "The constructors.",
    ],
    correctAnswer: "B",
    explanation: "These attributes define the state and identity of each object.",
    source: "Page 16 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 78,
    question: "In the example code below, what attributes are defined? public class Main { String fname = \" John\" ; String lname = \" Doe\" ; int age = 24; public static void main(String[] args) { Main myObj = new Main(); System.out.println(\" Name: \" + myObj.fname + \" \" + myObj.lname); System.out.println(\" Age: \" + myObj.age); } }",
    options: [
      "fname, lname, age.",
      "name, age, id.",
      "first, last, years.",
      "str1, str2, num.",
    ],
    correctAnswer: "A",
    explanation: "The class Main defines three attributes: fname, lname, and age.",
    source: "Page 16 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 79,
    question: "In the example, what does the object myObj access?",
    options: [
      "Methods only.",
      "All attributes.",
      "No attributes.",
      "Static fields.",
    ],
    correctAnswer: "B",
    explanation: "An object myObj is created and accesses all attributes.",
    source: "Page 16 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 80,
    question: "What is the output of the example?",
    options: [
      "Name: John Doe Age: 24",
      "Name: Doe John Age: 24",
      "Age: 24 Name: John Doe",
      "Error",
    ],
    correctAnswer: "A",
    explanation: "Output: Name: John Doe Age: 24.",
    source: "Page 16 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 81,
    question: "What can attributes be of?",
    options: [
      "Only int.",
      "Any valid Java data type: int, double, String, boolean, etc.",
      "Only String.",
      "No data types.",
    ],
    correctAnswer: "B",
    explanation: "Attributes can be of any valid Java data type: int, double, String, boolean, etc.",
    source: "Page 16 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 82,
    question: "What should you use for attributes to improve code readability?",
    options: [
      "Short names.",
      "Meaningful names.",
      "Random names.",
      "No names.",
    ],
    correctAnswer: "B",
    explanation: "Use meaningful names to improve code readability.",
    source: "Page 16 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 83,
    question: "Where are methods declared in Java?",
    options: [
      "Outside classes.",
      "Inside a class.",
      "In objects only.",
      "In main only.",
    ],
    correctAnswer: "B",
    explanation: "In Java, methods are declared inside a class.",
    source: "Page 17 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 84,
    question: "What does a method define?",
    options: [
      "Data only.",
      "An action or behavior that objects or the class can perform.",
      "Classes.",
      "Attributes.",
    ],
    correctAnswer: "B",
    explanation: "A method defines an action or behavior that objects or the class can perform.",
    source: "Page 17 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 85,
    question: "What do methods improve?",
    options: [
      "Code disorganization.",
      "Code organization and reusability.",
      "Errors.",
      "Compilation time.",
    ],
    correctAnswer: "B",
    explanation: "Methods improve code organization and reusability.",
    source: "Page 17 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 86,
    question: "In the example code below, what is myMethod()? public class Main { static void myMethod() { System.out.println(\" Hello World!\" ); } }",
    options: [
      "A public method.",
      "A static method.",
      "A constructor.",
      "An attribute.",
    ],
    correctAnswer: "B",
    explanation: "myMethod() is a static method, meaning it belongs to the class, not to any instance.",
    source: "Page 17 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 87,
    question: "What does the method do when called?",
    options: [
      "Nothing.",
      "Prints \"Hello World!\".",
      "Creates object.",
      "Modifies attribute.",
    ],
    correctAnswer: "B",
    explanation: "It prints \"Hello World!\" when called.",
    source: "Page 17 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 88,
    question: "What do you need to do to execute the method?",
    options: [
      "Define it only.",
      "Call this method (e.g., from main() method).",
      "Use new.",
      "Use final.",
    ],
    correctAnswer: "B",
    explanation: "You'll need to call this method (e.g., from main() method) to execute it.",
    source: "Page 17 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 89,
    question: "What must a method have?",
    options: [
      "No return type.",
      "A return type, e.g., void, int, String.",
      "Only void.",
      "Only int.",
    ],
    correctAnswer: "B",
    explanation: "A method must have a return type, e.g., void, int, String.",
    source: "Page 17 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 90,
    question: "What can methods also do?",
    options: [
      "Only execute.",
      "Receive parameters and return values (to be learned in later slides).",
      "Create classes.",
      "Define attributes.",
    ],
    correctAnswer: "B",
    explanation: "Methods can also receive parameters and return values (to be learned in later slides).",
    source: "Page 17 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 91,
    question: "How do you execute a method?",
    options: [
      "Define it.",
      "Call it by its name, followed by parentheses () and a semicolon ;.",
      "Use new.",
      "Use dot operator only.",
    ],
    correctAnswer: "B",
    explanation: "To execute a method, call it by its name, followed by parentheses () and a semicolon ;.",
    source: "Page 18 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 92,
    question: "If the method is static, how can you call it?",
    options: [
      "Only with object.",
      "Directly from the main() method.",
      "No call needed.",
      "With final.",
    ],
    correctAnswer: "B",
    explanation: "If the method is static, you can call it directly from the main() method.",
    source: "Page 18 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 93,
    question: "In the example code below, what is myMethod();? public class Main { static void myMethod() { System.out.println(\" Hello World!\" ); } public static void main(String[] args) { myMethod(); // Method call } }",
    options: [
      "Definition.",
      "Method call.",
      "Object creation.",
      "Attribute access.",
    ],
    correctAnswer: "B",
    explanation: "myMethod(); // Method call.",
    source: "Page 18 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 94,
    question: "In the example, how is myMethod() called?",
    options: [
      "With object.",
      "Directly from main() without creating an object.",
      "In constructor.",
      "Statically with class name.",
    ],
    correctAnswer: "B",
    explanation: "It is called directly from main() without creating an object.",
    source: "Page 18 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 95,
    question: "What is the output?",
    options: [
      "Nothing.",
      "Hello World!",
      "Error.",
      "5",
    ],
    correctAnswer: "B",
    explanation: "Output: Hello World!.",
    source: "Page 18 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 96,
    question: "When must a method be defined?",
    options: [
      "After call.",
      "Before or within scope of where you call it.",
      "No order.",
      "In separate file.",
    ],
    correctAnswer: "B",
    explanation: "You must define a method before or within scope of where you call it.",
    source: "Page 18 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 97,
    question: "What are required even if no parameters?",
    options: [
      "Brackets [].",
      "Parentheses ().",
      "Braces {}.",
      "No symbols.",
    ],
    correctAnswer: "B",
    explanation: "Parentheses () are required even if the method takes no parameters.",
    source: "Page 18 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 98,
    question: "What does a static method belong to?",
    options: [
      "The object.",
      "The class, can be called without creating an object.",
      "The attribute.",
      "The constructor.",
    ],
    correctAnswer: "B",
    explanation: "static method: belongs to the class, can be called without creating an object.",
    source: "Page 19 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 99,
    question: "What does a public method belong to?",
    options: [
      "The class.",
      "An object, must be called through an instance of the class.",
      "Static fields.",
      "Global.",
    ],
    correctAnswer: "B",
    explanation: "public method: belongs to an object, must be called through an instance of the class.",
    source: "Page 19 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 100,
    question: "In the example code below, what is this demonstrating? public class Main { // Static method static void myStaticMethod() { System.out.println(\" Static methods can be called without creating objects\" ); } // Public method public void myPublicMethod() { System.out.println(\" Public methods must be called by creating objects\" ); } public static void main(String[] args) { myStaticMethod(); // ✓ Works without object // myPublicMethod(); // ✗ Error: needs an object Main myObj = new Main(); // Create object myObj.myPublicMethod(); // ✓ Call public method via object } }",
    options: [
      "With object.",
      "Without object.",
      "Error.",
      "In constructor.",
    ],
    correctAnswer: "B",
    explanation: "myStaticMethod(); // ✓ Works without object.",
    source: "Page 20 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 101,
    question: "How is myPublicMethod() called?",
    options: [
      "Directly.",
      "By creating objects.",
      "Static call.",
      "No call.",
    ],
    correctAnswer: "B",
    explanation: "myObj.myPublicMethod(); // ✓ Call public method via object.",
    source: "Page 20 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 102,
    question: "What do static methods belong to and how are they called?",
    options: [
      "Objects, through instance.",
      "The class and can be called without creating objects.",
      "Attributes.",
      "Constructors.",
    ],
    correctAnswer: "B",
    explanation: "Static methods belong to the class and can be called without creating objects.",
    source: "Page 20 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 103,
    question: "What do public methods belong to and how are they called?",
    options: [
      "Class, directly.",
      "Objects and must be called through an instance of the class.",
      "No call needed.",
      "Globally.",
    ],
    correctAnswer: "B",
    explanation: "Public methods belong to objects and must be called through an instance of the class.",
    source: "Page 20 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 104,
    question: "How are static methods called?",
    options: [
      "Through object.",
      "Directly.",
      "With new.",
      "With this.",
    ],
    correctAnswer: "B",
    explanation: "Static methods are called directly.",
    source: "Page 20 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 105,
    question: "What do public methods require first?",
    options: [
      "No object.",
      "Object creation.",
      "Static declaration.",
      "Final.",
    ],
    correctAnswer: "B",
    explanation: "While public methods require object creation first.",
    source: "Page 20 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 106,
    question: "For static, how is access and requires object?",
    options: [
      "objectName.methodName(), Yes.",
      "ClassName.methodName(), No.",
      "No access.",
      "Parameter only.",
    ],
    correctAnswer: "B",
    explanation: "static ClassName.methodName() No.",
    source: "Page 21 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 107,
    question: "For public, how is access and requires object?",
    options: [
      "ClassName.methodName(), No.",
      "objectName.methodName(), Yes.",
      "Direct call, No.",
      "No object.",
    ],
    correctAnswer: "B",
    explanation: "public objectName.methodName() Yes.",
    source: "Page 21 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 108,
    question: "What does public control?",
    options: [
      "How accessed.",
      "Visibility, while static controls how a method is accessed.",
      "Data types.",
      "Return types.",
    ],
    correctAnswer: "B",
    explanation: "public controls visibility, while static controls how a method is accessed.",
    source: "Page 21 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 109,
    question: "What can you do with public and static?",
    options: [
      "Cannot combine.",
      "Combine both: public static void.",
      "Only public.",
      "Only static.",
    ],
    correctAnswer: "B",
    explanation: "You can combine both: public static void.",
    source: "Page 21 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 110,
    question: "What is Java?",
    options: [
      "A language with global functions.",
      "A pure object-oriented language.",
      "Functional.",
      "Procedural.",
    ],
    correctAnswer: "B",
    explanation: "Java is a pure object-oriented language.",
    source: "Page 22 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 111,
    question: "Where must all methods be defined?",
    options: [
      "Outside classes.",
      "Inside a class.",
      "Globally.",
      "In main.",
    ],
    correctAnswer: "B",
    explanation: "Therefore, all methods must be defined inside a class.",
    source: "Page 22 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 112,
    question: "Are global functions allowed in Java?",
    options: [
      "Yes.",
      "Not allowed.",
      "Only in C++.",
      "Optional.",
    ],
    correctAnswer: "B",
    explanation: "Global functions (functions outside of any class) are not allowed in Java.",
    source: "Page 22 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 113,
    question: "In C++, are global functions allowed?",
    options: [
      "No.",
      "Allowed (e.g. int add()).",
      "Only in classes.",
      "Not mentioned.",
    ],
    correctAnswer: "B",
    explanation: "Global Function Allowed (e.g. int add()).",
    source: "Page 22 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 114,
    question: "In Java, are global functions allowed?",
    options: [
      "Allowed.",
      "Not Allowed.",
      "Optional.",
      "In classes only.",
    ],
    correctAnswer: "B",
    explanation: "Not Allowed.",
    source: "Page 22 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 115,
    question: "Are class methods allowed in both?",
    options: [
      "Only in Java.",
      "Allowed in both.",
      "Only in C++.",
      "Not allowed.",
    ],
    correctAnswer: "B",
    explanation: "Class Method Allowed Required.",
    source: "Page 22 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 116,
    question: "What is code structure in C++?",
    options: [
      "Class-based only.",
      "Function-based or class-based.",
      "Object-based.",
      "No structure.",
    ],
    correctAnswer: "B",
    explanation: "Code Structure Function-based or class-based.",
    source: "Page 22 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 117,
    question: "What is code structure in Java?",
    options: [
      "Function-based.",
      "Class-based only.",
      "Global.",
      "Mixed.",
    ],
    correctAnswer: "B",
    explanation: "Class-based only.",
    source: "Page 22 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 118,
    question: "Why is the code below invalid in Java? // ❌ This will cause a compilation error int add(int a, int b) { return a + b; }",
    options: [
      "Inside class.",
      "This will cause a compilation error (global function).",
      "Valid.",
      "No return.",
    ],
    correctAnswer: "B",
    explanation: "// ❌ This will cause a compilation error int add(int a, int b) { return a + b; }.",
    source: "Page 23 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 119,
    question: "In the valid Java code below, how is it called? public class MathUtils { public static int add(int a, int b) { return a + b; } }",
    options: [
      "add(2, 3);",
      "MathUtils.add(2, 3);",
      "new add();",
      "Global add.",
    ],
    correctAnswer: "B",
    explanation: "Call with: MathUtils.add(2, 3);.",
    source: "Page 23 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 120,
    question: "What is true in Java?",
    options: [
      "Standalone functions.",
      "Everything lives inside a class — there are no standalone functions.",
      "Global allowed.",
      "Functions outside.",
    ],
    correctAnswer: "B",
    explanation: "In Java, everything lives inside a class — there are no standalone functions.",
    source: "Page 23 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 121,
    question: "To call non-static methods, what must you do?",
    options: [
      "Call directly.",
      "Create an object of the class.",
      "Use static.",
      "Use global.",
    ],
    correctAnswer: "B",
    explanation: "To call non-static methods, you must create an object of the class.",
    source: "Page 24 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 122,
    question: "What operator is used to access methods on the object?",
    options: [
      "Colon.",
      "Dot (.).",
      "Arrow.",
      "Comma.",
    ],
    correctAnswer: "B",
    explanation: "Use the dot (.) operator to access methods on the object.",
    source: "Page 24 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 123,
    question: "In the example code below, what are myCar.fullThrottle() and myCar.speed(200)? public class Main { public void fullThrottle() { System.out.println(\" Full speed!\" ); } public void speed(int max) { System.out.println(\"Max: \" + max); } public static void main(String[] args) { Main myCar = new Main(); myCar.fullThrottle(); myCar.speed(200); } }",
    options: [
      "Static calls.",
      "Calls to instance methods.",
      "Constructors.",
      "Attributes.",
    ],
    correctAnswer: "B",
    explanation: "myCar.fullThrottle() and myCar.speed(200) call instance methods.",
    source: "Page 24 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 124,
    question: "What does each method do?",
    options: [
      "Nothing.",
      "Runs actions defined in the class.",
      "Creates objects.",
      "Modifies class.",
    ],
    correctAnswer: "B",
    explanation: "Each method runs actions defined in the class.",
    source: "Page 24 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 125,
    question: "What are these methods?",
    options: [
      "Static.",
      "Public and non-static.",
      "Final.",
      "Private.",
    ],
    correctAnswer: "B",
    explanation: "These methods are public and non-static, so they require an object to be called.",
    source: "Page 24 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 126,
    question: "What does a static field belong to?",
    options: [
      "Instances (objects).",
      "The class, not to instances (objects).",
      "Methods.",
      "Constructors.",
    ],
    correctAnswer: "B",
    explanation: "A static field belongs to the class, not to instances (objects).",
    source: "Page 25 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 127,
    question: "Who shares the same copy of the static field?",
    options: [
      "No one.",
      "All objects.",
      "Only one object.",
      "Classes only.",
    ],
    correctAnswer: "B",
    explanation: "All objects share the same copy of the static field.",
    source: "Page 25 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 128,
    question: "In the example code below, what is university? public class Student { static String university = \" UIT\" ; String name; }",
    options: [
      "Instance variable.",
      "Static field.",
      "Method.",
      "Constructor.",
    ],
    correctAnswer: "B",
    explanation: "static String university = \"UIT\";.",
    source: "Page 25 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 129,
    question: "In the usage code below, what does it print? Student s1 = new Student(); Student s2 = new Student(); System.out.println(s1.university); // UIT System.out.println(s2.university); // UIT",
    options: [
      "Different values.",
      "UIT for both.",
      "null.",
      "Error.",
    ],
    correctAnswer: "B",
    explanation: "System.out.println(s1.university); // UIT System.out.println(s2.university); // UIT.",
    source: "Page 25 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 130,
    question: "If s2.university = \"HCMUT\";, what happens to s1.university?",
    options: [
      "Remains UIT.",
      "Changes to HCMUT.",
      "Error.",
      "null.",
    ],
    correctAnswer: "B",
    explanation: "s2.university = \"HCMUT\"; System.out.println(s1.university); // HCMUT.",
    source: "Page 25 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 131,
    question: "What does changing static fields through one object do?",
    options: [
      "Affects only that object.",
      "Affects all objects.",
      "No effect.",
      "Affects class only.",
    ],
    correctAnswer: "B",
    explanation: "Changing static fields through one object affects all objects.",
    source: "Page 25 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 132,
    question: "What are static fields for?",
    options: [
      "Unique per object.",
      "Values shared by all instances: e.g., university name, tax rate, version number.",
      "Temporary data.",
      "Methods.",
    ],
    correctAnswer: "B",
    explanation: "For values shared by all instances: e.g., university name, tax rate, version number.",
    source: "Page 25 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 133,
    question: "What else are static fields for?",
    options: [
      "Individual IDs.",
      "Counters (e.g., auto-increment IDs).",
      "Behaviors.",
      "Parameters.",
    ],
    correctAnswer: "B",
    explanation: "For counters (e.g., auto-increment IDs).",
    source: "Page 25 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 134,
    question: "What is the purpose of static field?",
    options: [
      "Perform behavior.",
      "Store shared data.",
      "Call methods.",
      "Initialize objects.",
    ],
    correctAnswer: "B",
    explanation: "Purpose Store shared data.",
    source: "Page 26 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 135,
    question: "How can static field be accessed?",
    options: [
      "objectName.field.",
      "ClassName.field.",
      "Method call.",
      "Constructor.",
    ],
    correctAnswer: "B",
    explanation: "Access ClassName.field.",
    source: "Page 26 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 136,
    question: "Does static field require object?",
    options: [
      "Yes.",
      "No.",
      "Sometimes.",
      "Always.",
    ],
    correctAnswer: "B",
    explanation: "Object Needed? No.",
    source: "Page 26 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 137,
    question: "What is usage example for static field?",
    options: [
      "Utility logic.",
      "Global constants, counters.",
      "Instance data.",
      "Behaviors.",
    ],
    correctAnswer: "B",
    explanation: "Usage Example Global constants, counters.",
    source: "Page 26 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 138,
    question: "What is the purpose of static method?",
    options: [
      "Store data.",
      "Perform shared behavior.",
      "Attributes.",
      "Objects.",
    ],
    correctAnswer: "B",
    explanation: "Purpose Perform shared behavior.",
    source: "Page 26 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 139,
    question: "How is static method accessed?",
    options: [
      "objectName.method()",
      "ClassName.method()",
      "No access.",
      "With new.",
    ],
    correctAnswer: "B",
    explanation: "Access ClassName.method().",
    source: "Page 26 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 140,
    question: "Does static method require object?",
    options: [
      "Yes.",
      "No.",
      "Optional.",
      "For public.",
    ],
    correctAnswer: "B",
    explanation: "Object Needed? No.",
    source: "Page 26 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 141,
    question: "What is usage example for static method?",
    options: [
      "Shared data.",
      "Utility logic, tools.",
      "Instance variables.",
      "Constructors.",
    ],
    correctAnswer: "B",
    explanation: "Usage Example Utility logic, tools.",
    source: "Page 26 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 142,
    question: "What does static field belong to?",
    options: [
      "Instance.",
      "The class, not instance.",
      "Object.",
      "Method.",
    ],
    correctAnswer: "B",
    explanation: "Belongs to the class, not instance.",
    source: "Page 26 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 143,
    question: "In the example code below, how is it accessed? class Example { static int count = 0; } System.out.println(Example.count);",
    options: [
      "With object.",
      "Using ClassName.field.",
      "Method.",
      "Constructor.",
    ],
    correctAnswer: "B",
    explanation: "System.out.println(Example.count);.",
    source: "Page 26 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 144,
    question: "What does static method belong to?",
    options: [
      "Object.",
      "The class.",
      "Attribute.",
      "Parameter.",
    ],
    correctAnswer: "B",
    explanation: "Belongs to the class.",
    source: "Page 26 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 145,
    question: "How can static method be called?",
    options: [
      "With object only.",
      "Without creating objects.",
      "New required.",
      "Final.",
    ],
    correctAnswer: "B",
    explanation: "Can be called without creating objects.",
    source: "Page 26 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 146,
    question: "In the example code below, what is the result? class MathUtils { static int square(int x) { return x * x; } } MathUtils.square(5); // 25",
    options: [
      "0",
      "25",
      "Error",
      "5",
    ],
    correctAnswer: "B",
    explanation: "MathUtils.square(5); // 25.",
    source: "Page 26 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 147,
    question: "What does Java encourage for better organization?",
    options: [
      "All in one class.",
      "Separating code into multiple classes.",
      "Global functions.",
      "Single file.",
    ],
    correctAnswer: "B",
    explanation: "Java encourages separating code into multiple classes for better organization.",
    source: "Page 27 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 148,
    question: "What does one class define?",
    options: [
      "main only.",
      "Methods and attributes.",
      "Objects only.",
      "Static only.",
    ],
    correctAnswer: "B",
    explanation: "One class defines methods and attributes.",
    source: "Page 27 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 149,
    question: "What can another class contain?",
    options: [
      "Attributes only.",
      "The main() method and create objects from the first class.",
      "No main.",
      "Constructors only.",
    ],
    correctAnswer: "B",
    explanation: "Another class can contain the main() method and create objects from the first class.",
    source: "Page 27 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 150,
    question: "What is best practice for classes?",
    options: [
      "All in one file.",
      "Each class is saved in a separate file.",
      "No files.",
      "Combined files.",
    ],
    correctAnswer: "B",
    explanation: "Each class is saved in a separate file.",
    source: "Page 27 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 151,
    question: "What must the file name match?",
    options: [
      "Method name.",
      "The public class name.",
      "Object name.",
      "Attribute name.",
    ],
    correctAnswer: "B",
    explanation: "The file name must match the public class name.",
    source: "Page 27 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 152,
    question: "What is the example structure?",
    options: [
      "Single file.",
      "Main.java → defines methods; Second.java → contains main() and uses Main.",
      "No structure.",
      "Global.",
    ],
    correctAnswer: "B",
    explanation: "Main.java → defines methods Second.java → contains main() and uses Main.",
    source: "Page 27 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 153,
    question: "In Main.java code below, what does it define? public class Main { public void fullThrottle() { System.out.println(\" Full speed!\" ); } public void speed(int max) { System.out.println(\"Max: \" + max); } }",
    options: [
      "main().",
      "The car's behaviors.",
      "Objects.",
      "Static fields.",
    ],
    correctAnswer: "B",
    explanation: "Main defines the car's behaviors.",
    source: "Page 28 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 154,
    question: "In Second.java code below, what does it do? class Second { public static void main(String[] args) { Main myCar = new Main(); myCar.fullThrottle(); myCar.speed(200); } }",
    options: [
      "Defines behaviors.",
      "Creates the Main object and calls its methods.",
      "Static calls.",
      "Attributes.",
    ],
    correctAnswer: "B",
    explanation: "Second creates the Main object and calls its methods.",
    source: "Page 28 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 155,
    question: "What does this separation allow?",
    options: [
      "No reuse.",
      "Better code reuse across multiple programs.",
      "Errors.",
      "Single use.",
    ],
    correctAnswer: "B",
    explanation: "This separation allows better code reuse across multiple programs.",
    source: "Page 28 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 156,
    question: "What should only one class contain?",
    options: [
      "Methods.",
      "main() — that class is the entry point of your program.",
      "Attributes.",
      "Objects.",
    ],
    correctAnswer: "B",
    explanation: "Only one class should contain main() — that class is the entry point of your program.",
    source: "Page 28 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 157,
    question: "What is a constructor?",
    options: [
      "A regular method.",
      "A special method used to initialize objects.",
      "A destructor.",
      "A static field.",
    ],
    correctAnswer: "B",
    explanation: "A constructor is a special method used to initialize objects.",
    source: "Page 29 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 158,
    question: "When is a constructor called?",
    options: [
      "Manually",
      "Automatically when an object is created",
      "In main",
      "With dot",
    ],
    correctAnswer: "B",
    explanation: "It is automatically called when an object is created.",
    source: "Page 29 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 159,
    question: "What is it used for?",
    options: [
      "To destroy objects",
      "To set initial values for attributes",
      "To call methods",
      "To access fields",
    ],
    correctAnswer: "B",
    explanation: "Used to set initial values for attributes.",
    source: "Page 29 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 160,
    question: "In the example code below, what is the output? public class Main { int x; public Main() { // Constructor x = 5; } public static void main(String[] args) { Main myObj = new Main(); // Constructor is called System.out.println(myObj.x); // Outputs 5 } }",
    options: [
      "0",
      "5",
      "null",
      "Error",
    ],
    correctAnswer: "B",
    explanation: "System.out.println(myObj.x); // Outputs 5.",
    source: "Page 29 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 161,
    question: "In the example, when does the constructor Main() run?",
    options: [
      "In main",
      "When new Main() is called",
      "After print",
      "Before creation",
    ],
    correctAnswer: "B",
    explanation: "The constructor Main() runs when new Main() is called.",
    source: "Page 29 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 162,
    question: "What does it do to x?",
    options: [
      "Prints",
      "Sets x = 5",
      "Modifies object",
      "Creates class",
    ],
    correctAnswer: "B",
    explanation: "It sets x = 5, so myObj.x will print 5.",
    source: "Page 29 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 163,
    question: "What must the constructor name match?",
    options: [
      "Method name",
      "The class name",
      "Object name",
      "Attribute name",
    ],
    correctAnswer: "B",
    explanation: "Constructor name must match the class name.",
    source: "Page 29 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 164,
    question: "What return type does a constructor have?",
    options: [
      "void",
      "Does not have a return type (not even void)",
      "int",
      "String",
    ],
    correctAnswer: "B",
    explanation: "It does not have a return type (not even void).",
    source: "Page 29 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 165,
    question: "What happens if you don't define a constructor?",
    options: [
      "Error",
      "Java provides a default constructor",
      "No initialization",
      "Static one",
    ],
    correctAnswer: "B",
    explanation: "If you don't define one, Java provides a default constructor.",
    source: "Page 29 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 166,
    question: "What does the default constructor not do?",
    options: [
      "Set initial values",
      "Set initial values",
      "Create object",
      "Call methods",
    ],
    correctAnswer: "A",
    explanation: "The default constructor does not set initial values.",
    source: "Page 29 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 167,
    question: "What can constructors take?",
    options: [
      "No parameters",
      "Parameters to initialize object attributes with custom values",
      "Only int",
      "Static",
    ],
    correctAnswer: "B",
    explanation: "Constructors can take parameters to initialize object attributes with custom values.",
    source: "Page 30 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 168,
    question: "When is it useful?",
    options: [
      "For same initial initial states",
      "When you want different objects to have different initial states",
      "For no states",
      "For static",
    ],
    correctAnswer: "B",
    explanation: "Useful when you want different objects to have different initial states.",
    source: "Page 30 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 169,
    question: "In the example code below, what is the output? public class Main { int x; public Main(int y) { x = y; } public static void main(String[] args) { Main myObj = new Main(5); System.out.println(myObj.x); // Outputs 5 } }",
    options: [
      "0",
      "5",
      "y",
      "Error",
    ],
    correctAnswer: "B",
    explanation: "System.out.println(myObj.x); // Outputs 5.",
    source: "Page 30 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 170,
    question: "What does the constructor take?",
    options: [
      "String",
      "An int y as a parameter",
      "No parameter",
      "Double",
    ],
    correctAnswer: "B",
    explanation: "The constructor takes an int y as a parameter.",
    source: "Page 30 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 171,
    question: "What happens inside the constructor?",
    options: [
      "y = x",
      "x = y",
      "Print x",
      "Create y",
    ],
    correctAnswer: "B",
    explanation: "Inside the constructor, x = y.",
    source: "Page 30 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 172,
    question: "When calling new Main(5), what happens?",
    options: [
      "5 is ignored",
      "The value 5 is passed to the constructor → x = 5",
      "Error",
      "y = 5",
    ],
    correctAnswer: "B",
    explanation: "When calling new Main(5), the value 5 is passed to the constructor → x = 5.",
    source: "Page 30 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 173,
    question: "What can you define?",
    options: [
      "Only one constructor",
      "Multiple constructors (constructor overloading) with different parameter types or numbers",
      "No constructors",
      "Static only",
    ],
    correctAnswer: "B",
    explanation: "You can define multiple constructors (constructor overloading) with different parameter types or numbers.",
    source: "Page 30 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 174,
    question: "What does it allow?",
    options: [
      "No flexibility",
      "Flexibility in how objects are created",
      "Errors",
      "Single way",
    ],
    correctAnswer: "B",
    explanation: "This allows flexibility in how objects are created.",
    source: "Page 30 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 175,
    question: "What does Java allow in a class?",
    options: [
      "Only one constructor",
      "Multiple constructors with different parameters",
      "No constructors",
      "Global constructors",
    ],
    correctAnswer: "B",
    explanation: "Java allows a class to have multiple constructors with different parameters.",
    source: "Page 31 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 176,
    question: "What is this called?",
    options: [
      "Method overloading",
      "Constructor overloading",
      "Field overloading",
      "Object overloading",
    ],
    correctAnswer: "B",
    explanation: "This is called constructor overloading.",
    source: "Page 31 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 177,
    question: "What does it provide?",
    options: [
      "Rigidity",
      "Flexibility when creating objects with different initialization options",
      "Errors",
      "No options",
    ],
    correctAnswer: "B",
    explanation: "It provides flexibility when creating objects with different initialization options.",
    source: "Page 31 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 178,
    question: "In the example code below, what are the outputs? public class Main { int x; public Main() { x = 0; } public Main(int y) { x = y; } public static void main(String[] args) { Main a = new Main(); // x = 0 Main b = new Main(10); // x = 10 System.out.println(a.x); // 0 System.out.println(b.x); // 10 } }",
    options: [
      "0 and 10",
      "10 and 0",
      "0 and 0",
      "10 and 10",
    ],
    correctAnswer: "A",
    explanation: "System.out.println(a.x); // 0 System.out.println(b.x); // 10.",
    source: "Page 31 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 179,
    question: "How many constructors are there?",
    options: [
      "One",
      "Two: one with no arguments, one with int",
      "Three",
      "None",
    ],
    correctAnswer: "B",
    explanation: "Two constructors: one with no arguments, one with int.",
    source: "Page 31 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 180,
    question: "What does Java do when creating the object?",
    options: [
      "Picks random",
      "Picks the matching constructor",
      "Error if multiple",
      "Uses default only",
    ],
    correctAnswer: "B",
    explanation: "Java picks the matching constructor when creating the object.",
    source: "Page 31 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 181,
    question: "What must overloaded constructors have?",
    options: [
      "Same signatures",
      "Different signatures",
      "No parameters",
      "Return types",
    ],
    correctAnswer: "B",
    explanation: "Overloaded constructors must have different signatures.",
    source: "Page 31 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 182,
    question: "What does it allow?",
    options: [
      "Fixed creation",
      "Flexible object creation",
      "No creation",
      "Static creation",
    ],
    correctAnswer: "B",
    explanation: "Allows flexible object creation.",
    source: "Page 31 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 183,
    question: "What does the this keyword refer to?",
    options: [
      "Class",
      "The current object",
      "Parameter",
      "Static",
    ],
    correctAnswer: "B",
    explanation: "The this keyword refers to the current object.",
    source: "Page 32 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 184,
    question: "Where is this commonly used?",
    options: [
      "In methods only",
      "In constructors to distinguish between instance variables and parameters when they have the same name",
      "In static",
      "In global",
    ],
    correctAnswer: "B",
    explanation: "Commonly used in constructors to distinguish between instance variables and parameters when they have the same name.",
    source: "Page 32 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 185,
    question: "In the example code below, what is the output? public class Main { int x; public Main(int x) { this.x = x; } public static void main(String[] args) { Main obj = new Main(7); System.out.println(obj.x); // Outputs 7 } }",
    options: [
      "0",
      "7",
      "x",
      "Error",
    ],
    correctAnswer: "B",
    explanation: "System.out.println(obj.x); // Outputs 7.",
    source: "Page 32 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 186,
    question: "What does this.x refer to?",
    options: [
      "Parameter",
      "The class attribute",
      "Method",
      "Object",
    ],
    correctAnswer: "B",
    explanation: "this.x refers to the class attribute.",
    source: "Page 32 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 187,
    question: "What is x (on the right side)?",
    options: [
      "Attribute",
      "The constructor parameter",
      "Static",
      "Final",
    ],
    correctAnswer: "B",
    explanation: "x (on the right side) is the constructor parameter.",
    source: "Page 32 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 188,
    question: "What would happen without this?",
    options: [
      "Assigns correctly",
      "Java would assign the parameter to itself — and the attribute remains uninitialized",
      "Error",
      "Prints null",
    ],
    correctAnswer: "B",
    explanation: "Without this, Java would assign the parameter to itself — and the attribute remains uninitialized.",
    source: "Page 32 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 189,
    question: "When is using this optional?",
    options: [
      "Always required",
      "Optional unless names conflict, but it is a good habit to improve clarity",
      "Never use",
      "Only in conflicts",
    ],
    correctAnswer: "B",
    explanation: "Using this is optional unless names conflict, but it is a good habit to improve clarity.",
    source: "Page 32 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 190,
    question: "What is constructor chaining?",
    options: [
      "Calling methods",
      "One constructor calls another in the same class using this(...)",
      "Super call",
      "Static call",
    ],
    correctAnswer: "B",
    explanation: "Constructor chaining means one constructor calls another in the same class using this(...).",
    source: "Page 33 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 191,
    question: "What does it help?",
    options: [
      "Duplicate code",
      "Reuse initialization code and avoid duplication",
      "Errors",
      "No reuse",
    ],
    correctAnswer: "B",
    explanation: "Helps reuse initialization code and avoid duplication.",
    source: "Page 33 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 192,
    question: "In the example code below, what is the output? public class Main { int x, y; public Main() { this(5); y = 10; } public Main(int x) { this.x = x; } public static void main(String[] args) { Main obj = new Main(); System.out.println(obj.x + \" \" + obj.y); // 5 10 } }",
    options: [
      "0 0",
      "5 10",
      "10 5",
      "Error",
    ],
    correctAnswer: "B",
    explanation: "System.out.println(obj.x + \" \" + obj.y); // 5 10.",
    source: "Page 33 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 193,
    question: "What does Main() do?",
    options: [
      "Calls Main(int x) using this(5)",
      "Sets x=5 directly",
      "Error",
      "Calls super",
    ],
    correctAnswer: "A",
    explanation: "Main() calls Main(int x) using this(5).",
    source: "Page 33 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 194,
    question: "What happens after chaining?",
    options: [
      "Sets x=10",
      "Then it sets y = 10",
      "Prints",
      "Creates",
    ],
    correctAnswer: "B",
    explanation: "Then it sets y = 10.",
    source: "Page 33 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 195,
    question: "Where must constructor chaining be?",
    options: [
      "Last line",
      "The first line inside the constructor",
      "Any line",
      "Outside",
    ],
    correctAnswer: "B",
    explanation: "Constructor chaining must be the first line inside the constructor.",
    source: "Page 33 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 196,
    question: "What is this(...) used for?",
    options: [
      "Refer to variables",
      "Only for calling another constructor in the same class",
      "Super call",
      "Static",
    ],
    correctAnswer: "B",
    explanation: "Use this(...) only for calling another constructor in the same class.",
    source: "Page 33 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 197,
    question: "What not to confuse with?",
    options: [
      "this(...) with this. used to refer to instance variables",
      "this with super",
      "this with static",
      "this with final",
    ],
    correctAnswer: "A",
    explanation: "Do not confuse with this. used to refer to instance variables.",
    source: "Page 33 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 198,
    question: "What happens if you don't define a constructor?",
    options: [
      "Error",
      "Java provides a default constructor",
      "No initialization",
      "Static one",
    ],
    correctAnswer: "B",
    explanation: "If no constructor is defined, Java automatically provides a no-argument constructor.",
    source: "Page 34 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 199,
    question: "What is it called?",
    options: [
      "Custom constructor",
      "The default constructor",
      "Overloaded",
      "Parameterized",
    ],
    correctAnswer: "B",
    explanation: "This is called the default constructor.",
    source: "Page 34 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 200,
    question: "In the example code below, does it work? public class Main { int x; // No constructor defined } Main obj = new Main(); // ✅ works fine",
    options: [
      "No",
      "Yes",
      "Error",
      "Only with parameters",
    ],
    correctAnswer: "B",
    explanation: "Main obj = new Main(); // ✅ works fine.",
    source: "Page 34 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 201,
    question: "What does the compiler add?",
    options: [
      "public Main(int) {}",
      "public Main() {}",
      "void Main()",
      "static Main()",
    ],
    correctAnswer: "B",
    explanation: "The compiler adds: public Main() {}.",
    source: "Page 34 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 202,
    question: "What if you define any constructor?",
    options: [
      "Still adds default",
      "But if you define any constructor, Java does not add a default one",
      "Adds multiple",
      "No effect",
    ],
    correctAnswer: "B",
    explanation: "But if you define any constructor, Java does not add a default one.",
    source: "Page 34 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 203,
    question: "If you define any constructor, what happens?",
    options: [
      "Java still creates default",
      "Java will NOT automatically create a default constructor",
      "Error",
      "Adds it anyway",
    ],
    correctAnswer: "B",
    explanation: "If you define any constructor (with or without parameters), → Java will NOT automatically create a default constructor.",
    source: "Page 35 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 204,
    question: "In the example code below, what happens with new Main();? public class Main { int x; // Custom constructor public Main(int y) { x = y; } public static void main(String[] args) { Main obj = new Main(); // ❌ Compile-time error } }",
    options: [
      "Works",
      "Compile-time error",
      "Runtime error",
      "Prints 0",
    ],
    correctAnswer: "B",
    explanation: "Main obj = new Main(); // ❌ Compile-time error.",
    source: "Page 35 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 205,
    question: "Why no default?",
    options: [
      "No constructor exists",
      "Since a constructor already exists (Main(int y)), Java assumes you control all initialization, → It does not generate the no-arg constructor",
      "Default always added",
      "Parameters required",
    ],
    correctAnswer: "B",
    explanation: "Since a constructor already exists (Main(int y)), Java assumes you control all initialization, → It does not generate the no-arg constructor.",
    source: "Page 35 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 206,
    question: "How to use both ways?",
    options: [
      "Don't define any",
      "Define both constructors: public Main() {} public Main(int y) { ... }",
      "Use super",
      "Use this",
    ],
    correctAnswer: "B",
    explanation: "To use both ways, define both constructors: public Main() {} public Main(int y) { ... }.",
    source: "Page 35 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 207,
    question: "What does the default constructor not do?",
    options: [
      "Does not assign initial values to attributes",
      "Sets initial values",
      "Sets to 0",
      "Sets to null",
    ],
    correctAnswer: "A",
    explanation: "But this constructor does not assign initial values to attributes.",
    source: "Page 36 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 208,
    question: "In the example code below, what are the outputs? public class Main { int x; // default is 0 String name; // default is null // No constructor defined public static void main(String[] args) { Main obj = new Main(); System.out.println(obj.x); // 0 System.out.println(obj.name); // null } }",
    options: [
      "0 and null",
      "1 and \"name\"",
      "Error",
      "null and 0",
    ],
    correctAnswer: "A",
    explanation: "System.out.println(obj.x); // 0 System.out.println(obj.name); // null.",
    source: "Page 36 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 209,
    question: "What is default for int?",
    options: [
      "null",
      "0",
      "1",
      "\"\"",
    ],
    correctAnswer: "B",
    explanation: "→ int → 0.",
    source: "Page 36 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 210,
    question: "What is default for String?",
    options: [
      "0",
      "null",
      "\"\"",
      "false",
    ],
    correctAnswer: "B",
    explanation: "→ String → null.",
    source: "Page 36 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 211,
    question: "What is default for boolean?",
    options: [
      "true",
      "false",
      "null",
      "0",
    ],
    correctAnswer: "B",
    explanation: "→ boolean → false, etc.",
    source: "Page 36 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 212,
    question: "What is there no in default constructor?",
    options: [
      "No logic to customize or initialize values",
      "Full logic",
      "Custom values",
      "Complex initialization",
    ],
    correctAnswer: "A",
    explanation: "No logic to customize or initialize values.",
    source: "Page 36 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 213,
    question: "When to use custom constructor?",
    options: [
      "For default values",
      "If you need to initialize attributes explicitly",
      "Never",
      "For no initialization",
    ],
    correctAnswer: "B",
    explanation: "Use a custom constructor if you need to initialize attributes explicitly.",
    source: "Page 36 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 214,
    question: "Why need no-arg constructor: Required by some frameworks?",
    options: [
      "For manual creation",
      "Java libraries like Spring, Hibernate, or Jackson require a no-arg constructor to instantiate objects via reflection",
      "For errors",
      "No reason",
    ],
    correctAnswer: "B",
    explanation: "Java libraries like Spring, Hibernate, or Jackson require a no-arg constructor to instantiate objects via reflection.",
    source: "Page 37 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 215,
    question: "What may fail without it?",
    options: [
      "Compilation",
      "Deserialization or object mapping may fail",
      "Running",
      "No effect",
    ],
    correctAnswer: "B",
    explanation: "Without it, deserialization or object mapping may fail.",
    source: "Page 37 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 216,
    question: "In inheritance, what do subclasses call?",
    options: [
      "No constructor",
      "Superclass's no-arg constructor implicitly",
      "Own constructor only",
      "Static",
    ],
    correctAnswer: "B",
    explanation: "Subclasses implicitly call the superclass's no-arg constructor.",
    source: "Page 37 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 217,
    question: "What must subclass do if super class lacks no-arg?",
    options: [
      "Nothing",
      "Explicitly call another constructor using super(...)",
      "Error always",
      "Use this",
    ],
    correctAnswer: "B",
    explanation: "If the superclass lacks a no-arg constructor, the subclass must explicitly call another constructor using super(...).",
    source: "Page 37 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 218,
    question: "For simplicity, what can you do?",
    options: [
      "Pass arguments always",
      "Easily create objects without passing arguments: User user = new User();",
      "Complicate",
      "Use setters first",
    ],
    correctAnswer: "B",
    explanation: "Easily create objects without passing arguments: User user = new User();.",
    source: "Page 37 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 219,
    question: "What can you do with basic object?",
    options: [
      "Nothing",
      "Create a basic object and set values later using setters: User u = new User(); u.setName(\"Alice\");",
      "Set in constructor only",
      "No setters",
    ],
    correctAnswer: "B",
    explanation: "Create a basic object and set values later using setters: User u = new User(); u.setName(\"Alice\");.",
    source: "Page 37 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 220,
    question: "What is method overloading?",
    options: [
      "Single method",
      "Multiple methods in the same class with same name, but different parameter list",
      "Different names",
      "Global methods",
    ],
    correctAnswer: "B",
    explanation: "Multiple methods in the same class Same name, but different parameter list.",
    source: "Page 38 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 221,
    question: "What does it allow?",
    options: [
      "Different names",
      "Reuse the same method name for similar actions",
      "Errors",
      "No reuse",
    ],
    correctAnswer: "B",
    explanation: "Allows you to reuse the same method name for similar actions.",
    source: "Page 38 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 222,
    question: "In the code below, what are the returns? class Calculator { int add(int a, int b) { return a + b; } double add(double a, double b) { return a + b; } } Calculator c = new Calculator(); c.add(3, 4); // Returns 7 (int) c.add(3.5, 2.1); // Returns 5.6 (double)",
    options: [
      "7 (int) and 5.6 (double)",
      "7.0 and 5",
      "Error",
      "Same type",
    ],
    correctAnswer: "A",
    explanation: "c.add(3, 4); // Returns 7 (int) c.add(3.5, 2.1); // Returns 5.6 (double).",
    source: "Page 38 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 223,
    question: "Methods must differ by what?",
    options: [
      "Return type only",
      "Number of parameters, Type of parameters, Order of parameters",
      "Name",
      "Visibility",
    ],
    correctAnswer: "B",
    explanation: "Methods must differ by: Number of parameters Type of parameters Order of parameters.",
    source: "Page 38 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 224,
    question: "What is not enough alone?",
    options: [
      "Signature",
      "Return type",
      "Number",
      "Types",
    ],
    correctAnswer: "B",
    explanation: "Return type alone is not enough!.",
    source: "Page 38 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 225,
    question: "What does it improve?",
    options: [
      "Confusion",
      "Readability",
      "Errors",
      "No benefits",
    ],
    correctAnswer: "B",
    explanation: "Improves readability.",
    source: "Page 38 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 226,
    question: "What does it support?",
    options: [
      "Runtime polymorphism",
      "Polymorphism (compile-time/static polymorphism)",
      "No polymorphism",
      "Inheritance",
    ],
    correctAnswer: "B",
    explanation: "Supports polymorphism (compile-time/static polymorphism).",
    source: "Page 38 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 227,
    question: "What does it organize?",
    options: [
      "Unrelated operations",
      "Related operations under a single method name",
      "Classes",
      "Attributes",
    ],
    correctAnswer: "B",
    explanation: "Organizes related operations under a single method name.",
    source: "Page 38 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 228,
    question: "Is overloading by return type only allowed?",
    options: [
      "Yes",
      "NOT allowed",
      "Optional",
      "Always",
    ],
    correctAnswer: "B",
    explanation: "Overloading by return type only is NOT allowed.",
    source: "Page 39 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 229,
    question: "Why does Java not allow overloading based only on return type?",
    options: [
      "Signature includes return",
      "Java uses method signature to distinguish overloaded methods. Method signature = method name + parameter list. Return type is not part of the signature",
      "Return is part",
      "No signature",
    ],
    correctAnswer: "B",
    explanation: "Java uses method signature to distinguish overloaded methods. Method signature = method name + parameter list. Return type is not part of the signature.",
    source: "Page 39 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 230,
    question: "In the invalid example code below, what happens? class Test { int show(int x) { return x; } double show(int x) { // ❌ Invalid: same name and parameters return x * 1.0; } }",
    options: [
      "Works",
      "Compile-time error: method is already defined with the same signature",
      "Runtime error",
      "Prints double",
    ],
    correctAnswer: "B",
    explanation: "Compile-time error: method is already defined with the same signature.",
    source: "Page 39 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 231,
    question: "What are valid: int show(int x), double show(double x), int show(int x, int y)?",
    options: [
      "Same parameters",
      "All have different parameter lists",
      "Same lists",
      "Return only different",
    ],
    correctAnswer: "B",
    explanation: "All have different parameter lists.",
    source: "Page 40 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 232,
    question: "To overload a method, what to do?",
    options: [
      "Change return only",
      "Change the number, type, or order of parameters",
      "Keep same",
      "Rely on return",
    ],
    correctAnswer: "B",
    explanation: "To overload a method: Change the number, type, or order of parameters. Do not rely on return type to make them different.",
    source: "Page 40 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 233,
    question: "The course part 1 covers what topics?",
    options: [
      "Methods only",
      "Java Classes and Objects, Create a Class in Java, Create an Object in Java, Multiple Objects, Java Class Attributes, Modify Attributes in Java, Override Default Attribute Values in Java, Prevent Overriding with final, Multiple Objects and Independent Attributes, Multiple Attributes in a Class",
      "Constructors only",
      "Overloading",
    ],
    correctAnswer: "B",
    explanation: "Part 1: Classes, Objects, and Attributes Java Classes and Objects Create a Class in Java Create an Object in Java Multiple Objects Java Class Attributes Modify Attributes in Java Override Default Attribute Values in Java Prevent Overriding with final Multiple Objects and Independent Attributes Multiple Attributes in a Class.",
    source: "Page 41 - Java Classes and Objects",
    topic: "Classes & Objects",
  },
  {
    id: 234,
    question: "In Java, what are modifiers?",
    options: [
      "Keywords used to define the accessibility of classes, methods, fields, and constructors, and the behavior or constraints of these elements.",
      "Variables that control program flow.",
      "Methods that initialize objects.",
      "Classes that extend other classes.",
    ],
    correctAnswer: "A",
    explanation: "Modifiers in Java are keywords that define the accessibility of classes, methods, fields, and constructors, as well as their behavior or constraints.",
    source: "Page 2",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 235,
    question: "How many categories of modifiers are there in Java, and what are they?",
    options: [
      "Two categories: Access Modifiers – Control visibility, and Non-Access Modifiers – Define additional behavior, not related to access.",
      "Three categories: Public, Private, and Protected.",
      "One category: Visibility controls.",
      "Four categories: Static, Final, Abstract, and Synchronized.",
    ],
    correctAnswer: "A",
    explanation: "Java has two categories of modifiers: Access Modifiers, which control visibility, and Non-Access Modifiers, which define additional behavior not related to access.",
    source: "Page 2",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 236,
    question: "What is the purpose of Access Modifiers in Java?",
    options: [
      "Control visibility of classes and members.",
      "Define characteristics or constraints.",
      "Handle exceptions.",
      "Manage memory allocation.",
    ],
    correctAnswer: "A",
    explanation: "Access Modifiers in Java are used to control the visibility of classes and their members.",
    source: "Page 3",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 237,
    question: "What is the purpose of Non-Access Modifiers in Java?",
    options: [
      "Define characteristics or constraints.",
      "Control visibility of classes and members.",
      "Initialize variables.",
      "Create loops.",
    ],
    correctAnswer: "A",
    explanation: "Non-Access Modifiers define characteristics or constraints of classes, methods, or fields, such as making them static, final, or abstract.",
    source: "Page 3",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 238,
    question: "What are examples of Access Modifiers in Java?",
    options: [
      "public, private, protected, default.",
      "static, final, abstract, synchronized, etc.",
      "class, method, field, constructor.",
      "int, double, String, boolean.",
    ],
    correctAnswer: "A",
    explanation: "Access Modifiers in Java include public, private, protected, and default (no modifier).",
    source: "Page 3",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 239,
    question: "What are examples of Non-Access Modifiers in Java?",
    options: [
      "static, final, abstract, synchronized, etc.",
      "public, private, protected, default.",
      "void, return, if, else.",
      "new, this, super, extends.",
    ],
    correctAnswer: "A",
    explanation: "Non-Access Modifiers in Java include static, final, abstract, synchronized, and others that define behavior or constraints.",
    source: "Page 3",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 240,
    question: "In the following code, what does the public modifier do for the class Main?\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\");\n  }\n}",
    options: [
      "It defines the visibility of the class Main, allowing any other class to access it.",
      "It makes the class private.",
      "It prevents subclassing.",
      "It declares the class as abstract.",
    ],
    correctAnswer: "A",
    explanation: "The public modifier makes the class Main accessible from any other class.",
    source: "Page 4",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 241,
    question: "What is the keyword public in the example code?\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\");\n  }\n}",
    options: [
      "A modifier that defines the visibility of the class and method.",
      "A variable type.",
      "A method name.",
      "A package declaration.",
    ],
    correctAnswer: "A",
    explanation: "The keyword public is a modifier that defines the visibility of the class and method.",
    source: "Page 4",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 242,
    question: "What do access modifiers determine in Java?",
    options: [
      "Where a class member can be accessed from.",
      "The size of variables.",
      "The number of methods in a class.",
      "The inheritance hierarchy.",
    ],
    correctAnswer: "A",
    explanation: "Access modifiers determine where a class member can be accessed from, controlling visibility.",
    source: "Page 5",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 243,
    question: "How many access levels does Java provide?",
    options: [
      "Four: public, protected, default (no keyword), private.",
      "Three: public, private, static.",
      "Two: access and non-access.",
      "Five: public, protected, default, private, final.",
    ],
    correctAnswer: "A",
    explanation: "Java provides four access levels: public, protected, default (no keyword), and private.",
    source: "Page 5",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 244,
    question: "How many modifiers are allowed for top-level classes in Java?",
    options: [
      "Only two: public and default (no modifier).",
      "All four: public, protected, default, private.",
      "Three: public, private, protected.",
      "One: public only.",
    ],
    correctAnswer: "A",
    explanation: "Top-level classes in Java can only use public or default (no modifier) access modifiers.",
    source: "Page 6",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 245,
    question: "What does the public modifier do for a top-level class?",
    options: [
      "The class is accessible from any other class.",
      "The class is accessible only within the same package.",
      "The class cannot be instantiated.",
      "The class must be subclassed.",
    ],
    correctAnswer: "A",
    explanation: "The public modifier allows a top-level class to be accessible from any other class.",
    source: "Page 6",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 246,
    question: "What does the default (no modifier) do for a top-level class?",
    options: [
      "The class is accessible only within the same package.",
      "The class is accessible from any other class.",
      "The class is hidden from all packages.",
      "The class can only be used in subclasses.",
    ],
    correctAnswer: "A",
    explanation: "The default access (no modifier) restricts a top-level class to be accessible only within the same package.",
    source: "Page 6",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 247,
    question: "What will be learned later in the course regarding access modifiers for classes?",
    options: [
      "More about packages.",
      "More about methods.",
      "More about variables.",
      "More about loops.",
    ],
    correctAnswer: "A",
    explanation: "The course will cover more about packages in relation to access modifiers for classes.",
    source: "Page 6",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 248,
    question: "Where is a top-level class defined?",
    options: [
      "Directly in a .java file.",
      "Inside another class or method.",
      "In a package declaration.",
      "In a method body.",
    ],
    correctAnswer: "A",
    explanation: "A top-level class is defined directly in a .java file.",
    source: "Page 7",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 249,
    question: "Where is a nested class defined?",
    options: [
      "Inside another class or method.",
      "Directly in a .java file.",
      "In an external library.",
      "In the main method.",
    ],
    correctAnswer: "A",
    explanation: "A nested class is defined inside another class or method.",
    source: "Page 7",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 250,
    question: "What is the common use of top-level classes?",
    options: [
      "Main classes of programs.",
      "Utility or helper classes.",
      "Data structures.",
      "Input/output operations.",
    ],
    correctAnswer: "A",
    explanation: "Top-level classes are commonly used as the main classes of programs.",
    source: "Page 7",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 251,
    question: "What is the common use of nested classes?",
    options: [
      "Utility or helper classes.",
      "Main classes of programs.",
      "Mathematical operations.",
      "Networking features.",
    ],
    correctAnswer: "A",
    explanation: "Nested classes are commonly used as utility or helper classes.",
    source: "Page 7",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 252,
    question: "In the code example, what is the class Outer?\n\n// Top-Level class\npublic class Outer {\n  // Nested class\n  class Inner {\n    // ...\n  }\n}",
    options: [
      "A top-level class.",
      "A nested class.",
      "An abstract class.",
      "A final class.",
    ],
    correctAnswer: "A",
    explanation: "The class Outer is a top-level class, as it is defined directly in a .java file.",
    source: "Page 7",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 253,
    question: "In the code example, what is the class Inner?\n\n// Top-Level class\npublic class Outer {\n  // Nested class\n  class Inner {\n    // ...\n  }\n}",
    options: [
      "A nested class.",
      "A top-level class.",
      "A static class.",
      "A private class.",
    ],
    correctAnswer: "A",
    explanation: "The class Inner is a nested class, as it is defined inside another class (Outer).",
    source: "Page 7",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 254,
    question: "What access modifiers can top-level classes use?",
    options: [
      "public and default (no modifier).",
      "private and protected.",
      "final and abstract.",
      "static and synchronized.",
    ],
    correctAnswer: "A",
    explanation: "Top-level classes can only use public or default (no modifier) access modifiers.",
    source: "Page 8",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 255,
    question: "Why can't top-level classes use private and protected?",
    options: [
      "Because private and protected imply visibility inside or relative to another class, and a top-level class is not inside another class.",
      "Because they are reserved for methods.",
      "Because they conflict with packages.",
      "Because they make classes immutable.",
    ],
    correctAnswer: "A",
    explanation: "Private and protected imply visibility inside or relative to another class, which is not applicable to top-level classes that are not inside another class.",
    source: "Page 8",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 256,
    question: "Which of the following is a valid top-level class declaration?",
    options: [
      "public class MyClass { }",
      "private class HiddenClass { }",
      "protected class SubClass { }",
      "final class FinalClass { }",
    ],
    correctAnswer: "A",
    explanation: "A valid top-level class declaration can use the public modifier, as in 'public class MyClass { }'.",
    source: "Page 9",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 257,
    question: "Which of the following is a valid top-level class declaration with default access?",
    options: [
      "class PackageClass { }",
      "public class MyClass { }",
      "private class HiddenClass { }",
      "protected class SubClass { }",
    ],
    correctAnswer: "A",
    explanation: "A valid top-level class with default access is declared without a modifier, as in 'class PackageClass { }'.",
    source: "Page 9",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 258,
    question: "Why is 'private class HiddenClass { }' invalid for a top-level class?",
    options: [
      "It results in an ERROR because private is not allowed for top-level classes.",
      "It is valid but hidden.",
      "It requires a package.",
      "It needs to be nested.",
    ],
    correctAnswer: "A",
    explanation: "The private modifier is not allowed for top-level classes, resulting in a compilation error.",
    source: "Page 9",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 259,
    question: "Why is 'protected class SubClass { }' invalid for a top-level class?",
    options: [
      "It results in an ERROR because protected is not allowed for top-level classes.",
      "It is valid for subclasses only.",
      "It conflicts with public.",
      "It must be abstract.",
    ],
    correctAnswer: "A",
    explanation: "The protected modifier is not allowed for top-level classes, resulting in a compilation error.",
    source: "Page 9",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 260,
    question: "What does the public modifier do for fields, methods, and constructors?",
    options: [
      "Accessible from any class.",
      "Accessible only within the declaring class.",
      "Accessible only within the same package.",
      "Accessible within the same package and by subclasses.",
    ],
    correctAnswer: "A",
    explanation: "The public modifier makes fields, methods, and constructors accessible from any class.",
    source: "Page 10",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 261,
    question: "What does the private modifier do for fields, methods, and constructors?",
    options: [
      "Accessible only within the declaring class.",
      "Accessible from any class.",
      "Accessible only within the same package.",
      "Accessible within the same package and by subclasses.",
    ],
    correctAnswer: "A",
    explanation: "The private modifier restricts access to fields, methods, and constructors to within the declaring class.",
    source: "Page 10",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 262,
    question: "What does the default (no modifier) do for fields, methods, and constructors?",
    options: [
      "Accessible only within the same package.",
      "Accessible from any class.",
      "Accessible only within the declaring class.",
      "Accessible within the same package and by subclasses.",
    ],
    correctAnswer: "A",
    explanation: "The default access (no modifier) restricts access to fields, methods, and constructors to within the same package.",
    source: "Page 10",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 263,
    question: "What does the protected modifier do for fields, methods, and constructors?",
    options: [
      "Accessible within the same package and by subclasses.",
      "Accessible from any class.",
      "Accessible only within the declaring class.",
      "Accessible only within the same package.",
    ],
    correctAnswer: "A",
    explanation: "The protected modifier allows access to fields, methods, and constructors within the same package and by subclasses.",
    source: "Page 10",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 264,
    question: "When will the use of protected become clearer?",
    options: [
      "When studying inheritance.",
      "When studying packages.",
      "When studying methods.",
      "When studying constructors.",
    ],
    correctAnswer: "A",
    explanation: "The use of the protected modifier becomes clearer when studying inheritance, as it involves access by subclasses.",
    source: "Page 10",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 265,
    question: "In the code example, what is the access level of the field 'name'?\n\npublic class Student {\n  private String name;\n  public void setName(String n) {\n    name = n;\n  }\n  public String getName() {\n    return name;\n  }\n}",
    options: [
      "private – not accessible outside the class.",
      "public – accessible from any class.",
      "protected – accessible in subclasses.",
      "default – accessible in the package.",
    ],
    correctAnswer: "A",
    explanation: "The field 'name' is private, meaning it is not accessible outside the class.",
    source: "Page 11",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 266,
    question: "In the code example, what do setName() and getName() provide?\n\npublic class Student {\n  private String name;\n  public void setName(String n) {\n    name = n;\n  }\n  public String getName() {\n    return name;\n  }\n}",
    options: [
      "Controlled access to the private field.",
      "Direct access to the field.",
      "Static behavior.",
      "Abstract methods.",
    ],
    correctAnswer: "A",
    explanation: "The setName() and getName() methods provide controlled access to the private field 'name'.",
    source: "Page 11",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 267,
    question: "What does the final modifier do for classes?",
    options: [
      "The class cannot be extended (no subclassing allowed).",
      "The class cannot be instantiated; must be subclassed.",
      "The class is accessible publicly.",
      "The class belongs to instances.",
    ],
    correctAnswer: "A",
    explanation: "The final modifier prevents a class from being extended, meaning no subclassing is allowed.",
    source: "Page 12",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 268,
    question: "What does the abstract modifier do for classes?",
    options: [
      "The class cannot be instantiated; must be subclassed.",
      "The class cannot be extended (no subclassing allowed).",
      "The class is private.",
      "The class is static.",
    ],
    correctAnswer: "A",
    explanation: "The abstract modifier means a class cannot be instantiated and must be subclassed.",
    source: "Page 12",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 269,
    question: "What does the final modifier do for fields and methods?",
    options: [
      "Cannot be modified (fields) or overridden (methods).",
      "Belongs to the class, not to any instance.",
      "Declares a method without a body; must be overridden in subclass.",
      "Skipped during serialization.",
    ],
    correctAnswer: "A",
    explanation: "The final modifier prevents fields from being modified and methods from being overridden.",
    source: "Page 13",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 270,
    question: "What does the static modifier do for fields and methods?",
    options: [
      "Belongs to the class, not to any instance.",
      "Cannot be modified (fields) or overridden (methods).",
      "Declares a method without a body; must be overridden in subclass.",
      "Allows only one thread to access the method at a time.",
    ],
    correctAnswer: "A",
    explanation: "The static modifier indicates that fields and methods belong to the class, not to any instance.",
    source: "Page 13",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 271,
    question: "What does the abstract modifier do for methods?",
    options: [
      "Declares a method without a body; must be overridden in subclass.",
      "Belongs to the class, not to any instance.",
      "Cannot be modified (fields) or overridden (methods).",
      "Always read from main memory, not thread-local cache.",
    ],
    correctAnswer: "A",
    explanation: "The abstract modifier declares a method without a body, which must be overridden in a subclass.",
    source: "Page 13",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 272,
    question: "What does the transient modifier do for fields?",
    options: [
      "Skipped during serialization.",
      "Allows only one thread to access the method at a time.",
      "Always read from main memory, not thread-local cache.",
      "Declares a method without a body.",
    ],
    correctAnswer: "A",
    explanation: "The transient modifier indicates that a field should be skipped during serialization.",
    source: "Page 13",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 273,
    question: "What does the synchronized modifier do for methods?",
    options: [
      "Allows only one thread to access the method at a time.",
      "Skipped during serialization.",
      "Belongs to the class, not to any instance.",
      "Cannot be overridden.",
    ],
    correctAnswer: "A",
    explanation: "The synchronized modifier ensures that only one thread can access a method at a time.",
    source: "Page 13",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 274,
    question: "What does the volatile modifier do for fields?",
    options: [
      "Always read from main memory, not thread-local cache.",
      "Skipped during serialization.",
      "Declares without a body.",
      "Belongs to the class.",
    ],
    correctAnswer: "A",
    explanation: "The volatile modifier ensures that a field is always read from main memory, not a thread-local cache.",
    source: "Page 13",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 275,
    question: "What is the role of access modifiers in Java?",
    options: [
      "To manage visibility and support encapsulation.",
      "To control inheritance only.",
      "To handle concurrency.",
      "To define method structure.",
    ],
    correctAnswer: "A",
    explanation: "Access modifiers manage visibility and support encapsulation in Java.",
    source: "Page 14",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 276,
    question: "What is the role of non-access modifiers in Java?",
    options: [
      "To control inheritance, concurrency, memory behavior, and method structure.",
      "To manage visibility only.",
      "To support encapsulation only.",
      "To define classes only.",
    ],
    correctAnswer: "A",
    explanation: "Non-access modifiers control inheritance, concurrency, memory behavior, and method structure.",
    source: "Page 14",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 277,
    question: "What does mastering Java modifiers help with?",
    options: [
      "Writing robust, maintainable, and secure code.",
      "Creating loops and conditions.",
      "Managing file input/output.",
      "Handling exceptions.",
    ],
    correctAnswer: "A",
    explanation: "Mastering Java modifiers helps in writing robust, maintainable, and secure code.",
    source: "Page 14",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 278,
    question: "What is encapsulation in Object-Oriented Programming?",
    options: [
      "Wrapping data (fields) and methods into a single unit – the class – and restricting direct access to some components.",
      "Extending one class from another.",
      "Creating multiple instances.",
      "Defining static methods.",
    ],
    correctAnswer: "A",
    explanation: "Encapsulation involves wrapping data and methods into a class and restricting direct access to some components.",
    source: "Page 15",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 279,
    question: "Encapsulation is one of the fundamental principles of what?",
    options: [
      "Object-Oriented Programming.",
      "Procedural Programming.",
      "Functional Programming.",
      "Logical Programming.",
    ],
    correctAnswer: "A",
    explanation: "Encapsulation is a fundamental principle of Object-Oriented Programming.",
    source: "Page 15",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 280,
    question: "According to the core idea of encapsulation, how should data inside an object be accessed?",
    options: [
      "It should be accessed via methods, not directly.",
      "It should be directly accessible.",
      "It should be static.",
      "It should be final.",
    ],
    correctAnswer: "A",
    explanation: "Encapsulation requires data to be accessed via methods, not directly, to ensure controlled access.",
    source: "Page 16",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 281,
    question: "How is encapsulation achieved for data access?",
    options: [
      "Using access modifiers and getter/setter methods.",
      "Using public fields.",
      "Using static variables.",
      "Using abstract classes.",
    ],
    correctAnswer: "A",
    explanation: "Encapsulation is achieved using access modifiers and getter/setter methods to control data access.",
    source: "Page 16",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 282,
    question: "In the code example, what is the access level of the field 'balance'?\n\nclass Account {\n  private double balance; // hidden\n  public double getBalance() {\n    return balance;\n  }\n  public void deposit(double amount) {\n    if (amount > 0) balance += amount;\n  }\n}",
    options: [
      "private – hidden.",
      "public – accessible.",
      "protected – for subclasses.",
      "default – package level.",
    ],
    correctAnswer: "A",
    explanation: "The field 'balance' is private, meaning it is hidden from outside access.",
    source: "Page 16",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 283,
    question: "In the code example, how does the deposit method handle the amount?\n\nclass Account {\n  private double balance; // hidden\n  public double getBalance() {\n    return balance;\n  }\n  public void deposit(double amount) {\n    if (amount > 0) balance += amount;\n  }\n}",
    options: [
      "If amount > 0, add to balance.",
      "Always add amount regardless.",
      "Subtract if amount < 0.",
      "Set balance to amount.",
    ],
    correctAnswer: "A",
    explanation: "The deposit method adds the amount to the balance only if the amount is positive.",
    source: "Page 16",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 284,
    question: "What is the first benefit of encapsulation?",
    options: [
      "Protects data integrity by preventing unauthorized or invalid access.",
      "Improves maintainability.",
      "Provides controlled access.",
      "Encourages modular design.",
    ],
    correctAnswer: "A",
    explanation: "The first benefit of encapsulation is protecting data integrity by preventing unauthorized or invalid access.",
    source: "Page 17",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 285,
    question: "What is the second benefit of encapsulation?",
    options: [
      "Improves maintainability by changes to internal implementation not affecting external code.",
      "Protects data integrity.",
      "Provides controlled access.",
      "Encourages modular design.",
    ],
    correctAnswer: "A",
    explanation: "The second benefit of encapsulation is improving maintainability by ensuring internal changes do not affect external code.",
    source: "Page 17",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 286,
    question: "What is the third benefit of encapsulation?",
    options: [
      "Provides controlled access by only allowing safe interactions through well-defined methods.",
      "Protects data integrity.",
      "Improves maintainability.",
      "Encourages modular design.",
    ],
    correctAnswer: "A",
    explanation: "The third benefit of encapsulation is providing controlled access through well-defined methods.",
    source: "Page 17",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 287,
    question: "What is the fourth benefit of encapsulation?",
    options: [
      "Encourages modular design by objects being self-contained, with clear interfaces.",
      "Protects data integrity.",
      "Improves maintainability.",
      "Provides controlled access.",
    ],
    correctAnswer: "A",
    explanation: "The fourth benefit of encapsulation is encouraging modular design by creating self-contained objects with clear interfaces.",
    source: "Page 17",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 288,
    question: "In the code without encapsulation, what is the issue with the field 'age'?\n\nclass Student {\n  public int age; // directly modifiable\n}",
    options: [
      "It is directly modifiable.",
      "It is private.",
      "It has validation.",
      "It is read-only.",
    ],
    correctAnswer: "A",
    explanation: "Without encapsulation, the field 'age' is public and directly modifiable, which can lead to invalid data.",
    source: "Page 18",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 289,
    question: "In the code with encapsulation, how is access to 'age' controlled?\n\nclass Student {\n  private int age;\n  public void setAge(int a) {\n    if (a >= 0) age = a;\n  }\n  public int getAge() {\n    return age;\n  }\n}",
    options: [
      "Through setAge with validation and getAge.",
      "Directly modifiable.",
      "No access at all.",
      "Static access.",
    ],
    correctAnswer: "A",
    explanation: "Access to 'age' is controlled through the setAge method with validation and the getAge method.",
    source: "Page 18",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 290,
    question: "What is a key difference in the first version without encapsulation?",
    options: [
      "It exposes the internal data directly.",
      "It allows only safe, validated access.",
      "It uses private fields.",
      "It has getter and setter.",
    ],
    correctAnswer: "A",
    explanation: "The first version without encapsulation exposes the internal data directly, allowing unrestricted access.",
    source: "Page 18",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 291,
    question: "What is a key difference in the second version with encapsulation?",
    options: [
      "It allows only safe, validated access.",
      "It exposes the internal data directly.",
      "It uses public fields.",
      "It has no methods.",
    ],
    correctAnswer: "A",
    explanation: "The second version with encapsulation allows only safe, validated access to the data.",
    source: "Page 18",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 292,
    question: "In the code example, what is the field 'age' declared as?\n\nclass Student {\n  public int age;\n}",
    options: [
      "public int age;",
      "private int age;",
      "protected int age;",
      "static int age;",
    ],
    correctAnswer: "A",
    explanation: "The field 'age' is declared as public, making it directly accessible.",
    source: "Page 19",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 293,
    question: "In the usage example, what happens with s.age = -5;?\n\nStudent s = new Student();\ns.age = -5; // This is allowed, but it's wrong!",
    options: [
      "It is allowed, but it's wrong!",
      "It is not allowed.",
      "It sets age to 0.",
      "It throws an error.",
    ],
    correctAnswer: "A",
    explanation: "Assigning a negative age is allowed with a public field, but it is incorrect and can lead to invalid data.",
    source: "Page 19",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 294,
    question: "What is the problem with assigning a negative age in the example?\n\nStudent s = new Student();\ns.age = -5; // This is allowed, but it's wrong!",
    options: [
      "No rule stops us from assigning a negative age, which is dangerous and leads to bad data.",
      "It is automatically validated.",
      "It requires a setter.",
      "It is read-only.",
    ],
    correctAnswer: "A",
    explanation: "Without validation, assigning a negative age is dangerous and leads to bad data.",
    source: "Page 19",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 295,
    question: "What is the first step of encapsulation to protect the field?\n\nclass Student {\n  private int age; // hidden from outside\n}",
    options: [
      "Make it private: private int age; // hidden from outside",
      "Make it public.",
      "Add a getter.",
      "Add a setter.",
    ],
    correctAnswer: "A",
    explanation: "The first step of encapsulation is to make the field private to hide it from outside access.",
    source: "Page 20",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 296,
    question: "What happens when trying to access a private field directly?\n\nStudent s = new Student();\ns.age = 20; // ❌ ERROR: age has private access",
    options: [
      "ERROR: age has private access.",
      "It assigns successfully.",
      "It sets to default.",
      "It calls a method.",
    ],
    correctAnswer: "A",
    explanation: "Attempting to access a private field directly results in a compilation error.",
    source: "Page 20",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 297,
    question: "What is this step called in encapsulation?\n\nclass Student {\n  private int age; // hidden from outside\n}",
    options: [
      "Data hiding.",
      "Method overriding.",
      "Inheritance.",
      "Polymorphism.",
    ],
    correctAnswer: "A",
    explanation: "Making a field private is called data hiding, the first step of encapsulation.",
    source: "Page 20",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 298,
    question: "What does the setter method do in the example?\n\npublic void setAge(int a) {\n  if (a >= 0) {\n    age = a;\n  }\n}",
    options: [
      "Sets the value safely if a >= 0.",
      "Always sets the value.",
      "Returns the value.",
      "Deposits amount.",
    ],
    correctAnswer: "A",
    explanation: "The setter method sets the value of 'age' only if the input is non-negative, ensuring safe assignment.",
    source: "Page 21",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 299,
    question: "In the full class after adding the setter, what is included?\n\nclass Student {\n  private int age;\n  public void setAge(int a) {\n    if (a >= 0) {\n      age = a;\n    }\n  }\n}",
    options: [
      "private int age; and public void setAge(int a) with validation.",
      "public int age;",
      "getAge method.",
      "deposit method.",
    ],
    correctAnswer: "A",
    explanation: "The class includes a private 'age' field and a setAge method with validation.",
    source: "Page 21",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 300,
    question: "What happens with s.setAge(20); and s.setAge(-5);?\n\nStudent s = new Student();\ns.setAge(20); // ✅ Safe assignment\ns.setAge(-5); // ✅ Nothing happens (data stays valid)",
    options: [
      "s.setAge(20); is safe assignment, s.setAge(-5); nothing happens (data stays valid).",
      "Both assign directly.",
      "Both throw errors.",
      "Only negative assigns.",
    ],
    correctAnswer: "A",
    explanation: "s.setAge(20) assigns the value safely, while s.setAge(-5) does nothing, keeping the data valid.",
    source: "Page 21",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 301,
    question: "What does the getter method do?\n\npublic int getAge() {\n  return age;\n}",
    options: [
      "Returns the value of age.",
      "Sets the value.",
      "Validates input.",
      "Deposits amount.",
    ],
    correctAnswer: "A",
    explanation: "The getter method returns the value of the 'age' field.",
    source: "Page 22",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 302,
    question: "What is the full class after adding the getter?\n\nclass Student {\n  private int age;\n  public void setAge(int a) {\n    if (a >= 0) {\n      age = a;\n    }\n  }\n  public int getAge() {\n    return age;\n  }\n}",
    options: [
      "private age, setAge with validation, getAge to return age.",
      "public age only.",
      "No methods.",
      "Abstract class.",
    ],
    correctAnswer: "A",
    explanation: "The class includes a private 'age' field, a setAge method with validation, and a getAge method to return the age.",
    source: "Page 22",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 303,
    question: "In the usage example, what does the code do?\n\nStudent s = new Student();\ns.setAge(21); // set value\nSystem.out.println(s.getAge()); // print value → 21",
    options: [
      "Sets age to 21 and prints 21.",
      "Sets to -21.",
      "Prints nothing.",
      "Throws error.",
    ],
    correctAnswer: "A",
    explanation: "The code sets the age to 21 using setAge and prints 21 using getAge.",
    source: "Page 23",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 304,
    question: "What is achieved now with getter and setter?\n\nclass Student {\n  private int age;\n  public void setAge(int a) {\n    if (a >= 0) {\n      age = a;\n    }\n  }\n  public int getAge() {\n    return age;\n  }\n}",
    options: [
      "Full control over how the field is accessed.",
      "Direct access.",
      "No access.",
      "Static control.",
    ],
    correctAnswer: "A",
    explanation: "Using getter and setter methods provides full control over how the field is accessed.",
    source: "Page 23",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 305,
    question: "What is a best practice for fields in encapsulation?",
    options: [
      "Use private for all fields.",
      "Use public for all fields.",
      "Use protected for fields.",
      "Use default for fields.",
    ],
    correctAnswer: "A",
    explanation: "A best practice in encapsulation is to use private for all fields to hide them from outside access.",
    source: "Page 24",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 306,
    question: "What is a best practice for accessing fields safely?",
    options: [
      "Use public methods (getters/setters).",
      "Use direct access.",
      "Use static methods.",
      "Use abstract methods.",
    ],
    correctAnswer: "A",
    explanation: "Using public getter and setter methods is a best practice for safely accessing fields.",
    source: "Page 24",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 307,
    question: "When should validation be added in encapsulation?",
    options: [
      "In setters when needed.",
      "In getters only.",
      "In constructors only.",
      "Never.",
    ],
    correctAnswer: "A",
    explanation: "Validation should be added in setter methods when needed to ensure data integrity.",
    source: "Page 24",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 308,
    question: "What should not be created for fields that should not change?",
    options: [
      "Do not create setters.",
      "Create multiple setters.",
      "Create getters only if changing.",
      "Make them public.",
    ],
    correctAnswer: "A",
    explanation: "For fields that should not change, setters should not be created to enforce immutability.",
    source: "Page 24",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 309,
    question: "What is the purpose of the private keyword?",
    options: [
      "Hides data from outside.",
      "Allows access through methods.",
      "Returns the value of a field.",
      "Sets the value with optional checks.",
    ],
    correctAnswer: "A",
    explanation: "The private keyword hides data from outside access, a key part of encapsulation.",
    source: "Page 25",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 310,
    question: "What is the purpose of the public keyword in encapsulation?",
    options: [
      "Allows access through methods.",
      "Hides data from outside.",
      "Returns the value.",
      "Sets the value.",
    ],
    correctAnswer: "A",
    explanation: "The public keyword allows access to fields through methods, such as getters and setters, in encapsulation.",
    source: "Page 25",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 311,
    question: "What is the purpose of getX() methods?",
    options: [
      "Returns the value of a field.",
      "Sets the value with optional checks.",
      "Hides data.",
      "Allows access.",
    ],
    correctAnswer: "A",
    explanation: "getX() methods are used to return the value of a field in encapsulation.",
    source: "Page 25",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 312,
    question: "What is the purpose of setX() methods?",
    options: [
      "Sets the value with optional checks.",
      "Returns the value of a field.",
      "Hides data.",
      "Allows direct access.",
    ],
    correctAnswer: "A",
    explanation: "setX() methods set the value of a field with optional validation checks in encapsulation.",
    source: "Page 25",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 313,
    question: "In the Student class example, what are the fields?\n\npublic class Student {\n  private String name;\n  private int age;\n  public void setName(String n) { name = n; }\n  public String getName() {\n    return name;\n  }\n  public void setAge(int a) { if (a >= 0) age = a; }\n  public int getAge() {\n    return age;\n  }\n}",
    options: [
      "private String name; private int age;",
      "public String name; public int age;",
      "protected String name; protected int age;",
      "static String name; static int age;",
    ],
    correctAnswer: "A",
    explanation: "The fields in the Student class are 'private String name' and 'private int age'.",
    source: "Page 26",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 314,
    question: "In the Student class example, what does setAge do?\n\npublic class Student {\n  private String name;\n  private int age;\n  public void setName(String n) { name = n; }\n  public String getName() {\n    return name;\n  }\n  public void setAge(int a) { if (a >= 0) age = a; }\n  public int getAge() {\n    return age;\n  }\n}",
    options: [
      "if (a >= 0) age = a;",
      "age = a; without check.",
      "return age;",
      "name = n;",
    ],
    correctAnswer: "A",
    explanation: "The setAge method sets the age only if the input is non-negative, ensuring valid data.",
    source: "Page 26",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 315,
    question: "In the example, how are fields handled?\n\npublic class Student {\n  private String name;\n  private int age;\n  public void setName(String n) { name = n; }\n  public String getName() {\n    return name;\n  }\n  public void setAge(int a) { if (a >= 0) age = a; }\n  public int getAge() {\n    return age;\n  }\n}",
    options: [
      "Fields are private.",
      "Fields are public.",
      "Fields are protected.",
      "Fields are static.",
    ],
    correctAnswer: "A",
    explanation: "The fields in the Student class are private, supporting encapsulation.",
    source: "Page 26",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 316,
    question: "In the example, what do methods control?\n\npublic class Student {\n  private String name;\n  private int age;\n  public void setName(String n) { name = n; }\n  public String getName() {\n    return name;\n  }\n  public void setAge(int a) { if (a >= 0) age = a; }\n  public int getAge() {\n    return age;\n  }\n}",
    options: [
      "How values are assigned and retrieved.",
      "Direct field access.",
      "Class extension.",
      "Thread access.",
    ],
    correctAnswer: "A",
    explanation: "Methods in the Student class control how values are assigned and retrieved, ensuring proper encapsulation.",
    source: "Page 26",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 317,
    question: "In the usage example, what cannot external code do?\n\nStudent s = new Student();\ns.setName(\"Alice\");\ns.setAge(20);\nSystem.out.println(s.getName());\nSystem.out.println(s.getAge());",
    options: [
      "Directly access fields.",
      "Use setters.",
      "Use getters.",
      "Print values.",
    ],
    correctAnswer: "A",
    explanation: "External code cannot directly access the private fields of the Student class.",
    source: "Page 27",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 318,
    question: "How is all access handled in the example?\n\nStudent s = new Student();\ns.setName(\"Alice\");\ns.setAge(20);\nSystem.out.println(s.getName());\nSystem.out.println(s.getAge());",
    options: [
      "Through controlled methods.",
      "Directly to fields.",
      "Via static calls.",
      "Via constructors.",
    ],
    correctAnswer: "A",
    explanation: "All access to fields in the example is handled through controlled methods (getters and setters).",
    source: "Page 27",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 319,
    question: "In the BankAccount class, what is the field?\n\npublic class BankAccount {\n  private double balance;\n  public void deposit(double amount) {\n    if (amount > 0) balance += amount;\n  }\n  public void withdraw(double amount) {\n    if (amount > 0 && amount <= balance) balance -= amount;\n  }\n  public double getBalance() {\n    return balance;\n  }\n}",
    options: [
      "private double balance;",
      "public double balance;",
      "protected double balance;",
      "static double balance;",
    ],
    correctAnswer: "A",
    explanation: "The field in the BankAccount class is 'private double balance', ensuring encapsulation.",
    source: "Page 28",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 320,
    question: "In the BankAccount class, how does deposit work?\n\npublic class BankAccount {\n  private double balance;\n  public void deposit(double amount) {\n    if (amount > 0) balance += amount;\n  }\n  public void withdraw(double amount) {\n    if (amount > 0 && amount <= balance) balance -= amount;\n  }\n  public double getBalance() {\n    return balance;\n  }\n}",
    options: [
      "if (amount > 0) balance += amount;",
      "balance += amount; always.",
      "balance -= amount;",
      "return balance;",
    ],
    correctAnswer: "A",
    explanation: "The deposit method adds the amount to the balance only if the amount is positive.",
    source: "Page 28",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 321,
    question: "In the BankAccount class, how does withdraw work?\n\npublic class BankAccount {\n  private double balance;\n  public void deposit(double amount) {\n    if (amount > 0) balance += amount;\n  }\n  public void withdraw(double amount) {\n    if (amount > 0 && amount <= balance) balance -= amount;\n  }\n  public double getBalance() {\n    return balance;\n  }\n}",
    options: [
      "if (amount > 0 && amount <= balance) balance -= amount;",
      "balance -= amount; always.",
      "balance += amount;",
      "if (amount < 0) balance -= amount;",
    ],
    correctAnswer: "A",
    explanation: "The withdraw method subtracts the amount from the balance only if the amount is positive and does not exceed the balance.",
    source: "Page 28",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 322,
    question: "How can balance be changed in the BankAccount class?\n\npublic class BankAccount {\n  private double balance;\n  public void deposit(double amount) {\n    if (amount > 0) balance += amount;\n  }\n  public void withdraw(double amount) {\n    if (amount > 0 && amount <= balance) balance -= amount;\n  }\n  public double getBalance() {\n    return balance;\n  }\n}",
    options: [
      "Only through business rules.",
      "Directly.",
      "Via public field.",
      "Via static methods.",
    ],
    correctAnswer: "A",
    explanation: "The balance can only be changed through business rules enforced by the deposit and withdraw methods.",
    source: "Page 28",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 323,
    question: "What happens to invalid operations like negative deposit in the BankAccount class?",
    options: [
      "They are rejected.",
      "They are allowed.",
      "They set to zero.",
      "They throw exceptions.",
    ],
    correctAnswer: "A",
    explanation: "Invalid operations, such as a negative deposit, are rejected by the business rules in the deposit method.",
    source: "Page 28",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 324,
    question: "In the usage example, what is protected?\n\nBankAccount b = new BankAccount();\nb.deposit(1000);\nb.withdraw(200);\nSystem.out.println(b.getBalance());",
    options: [
      "The internal state is protected.",
      "External code.",
      "Methods are protected.",
      "Balance is public.",
    ],
    correctAnswer: "A",
    explanation: "The internal state of the BankAccount class is protected through encapsulation.",
    source: "Page 29",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 325,
    question: "What operations are allowed in the BankAccount usage?\n\nBankAccount b = new BankAccount();\nb.deposit(1000);\nb.withdraw(200);\nSystem.out.println(b.getBalance());",
    options: [
      "Only valid operations.",
      "All operations.",
      "No operations.",
      "Static operations.",
    ],
    correctAnswer: "A",
    explanation: "Only valid operations, as defined by the business rules, are allowed in the BankAccount class.",
    source: "Page 29",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 326,
    question: "In the Country class, how is the field 'name' initialized?\n\npublic class Country {\n  private String name;\n  public Country(String name) {\n    this.name = name;\n  }\n  public String getName() {\n    return name;\n  }\n}",
    options: [
      "Once in the constructor: this.name = name;",
      "Via setter.",
      "Directly public.",
      "In getter.",
    ],
    correctAnswer: "A",
    explanation: "The 'name' field is initialized once in the constructor of the Country class.",
    source: "Page 30",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 327,
    question: "Why can't the value be changed later in the Country class?\n\npublic class Country {\n  private String name;\n  public Country(String name) {\n    this.name = name;\n  }\n  public String getName() {\n    return name;\n  }\n}",
    options: [
      "No setter means the value cannot be changed later.",
      "Setter is provided.",
      "Field is public.",
      "Constructor changes it.",
    ],
    correctAnswer: "A",
    explanation: "The absence of a setter method means the 'name' field cannot be changed after initialization.",
    source: "Page 30",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 328,
    question: "In the immutable Student class, what are the fields declared as?\n\npublic class Student {\n  private final String name;\n  private final int age;\n  public Student(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n  public String getName() {\n    return name;\n  }\n  public int getAge() {\n    return age;\n  }\n}",
    options: [
      "private final String name; private final int age;",
      "public String name; public int age;",
      "protected final name;",
      "static name;",
    ],
    correctAnswer: "A",
    explanation: "The fields in the immutable Student class are declared as 'private final String name' and 'private final int age'.",
    source: "Page 31",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 329,
    question: "How are values set in the immutable Student class?\n\npublic class Student {\n  private final String name;\n  private final int age;\n  public Student(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n  public String getName() {\n    return name;\n  }\n  public int getAge() {\n    return age;\n  }\n}",
    options: [
      "Once via the constructor: this.name = name; this.age = age;",
      "Via setters.",
      "Directly.",
      "In getters.",
    ],
    correctAnswer: "A",
    explanation: "Values in the immutable Student class are set once via the constructor.",
    source: "Page 31",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 330,
    question: "What is a key characteristic of the immutable class?\n\npublic class Student {\n  private final String name;\n  private final int age;\n  public Student(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n  public String getName() {\n    return name;\n  }\n  public int getAge() {\n    return age;\n  }\n}",
    options: [
      "Fields are private and final.",
      "Fields are public.",
      "Setters are provided.",
      "No constructor.",
    ],
    correctAnswer: "A",
    explanation: "A key characteristic of an immutable class is that its fields are private and final.",
    source: "Page 31",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 331,
    question: "In the immutable class, are setters provided?\n\npublic class Student {\n  private final String name;\n  private final int age;\n  public Student(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n  public String getName() {\n    return name;\n  }\n  public int getAge() {\n    return age;\n  }\n}",
    options: [
      "No setters are provided.",
      "Setters are provided.",
      "Multiple setters.",
      "Protected setters.",
    ],
    correctAnswer: "A",
    explanation: "No setters are provided in the immutable Student class to ensure immutability.",
    source: "Page 31",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 332,
    question: "How are values set in the immutable class?\n\npublic class Student {\n  private final String name;\n  private final int age;\n  public Student(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n  public String getName() {\n    return name;\n  }\n  public int getAge() {\n    return age;\n  }\n}",
    options: [
      "Values are set once via the constructor.",
      "Values change via setters.",
      "Values are direct.",
      "Values are static.",
    ],
    correctAnswer: "A",
    explanation: "Values in the immutable class are set once via the constructor, ensuring they cannot be changed later.",
    source: "Page 31",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 333,
    question: "What best practice uses private in encapsulation?",
    options: [
      "Use private to hide internal fields.",
      "Use public to hide fields.",
      "Use protected.",
      "Use default.",
    ],
    correctAnswer: "A",
    explanation: "Using private to hide internal fields is a best practice in encapsulation.",
    source: "Page 32",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 334,
    question: "What best practice uses methods in encapsulation?",
    options: [
      "Use methods to validate and control access.",
      "Use direct access.",
      "Avoid methods.",
      "Use static only.",
    ],
    correctAnswer: "A",
    explanation: "Use methods to validate and control access.",
    source: "Page 32",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 335,
    question: "When should setters not be provided?",
    options: [
      "When fields should be read-only.",
      "Always provide setters.",
      "For public fields.",
      "For private fields.",
    ],
    correctAnswer: "A",
    explanation: "Do not provide setters when fields should be read-only.",
    source: "Page 32",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 336,
    question: "What do immutable classes ensure?",
    options: [
      "Full protection of internal state.",
      "Partial protection.",
      "No protection.",
      "External changes.",
    ],
    correctAnswer: "A",
    explanation: "Immutable classes ensure full protection of internal state.",
    source: "Page 32",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 337,
    question: "What is a Java package?",
    options: [
      "A namespace that organizes a set of related classes and interfaces.",
      "A class that extends another.",
      "A method group.",
      "A variable container.",
    ],
    correctAnswer: "A",
    explanation: "A package is a namespace that organizes a set of related classes and interfaces.",
    source: "Page 33",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 338,
    question: "What is a benefit of Java packages?",
    options: [
      "Prevents class name conflicts.",
      "Increases conflicts.",
      "Hides all classes.",
      "Removes interfaces.",
    ],
    correctAnswer: "A",
    explanation: "Prevents class name conflicts.",
    source: "Page 33",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 339,
    question: "What is another benefit of Java packages?",
    options: [
      "Groups similar classes together.",
      "Separates all classes.",
      "Deletes classes.",
      "Makes classes abstract.",
    ],
    correctAnswer: "A",
    explanation: "Groups similar classes together.",
    source: "Page 33",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 340,
    question: "What is another benefit of Java packages?",
    options: [
      "Helps maintain large projects.",
      "Complicates small projects.",
      "Prevents maintenance.",
      "Ignores projects.",
    ],
    correctAnswer: "A",
    explanation: "Helps maintain large projects.",
    source: "Page 33",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 341,
    question: "Where do you declare a package in a .java file?",
    options: [
      "At the top: package myschool.student;",
      "At the bottom.",
      "In the class body.",
      "In the method.",
    ],
    correctAnswer: "A",
    explanation: "At the top of your .java file, declare the package: package myschool.student;.",
    source: "Page 34",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 342,
    question: "How do you use a class from another package?",
    options: [
      "import myschool.student.Student;",
      "package myschool.student;",
      "extend myschool.student;",
      "new myschool.student;",
    ],
    correctAnswer: "A",
    explanation: "To use a class from another package: import myschool.student.Student;.",
    source: "Page 34",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 343,
    question: "Which package provides core language features and is automatically imported?",
    options: [
      "java.lang",
      "java.util",
      "java.io",
      "java.time",
    ],
    correctAnswer: "A",
    explanation: "java.lang – core language features (automatically imported).",
    source: "Page 35",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 344,
    question: "Which package provides data structures and utilities?",
    options: [
      "java.util",
      "java.lang",
      "java.io",
      "java.math",
    ],
    correctAnswer: "A",
    explanation: "java.util – data structures and utilities.",
    source: "Page 35",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 345,
    question: "Which package provides input/output?",
    options: [
      "java.io",
      "java.util",
      "java.time",
      "java.math",
    ],
    correctAnswer: "A",
    explanation: "java.io – input/output.",
    source: "Page 35",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 346,
    question: "Which package provides date and time?",
    options: [
      "java.time",
      "java.io",
      "java.util",
      "java.lang",
    ],
    correctAnswer: "A",
    explanation: "java.time – date and time.",
    source: "Page 35",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 347,
    question: "Which package provides mathematical operations?",
    options: [
      "java.math",
      "java.time",
      "java.io",
      "java.lang",
    ],
    correctAnswer: "A",
    explanation: "java.math – mathematical operations.",
    source: "Page 35",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 348,
    question: "What is imported in the example?",
    options: [
      "import java.util.Scanner;",
      "import java.lang;",
      "import java.io;",
      "No import.",
    ],
    correctAnswer: "A",
    explanation: "import java.util.Scanner;.",
    source: "Page 36",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 349,
    question: "In the example, what does Scanner do?",
    options: [
      "Reads input: String name = sc.nextLine();",
      "Prints output only.",
      "Calculates math.",
      "Handles files.",
    ],
    correctAnswer: "A",
    explanation: "Scanner sc = new Scanner(System.in); String name = sc.nextLine();.",
    source: "Page 36",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 350,
    question: "What package is Scanner part of?",
    options: [
      "java.util",
      "java.lang",
      "java.io",
      "java.math",
    ],
    correctAnswer: "A",
    explanation: "Scanner is part of the java.util package.",
    source: "Page 36",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 351,
    question: "Why do we import Scanner?",
    options: [
      "To use it in our program.",
      "To hide it.",
      "To delete it.",
      "To make it private.",
    ],
    correctAnswer: "A",
    explanation: "We import it to use in our program.",
    source: "Page 36",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 352,
    question: "For public modifier, is access from same package and different package allowed?",
    options: [
      "✅ from same, ✅ from different.",
      "✅ from same, ❌ from different.",
      "❌ from same, ❌ from different.",
      "✅ from same, ✅ if subclass.",
    ],
    correctAnswer: "A",
    explanation: "public ✅ ✅.",
    source: "Page 37",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 353,
    question: "For protected modifier, is access from same package allowed and from different package?",
    options: [
      "✅ from same, ✅ (if subclass) from different.",
      "✅ from same, ✅ from different.",
      "✅ from same, ❌ from different.",
      "❌ from same, ❌ from different.",
    ],
    correctAnswer: "A",
    explanation: "protected ✅ ✅ (if subclass).",
    source: "Page 37",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 354,
    question: "For default modifier, is access from same package allowed and from different package?",
    options: [
      "✅ from same, ❌ from different.",
      "✅ from same, ✅ from different.",
      "❌ from same, ❌ from different.",
      "✅ from same, ✅ if subclass.",
    ],
    correctAnswer: "A",
    explanation: "default ✅ ❌.",
    source: "Page 37",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 355,
    question: "For private modifier, is access from same package and different package allowed?",
    options: [
      "❌ from same, ❌ from different.",
      "✅ from same, ✅ from different.",
      "✅ from same, ❌ from different.",
      "✅ from same, ✅ if subclass.",
    ],
    correctAnswer: "A",
    explanation: "private ❌ ❌.",
    source: "Page 37",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 356,
    question: "What do packages work with to control visibility across files?",
    options: [
      "Access modifiers.",
      "Classes only.",
      "Methods only.",
      "Variables only.",
    ],
    correctAnswer: "A",
    explanation: "Key Point: Packages work with access modifiers to control visibility across files.",
    source: "Page 37",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 357,
    question: "What is the Java API?",
    options: [
      "A collection of prewritten classes provided by the Java platform.",
      "A user-defined class.",
      "A package declaration.",
      "A method library.",
    ],
    correctAnswer: "A",
    explanation: "The Java API is a collection of prewritten classes provided by the Java platform.",
    source: "Page 38",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 358,
    question: "What does the Java API include?",
    options: [
      "Classes for strings, files, networking, collections, etc.",
      "Only user classes.",
      "Only primitives.",
      "Only exceptions.",
    ],
    correctAnswer: "A",
    explanation: "Includes classes for strings, files, networking, collections, etc.",
    source: "Page 38",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 359,
    question: "What benefit does the Java API provide?",
    options: [
      "Saves time – no need to reinvent the wheel.",
      "Increases time.",
      "Reinvents classes.",
      "Deletes code.",
    ],
    correctAnswer: "A",
    explanation: "Saves time – no need to reinvent the wheel.",
    source: "Page 38",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 360,
    question: "How is the Java API described?",
    options: [
      "Well-documented with examples.",
      "Undocumented.",
      "No examples.",
      "Poorly maintained.",
    ],
    correctAnswer: "A",
    explanation: "Well-documented with examples.",
    source: "Page 38",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 361,
    question: "How do you bring in classes from the Java API?",
    options: [
      "Use import.",
      "Use package.",
      "Use extend.",
      "Use new.",
    ],
    correctAnswer: "A",
    explanation: "Use import to bring in classes.",
    source: "Page 39",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 362,
    question: "Where can you look up Java API documentation?",
    options: [
      "https://docs.oracle.com/en/java/javase/",
      "https://example.com",
      "Local file.",
      "No documentation.",
    ],
    correctAnswer: "A",
    explanation: "Look up documentation at: https://docs.oracle.com/en/java/javase/.",
    source: "Page 39",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 363,
    question: "In the example, what package is Math from and how is it imported?",
    options: [
      "From java.lang (auto-imported).",
      "From java.util, manual import.",
      "From java.math, import needed.",
      "From java.io.",
    ],
    correctAnswer: "A",
    explanation: "Using Math class from java.lang (auto-imported):.",
    source: "Page 39",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 364,
    question: "What is imported in the practice example?",
    options: [
      "import java.util.ArrayList;",
      "import java.lang.ArrayList;",
      "No import.",
      "import java.io;",
    ],
    correctAnswer: "A",
    explanation: "import java.util.ArrayList;.",
    source: "Page 40",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 365,
    question: "In the example, what does ArrayList do?",
    options: [
      "Adds \"Java\" and \"OOP\" to a dynamic array.",
      "Removes items.",
      "Calculates sqrt.",
      "Reads input.",
    ],
    correctAnswer: "A",
    explanation: "list.add(\"Java\"); list.add(\"OOP\");.",
    source: "Page 40",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 366,
    question: "What package is ArrayList from?",
    options: [
      "java.util",
      "java.lang",
      "java.math",
      "java.time",
    ],
    correctAnswer: "A",
    explanation: "ArrayList is from java.util.",
    source: "Page 40",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 367,
    question: "What is ArrayList described as?",
    options: [
      "Generic class for dynamic arrays.",
      "Static array.",
      "Method for math.",
      "Input class.",
    ],
    correctAnswer: "A",
    explanation: "Generic class for dynamic arrays.",
    source: "Page 40",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 368,
    question: "What do packages do?",
    options: [
      "Group related classes and avoid naming conflicts.",
      "Hide classes.",
      "Delete classes.",
      "Make classes final.",
    ],
    correctAnswer: "A",
    explanation: "Packages group related classes and avoid naming conflicts.",
    source: "Page 41",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 369,
    question: "How do you define and use packages?",
    options: [
      "Use package to define; import to use.",
      "Use import to define.",
      "Use extend to use.",
      "No need for import.",
    ],
    correctAnswer: "A",
    explanation: "Use package to define; import to use.",
    source: "Page 41",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 370,
    question: "What does the Java API provide?",
    options: [
      "Thousands of ready-to-use classes.",
      "Only a few classes.",
      "User-defined only.",
      "No classes.",
    ],
    correctAnswer: "A",
    explanation: "The Java API gives you thousands of ready-to-use classes.",
    source: "Page 41",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 371,
    question: "What should you learn to understand available functionality?",
    options: [
      "Learn to read JavaDoc.",
      "Ignore documentation.",
      "Write your own.",
      "Use only lang.",
    ],
    correctAnswer: "A",
    explanation: "Learn to read JavaDoc to understand available functionality.",
    source: "Page 41",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 372,
    question: "What purpose do modifiers serve in Java regarding classes, methods, fields, and constructors?",
    options: [
      "They define accessibility and behavior or constraints.",
      "They handle exception throwing.",
      "They manage loop iterations.",
      "They create array structures.",
    ],
    correctAnswer: "A",
    explanation: "In Java, modifiers are keywords used to define the accessibility of classes, methods, fields, and constructors, as well as their behavior or constraints.",
    source: "Page 2",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 373,
    question: "What divides modifiers into access and non-access types in Java?",
    options: [
      "Access controls visibility; non-access defines additional behavior unrelated to access.",
      "Access defines behavior; non-access controls visibility.",
      "Both categories manage only visibility.",
      "Both categories handle only constraints.",
    ],
    correctAnswer: "A",
    explanation: "Access Modifiers – Control visibility; Non-Access Modifiers – Define additional behavior, not related to access.",
    source: "Page 2",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 374,
    question: "In the table of modifier types, what role do access modifiers play?",
    options: [
      "They control visibility of classes and members.",
      "They define characteristics or constraints.",
      "They group related classes.",
      "They provide ready-to-use methods.",
    ],
    correctAnswer: "A",
    explanation: "Access Modifiers: Control visibility of classes and members.",
    source: "Page 3",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 375,
    question: "In the table of modifier types, what do non-access modifiers primarily do?",
    options: [
      "Define characteristics or constraints.",
      "Control visibility of classes and members.",
      "Wrap data and methods.",
      "Organize namespaces.",
    ],
    correctAnswer: "A",
    explanation: "Non-Access Modifiers: Define characteristics or constraints.",
    source: "Page 3",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 376,
    question: "Which set correctly lists examples of access modifiers?",
    options: [
      "public, private, protected, default.",
      "static, final, abstract, synchronized.",
      "class, object, method, field.",
      "extends, implements, super, this.",
    ],
    correctAnswer: "A",
    explanation: "Access: public, private, protected, default.",
    source: "Page 3",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 377,
    question: "Which options are correct examples of non-access modifiers?",
    options: [
      "static, final, abstract, synchronized, etc.",
      "public, private, protected, default.",
      "void, return, if, else.",
      "new, this, super, extends.",
    ],
    correctAnswer: "A",
    explanation: "Non-access: static, final, abstract, synchronized, etc.",
    source: "Page 3",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 378,
    question: "In the code example, why can other classes access the Main class?\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\");\n  }\n}",
    options: [
      "Because it is declared public, defining its visibility.",
      "Because it uses static.",
      "Because it has a main method.",
      "Because it prints to console.",
    ],
    correctAnswer: "A",
    explanation: "It defines the visibility of the class Main and the method main. Any other class can access Main because it is declared public.",
    source: "Page 4",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 379,
    question: "What role does the 'public' keyword play in the provided code example?\n\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World\");\n  }\n}",
    options: [
      "It is a modifier defining visibility for class and method.",
      "It declares a variable.",
      "It initializes an object.",
      "It controls loop behavior.",
    ],
    correctAnswer: "A",
    explanation: "The keyword public is a modifier.",
    source: "Page 4",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 380,
    question: "Access modifiers in Java control access to what elements?",
    options: [
      "Class members from specific locations.",
      "Only class definitions.",
      "Variable types only.",
      "Method parameters only.",
    ],
    correctAnswer: "A",
    explanation: "Access modifiers determine where a class member can be accessed from.",
    source: "Page 5",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 381,
    question: "What are the four provided access levels in Java?",
    options: [
      "public, protected, default (no keyword), private.",
      "static, final, abstract, synchronized.",
      "public, private, static, final.",
      "protected, default, transient, volatile.",
    ],
    correctAnswer: "A",
    explanation: "Java provides four access levels: public, protected, default (no keyword), private.",
    source: "Page 5",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 382,
    question: "For top-level classes, which access modifiers are permitted?",
    options: [
      "Only public and default (no modifier).",
      "All four including private and protected.",
      "Only private and protected.",
      "Only abstract and final.",
    ],
    correctAnswer: "A",
    explanation: "Only two modifiers are allowed for top-level classes: public and default (no modifier).",
    source: "Page 6",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 383,
    question: "If a top-level class uses public, what access does it grant?",
    options: [
      "Accessible from any other class.",
      "Accessible only within the same package.",
      "No access outside its file.",
      "Access only by subclasses.",
    ],
    correctAnswer: "A",
    explanation: "public: The class is accessible from any other class.",
    source: "Page 6",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 384,
    question: "If no modifier is used for a top-level class, what is its access scope?",
    options: [
      "Accessible only within the same package.",
      "Accessible from any other class.",
      "Hidden completely.",
      "Accessible by subclasses anywhere.",
    ],
    correctAnswer: "A",
    explanation: "default (no modifier): The class is accessible only within the same package.",
    source: "Page 6",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 385,
    question: "Regarding packages in relation to class access modifiers, what is noted for future study?",
    options: [
      "You will learn more about packages later in this course.",
      "Packages are not related to access.",
      "Packages replace modifiers.",
      "Packages are covered immediately.",
    ],
    correctAnswer: "A",
    explanation: "You will learn more about packages later in this course.",
    source: "Page 6",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 386,
    question: "A top-level class is defined in what location?",
    options: [
      "Directly in a .java file.",
      "Inside another class or method.",
      "Within a package only.",
      "In a constructor.",
    ],
    correctAnswer: "A",
    explanation: "Top-level: Directly in a .java file.",
    source: "Page 7",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 387,
    question: "Where is a nested class typically defined?",
    options: [
      "Inside another class or method.",
      "Directly in a .java file.",
      "In an external package.",
      "In the main function.",
    ],
    correctAnswer: "A",
    explanation: "Nested: Inside another class or method.",
    source: "Page 7",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 388,
    question: "Top-level classes are commonly used for what purpose?",
    options: [
      "Main classes of programs.",
      "Utility or helper classes.",
      "Data validation only.",
      "Method definitions only.",
    ],
    correctAnswer: "A",
    explanation: "Main classes of programs.",
    source: "Page 7",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 389,
    question: "Nested classes are often employed as what?",
    options: [
      "Utility or helper classes.",
      "Main classes of programs.",
      "Abstract base classes.",
      "Final immutable classes.",
    ],
    correctAnswer: "A",
    explanation: "Utility or helper classes.",
    source: "Page 7",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 390,
    question: "In the code snippet, what type is the class named Outer?",
    options: [
      "Top-level class.",
      "Nested class.",
      "Abstract class.",
      "Static class.",
    ],
    correctAnswer: "A",
    explanation: "// Top-Level class public class Outer {.",
    source: "Page 7",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 391,
    question: "In the code snippet, what type is the class named Inner?",
    options: [
      "Nested class.",
      "Top-level class.",
      "Public class.",
      "Private class.",
    ],
    correctAnswer: "A",
    explanation: "// Nested class class Inner {.",
    source: "Page 7",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 392,
    question: "Top-level classes are restricted to which access modifiers?",
    options: [
      "public and default (no modifier).",
      "private and protected.",
      "final and abstract.",
      "static and volatile.",
    ],
    correctAnswer: "A",
    explanation: "Top-level classes can only use: public, default (no modifier).",
    source: "Page 8",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 393,
    question: "What is the reason top-level classes cannot use private or protected?",
    options: [
      "They imply visibility relative to another class, but top-level is not inside another.",
      "They are for methods only.",
      "They conflict with non-access modifiers.",
      "They make classes non-instantiable.",
    ],
    correctAnswer: "A",
    explanation: "private and protected imply visibility inside or relative to another class; A top-level class is not inside another class, so private and protected are not meaningful.",
    source: "Page 8",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 394,
    question: "Which declaration is valid for a top-level class using public?",
    options: [
      "public class MyClass { }",
      "private class HiddenClass { }",
      "protected class SubClass { }",
      "abstract class AbsClass { }",
    ],
    correctAnswer: "A",
    explanation: "Valid: public class MyClass { }.",
    source: "Page 9",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 395,
    question: "Which shows a valid default access top-level class?",
    options: [
      "class PackageClass { }",
      "public class MyClass { }",
      "private class HiddenClass { }",
      "protected class SubClass { }",
    ],
    correctAnswer: "A",
    explanation: "class PackageClass { } // default access.",
    source: "Page 9",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 396,
    question: "What issue arises with private class HiddenClass { } as top-level?",
    options: [
      "It causes an ERROR, as private is invalid for top-level.",
      "It is valid but restricted.",
      "It requires nesting.",
      "It needs public extension.",
    ],
    correctAnswer: "A",
    explanation: "Invalid: private class HiddenClass { } // ERROR.",
    source: "Page 9",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 397,
    question: "What problem occurs with protected class SubClass { } for top-level?",
    options: [
      "It results in an ERROR, as protected is not allowed.",
      "It is valid for inheritance only.",
      "It conflicts with default.",
      "It must be final.",
    ],
    correctAnswer: "A",
    explanation: "protected class SubClass { } // ERROR.",
    source: "Page 9",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 398,
    question: "For fields or methods, what scope does public provide?",
    options: [
      "Accessible from any class.",
      "Only within declaring class.",
      "Only same package.",
      "Same package and subclasses.",
    ],
    correctAnswer: "A",
    explanation: "public: Accessible from any class.",
    source: "Page 10",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 399,
    question: "What limits access when using private for members?",
    options: [
      "Only within the declaring class.",
      "From any class.",
      "Only same package.",
      "Same package and subclasses.",
    ],
    correctAnswer: "A",
    explanation: "private: Accessible only within the declaring class.",
    source: "Page 10",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 400,
    question: "No modifier for members means access is limited to what?",
    options: [
      "Only within the same package.",
      "From any class.",
      "Only declaring class.",
      "Same package and subclasses.",
    ],
    correctAnswer: "A",
    explanation: "default (no modifier): Accessible only within the same package.",
    source: "Page 10",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 401,
    question: "Protected members can be accessed where?",
    options: [
      "Within same package and by subclasses.",
      "From any class.",
      "Only declaring class.",
      "Only same package.",
    ],
    correctAnswer: "A",
    explanation: "protected: Accessible within the same package and by subclasses.",
    source: "Page 10",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 402,
    question: "The protected modifier's use is clarified in the context of what topic?",
    options: [
      "Inheritance.",
      "Packages.",
      "Encapsulation.",
      "Modifiers.",
    ],
    correctAnswer: "A",
    explanation: "The use of protected will become clearer when we study inheritance.",
    source: "Page 10",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 403,
    question: "In the Student class code, why can't 'name' be accessed externally?\n\npublic class Student {\n  private String name;\n  public void setName(String n) {\n    name = n;\n  }\n  public String getName() {\n    return name;\n  }\n}",
    options: [
      "It is private, not accessible outside the class.",
      "It is public, but hidden.",
      "It is protected for subclasses.",
      "It is default package level.",
    ],
    correctAnswer: "A",
    explanation: "name is private – not accessible outside the class.",
    source: "Page 11",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 404,
    question: "In the Student class, what role do setName and getName play?\n\npublic class Student {\n  private String name;\n  public void setName(String n) {\n    name = n;\n  }\n  public String getName() {\n    return name;\n  }\n}",
    options: [
      "Provide controlled access to the field.",
      "Expose the field directly.",
      "Make the field static.",
      "Declare the field abstract.",
    ],
    correctAnswer: "A",
    explanation: "setName() and getName() provide controlled access.",
    source: "Page 11",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 405,
    question: "A final class prevents what action?",
    options: [
      "Extension or subclassing.",
      "Instantiation.",
      "Method overriding.",
      "Field modification.",
    ],
    correctAnswer: "A",
    explanation: "final: The class cannot be extended (no subclassing allowed).",
    source: "Page 12",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 406,
    question: "An abstract class requires what?",
    options: [
      "Subclassing; cannot be instantiated directly.",
      "No subclassing allowed.",
      "All methods to have bodies.",
      "Fields to be modifiable.",
    ],
    correctAnswer: "A",
    explanation: "abstract: The class cannot be instantiated; must be subclassed.",
    source: "Page 12",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 407,
    question: "Final applied to fields or methods means what?",
    options: [
      "Fields cannot be modified; methods cannot be overridden.",
      "Belong to class, not instance.",
      "Method without body, must override.",
      "Skipped in serialization.",
    ],
    correctAnswer: "A",
    explanation: "final: Cannot be modified (fields) or overridden (methods).",
    source: "Page 13",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 408,
    question: "What does static indicate for fields or methods?",
    options: [
      "Belongs to the class, not to any instance.",
      "Cannot be modified or overridden.",
      "Declares without body for override.",
      "Allows single thread access only.",
    ],
    correctAnswer: "A",
    explanation: "static: Belongs to the class, not to any instance.",
    source: "Page 13",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 409,
    question: "Abstract for methods declares what?",
    options: [
      "Method without body; must be overridden in subclass.",
      "Belongs to class.",
      "Cannot be modified.",
      "Read from main memory.",
    ],
    correctAnswer: "A",
    explanation: "abstract: Declares a method without a body; must be overridden in subclass.",
    source: "Page 13",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 410,
    question: "Transient fields are handled how during serialization?",
    options: [
      "Skipped.",
      "Read from cache.",
      "Single thread access.",
      "Without body.",
    ],
    correctAnswer: "A",
    explanation: "transient: Skipped during serialization.",
    source: "Page 13",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 411,
    question: "Synchronized methods allow access in what manner?",
    options: [
      "Only one thread at a time.",
      "Skipped in serialization.",
      "Belong to instance.",
      "Can be overridden.",
    ],
    correctAnswer: "A",
    explanation: "synchronized: Allows only one thread to access the method at a time.",
    source: "Page 13",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 412,
    question: "Volatile fields are always read from where?",
    options: [
      "Main memory, not thread-local cache.",
      "Thread cache only.",
      "Serialization stream.",
      "Subclass override.",
    ],
    correctAnswer: "A",
    explanation: "volatile: Always read from main memory, not thread-local cache.",
    source: "Page 13",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 413,
    question: "Access modifiers help manage what to support encapsulation?",
    options: [
      "Visibility.",
      "Inheritance only.",
      "Concurrency only.",
      "Memory only.",
    ],
    correctAnswer: "A",
    explanation: "Use access modifiers to manage visibility and support encapsulation.",
    source: "Page 14",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 414,
    question: "Non-access modifiers control aspects like what?",
    options: [
      "Inheritance, concurrency, memory behavior, method structure.",
      "Visibility and encapsulation only.",
      "Data wrapping only.",
      "Package organization.",
    ],
    correctAnswer: "A",
    explanation: "Use non-access modifiers to control inheritance, concurrency, memory behavior, and method structure.",
    source: "Page 14",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 415,
    question: "What advantage comes from mastering modifiers in Java?",
    options: [
      "Writing robust, maintainable, and secure code.",
      "Handling only basic syntax.",
      "Managing exceptions solely.",
      "Creating simple loops.",
    ],
    correctAnswer: "A",
    explanation: "Mastering Java modifiers helps you write robust, maintainable, and secure code.",
    source: "Page 14",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 416,
    question: "Encapsulation involves wrapping what into a class with restricted access?",
    options: [
      "Data (fields) and methods, restricting direct access to components.",
      "Only methods without data.",
      "Classes into packages.",
      "Modifiers into categories.",
    ],
    correctAnswer: "A",
    explanation: "Wrapping data (fields) and methods into a single unit – the class – and restricting direct access to some components.",
    source: "Page 15",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 417,
    question: "In which programming paradigm is encapsulation a fundamental principle?",
    options: [
      "Object-Oriented Programming.",
      "Procedural Programming.",
      "Functional Programming.",
      "Script-based Programming.",
    ],
    correctAnswer: "A",
    explanation: "Encapsulation is one of the fundamental principles of Object-Oriented Programming.",
    source: "Page 15",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 418,
    question: "The core of encapsulation prohibits direct access to what?",
    options: [
      "Data inside an object.",
      "Methods in a class.",
      "Public modifiers.",
      "Static fields.",
    ],
    correctAnswer: "A",
    explanation: "Data inside an object should not be directly accessible.",
    source: "Page 16",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 419,
    question: "Under encapsulation, object data should be accessed how?",
    options: [
      "Via methods.",
      "Directly.",
      "Through static calls.",
      "Via inheritance.",
    ],
    correctAnswer: "A",
    explanation: "Instead, it should be accessed via methods.",
    source: "Page 16",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 420,
    question: "Encapsulation uses what to restrict and control access?",
    options: [
      "Access modifiers and getter/setter methods.",
      "Only public fields.",
      "Abstract classes.",
      "Final modifiers.",
    ],
    correctAnswer: "A",
    explanation: "This is done using access modifiers and getter/setter methods.",
    source: "Page 16",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 421,
    question: "In the Account class example, why is 'balance' commented as hidden?",
    options: [
      "It is private.",
      "It is public.",
      "It is static.",
      "It is final.",
    ],
    correctAnswer: "A",
    explanation: "private double balance; // hidden.",
    source: "Page 16",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 422,
    question: "In the Account class, deposit adds amount only under what condition?",
    options: [
      "If amount > 0.",
      "Always regardless of amount.",
      "If amount < 0.",
      "If balance > amount.",
    ],
    correctAnswer: "A",
    explanation: "if (amount > 0) balance += amount;.",
    source: "Page 16",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 423,
    question: "How does encapsulation protect data integrity?",
    options: [
      "Prevents unauthorized or invalid access.",
      "Allows all changes.",
      "Exposes internals.",
      "Removes validation.",
    ],
    correctAnswer: "A",
    explanation: "1. Protects data integrity: Prevents unauthorized or invalid access.",
    source: "Page 17",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 424,
    question: "Encapsulation improves maintainability by ensuring what about changes?",
    options: [
      "Internal changes do not affect external code.",
      "External code must change with internals.",
      "No changes are possible.",
      "All code is affected.",
    ],
    correctAnswer: "A",
    explanation: "2. Improves maintainability: Changes to internal implementation do not affect external code.",
    source: "Page 17",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 425,
    question: "What does encapsulation provide through methods?",
    options: [
      "Controlled access with safe interactions via well-defined methods.",
      "Uncontrolled direct access.",
      "No access at all.",
      "Access without definitions.",
    ],
    correctAnswer: "A",
    explanation: "3. Provides controlled access: Only allows safe interactions through well-defined methods.",
    source: "Page 17",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 426,
    question: "Encapsulation encourages what design where objects have clear interfaces?",
    options: [
      "Modular design with self-contained objects.",
      "Monolithic design.",
      "Dependent objects.",
      "Unclear interfaces.",
    ],
    correctAnswer: "A",
    explanation: "4. Encourages modular design: Objects are self-contained, with clear interfaces.",
    source: "Page 17",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 427,
    question: "In the non-encapsulated Student class, what problem exists with 'age'?\n\nclass Student {\n  public int age; // directly modifiable\n}",
    options: [
      "It is directly modifiable.",
      "It has validation built-in.",
      "It is hidden.",
      "It is read-only.",
    ],
    correctAnswer: "A",
    explanation: "public int age; // directly modifiable.",
    source: "Page 18",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 428,
    question: "In the encapsulated Student class, access to 'age' is managed how?\n\nclass Student {\n  private int age;\n  public void setAge(int a) {\n    if (a >= 0) age = a;\n  }\n  public int getAge() {\n    return age;\n  }\n}",
    options: [
      "Via setter with validation and getter.",
      "Directly without methods.",
      "No access provided.",
      "Static class level.",
    ],
    correctAnswer: "A",
    explanation: "private int age; public void setAge(int a) { if (a >= 0) age = a; } public int getAge() { return age; }.",
    source: "Page 18",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 429,
    question: "How does the non-encapsulated version differ in data handling?",
    options: [
      "Exposes internal data directly.",
      "Allows only validated access.",
      "Uses private fields.",
      "Provides methods only.",
    ],
    correctAnswer: "A",
    explanation: "The first version exposes the internal data directly.",
    source: "Page 18",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 430,
    question: "What advantage does the encapsulated version offer?",
    options: [
      "Allows only safe, validated access.",
      "Exposes data directly.",
      "No validation needed.",
      "Public fields used.",
    ],
    correctAnswer: "A",
    explanation: "The second version allows only safe, validated access.",
    source: "Page 18",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 431,
    question: "In the example showing issues with public fields, how is 'age' declared?\n\nclass Student {\n  public int age;\n}",
    options: [
      "public int age;",
      "private int age;",
      "protected int age;",
      "static int age;",
    ],
    correctAnswer: "A",
    explanation: "class Student { public int age; }.",
    source: "Page 19",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 432,
    question: "In the usage, why is s.age = -5; problematic?",
    options: [
      "It is allowed but wrong, as negative age is invalid.",
      "It is not allowed by compiler.",
      "It sets to positive automatically.",
      "It causes runtime error.",
    ],
    correctAnswer: "A",
    explanation: "s.age = -5; // This is allowed, but it's wrong!.",
    source: "Page 19",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 433,
    question: "The lack of rules for public fields leads to what?",
    options: [
      "Dangerous bad data from invalid assignments like negative age.",
      "Automatic validation.",
      "Safe data always.",
      "No assignments possible.",
    ],
    correctAnswer: "A",
    explanation: "Problem: No rule stops us from assigning a negative age. ⚠ This is dangerous and leads to bad data.",
    source: "Page 19",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 434,
    question: "To protect 'age', what modifier is applied in step 1?\n\nclass Student {\n  private int age; // hidden from outside\n}",
    options: [
      "private.",
      "public.",
      "protected.",
      "static.",
    ],
    correctAnswer: "A",
    explanation: "To protect the age field, we make it private: class Student { private int age; // hidden from outside }.",
    source: "Page 20",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 435,
    question: "Attempting s.age = 20; after making private results in what?",
    options: [
      "ERROR due to private access.",
      "Successful assignment.",
      "Default value set.",
      "Method call required.",
    ],
    correctAnswer: "A",
    explanation: "s.age = 20; // ❌ ERROR: age has private access.",
    source: "Page 20",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 436,
    question: "This initial encapsulation step is known as what?",
    options: [
      "Data hiding.",
      "Method exposure.",
      "Field validation.",
      "Access granting.",
    ],
    correctAnswer: "A",
    explanation: "ℹ This is the first step of Encapsulation: data hiding.",
    source: "Page 20",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 437,
    question: "The setAge method sets age only if what?",
    options: [
      "a >= 0.",
      "a < 0.",
      "Always.",
      "If a == 0.",
    ],
    correctAnswer: "A",
    explanation: "public void setAge(int a) { if (a >= 0) { age = a; } }.",
    source: "Page 21",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 438,
    question: "After step 2, the Student class contains what elements?",
    options: [
      "private age and public setAge with check.",
      "public age only.",
      "getter included.",
      "no fields.",
    ],
    correctAnswer: "A",
    explanation: "class Student { private int age; public void setAge(int a) { if (a >= 0) { age = a; } } }.",
    source: "Page 21",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 439,
    question: "For s.setAge(20); it assigns, but for s.setAge(-5); what occurs?",
    options: [
      "Nothing happens, data stays valid.",
      "Assigns negative.",
      "Throws error.",
      "Sets to zero.",
    ],
    correctAnswer: "A",
    explanation: "s.setAge(20); // ✅ Safe assignment s.setAge(-5); // ✅ Nothing happens (data stays valid).",
    source: "Page 21",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 440,
    question: "The getAge method performs what action?",
    options: [
      "Returns age value.",
      "Sets age value.",
      "Validates age.",
      "Hides age.",
    ],
    correctAnswer: "A",
    explanation: "public int getAge() { return age; }.",
    source: "Page 22",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 441,
    question: "With getter added, what does the full Student class include?",
    options: [
      "private age, setAge with check, getAge return.",
      "public age.",
      "No setter.",
      "Abstract methods.",
    ],
    correctAnswer: "A",
    explanation: "class Student { private int age; public void setAge(int a) { if (a >= 0) { age = a; } } public int getAge() { return age; } }.",
    source: "Page 22",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 442,
    question: "After s.setAge(21); what does s.getAge() return when printed?",
    options: [
      "21.",
      "0.",
      "Error.",
      "Nothing.",
    ],
    correctAnswer: "A",
    explanation: "s.setAge(21); // set value System.out.println(s.getAge()); // print value → 21.",
    source: "Page 23",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 443,
    question: "Using getter and setter provides what over field access?",
    options: [
      "Full control.",
      "No control.",
      "Partial direct access.",
      "Static control.",
    ],
    correctAnswer: "A",
    explanation: "✅ Now we have full control over how the field is accessed.",
    source: "Page 23",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 444,
    question: "Best practice recommends what modifier for all fields?",
    options: [
      "private.",
      "public.",
      "protected.",
      "default.",
    ],
    correctAnswer: "A",
    explanation: "Use private for all fields.",
    source: "Page 24",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 445,
    question: "Use what to safely access fields per best practices?",
    options: [
      "public methods (getters/setters).",
      "Direct field access.",
      "Static fields.",
      "Abstract access.",
    ],
    correctAnswer: "A",
    explanation: "Use public methods (getters/setters) to access fields safely.",
    source: "Page 24",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 446,
    question: "Where should validation be included when necessary?",
    options: [
      "In setters.",
      "In getters.",
      "In fields directly.",
      "Never.",
    ],
    correctAnswer: "A",
    explanation: "Add validation in setters when needed.",
    source: "Page 24",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 447,
    question: "For unchanging fields, what should be avoided?",
    options: [
      "Creating setters.",
      "Creating getters.",
      "Using private.",
      "Adding validation.",
    ],
    correctAnswer: "A",
    explanation: "Do not create setters for fields that should not change.",
    source: "Page 24",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 448,
    question: "The private keyword serves to do what in recap?",
    options: [
      "Hide data from outside.",
      "Allow method access.",
      "Return field value.",
      "Set with checks.",
    ],
    correctAnswer: "A",
    explanation: "private Hides data from outside.",
    source: "Page 25",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 449,
    question: "Public in encapsulation allows what via methods?",
    options: [
      "Access through methods.",
      "Data hiding.",
      "Value return.",
      "Value setting.",
    ],
    correctAnswer: "A",
    explanation: "public Allows access through methods.",
    source: "Page 25",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 450,
    question: "What do getter methods like getX() do?",
    options: [
      "Return the value of a field.",
      "Set value with checks.",
      "Hide data.",
      "Allow access.",
    ],
    correctAnswer: "A",
    explanation: "getX() Returns the value of a field.",
    source: "Page 25",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 451,
    question: "Setter methods like setX() perform what?",
    options: [
      "Set value with optional checks.",
      "Return field value.",
      "Hide from outside.",
      "Allow direct access.",
    ],
    correctAnswer: "A",
    explanation: "setX() Sets the value with optional checks.",
    source: "Page 25",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 452,
    question: "How are name and age declared in the encapsulated Student?",
    options: [
      "private String name; private int age;",
      "public String name; public int age;",
      "protected String name; protected int age;",
      "static String name; static int age;",
    ],
    correctAnswer: "A",
    explanation: "private String name; private int age;.",
    source: "Page 26",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 453,
    question: "In the Student class, setAge assigns only if what?",
    options: [
      "a >= 0.",
      "Always.",
      "a < 0.",
      "a == age.",
    ],
    correctAnswer: "A",
    explanation: "if (a >= 0) age = a;.",
    source: "Page 26",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 454,
    question: "Fields in this Student example are handled with what modifier?",
    options: [
      "private.",
      "public.",
      "protected.",
      "static.",
    ],
    correctAnswer: "A",
    explanation: "Fields are private.",
    source: "Page 26",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 455,
    question: "Methods in the Student class control what aspects?",
    options: [
      "How values are assigned and retrieved.",
      "Direct field modification.",
      "Class extension.",
      "Thread synchronization.",
    ],
    correctAnswer: "A",
    explanation: "Methods control how values are assigned and retrieved.",
    source: "Page 26",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 456,
    question: "In usage, external code is prevented from what with fields?",
    options: [
      "Direct access.",
      "Using setters.",
      "Using getters.",
      "Printing values.",
    ],
    correctAnswer: "A",
    explanation: "External code cannot directly access fields.",
    source: "Page 27",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 457,
    question: "All field interactions in Student usage occur through what?",
    options: [
      "Controlled methods.",
      "Direct fields.",
      "Constructors only.",
      "Static variables.",
    ],
    correctAnswer: "A",
    explanation: "All access is through controlled methods.",
    source: "Page 27",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 458,
    question: "'balance' in BankAccount is declared with what?",
    options: [
      "private double balance;",
      "public double balance;",
      "final double balance;",
      "static double balance;",
    ],
    correctAnswer: "A",
    explanation: "private double balance;.",
    source: "Page 28",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 459,
    question: "Deposit in BankAccount adds if what is true?",
    options: [
      "amount > 0.",
      "amount <= balance.",
      "Always adds.",
      "amount < 0.",
    ],
    correctAnswer: "A",
    explanation: "if (amount > 0) balance += amount;.",
    source: "Page 28",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 460,
    question: "Withdraw subtracts if what conditions?",
    options: [
      "amount > 0 && amount <= balance.",
      "amount > 0 only.",
      "amount <= balance only.",
      "Always subtracts.",
    ],
    correctAnswer: "A",
    explanation: "if (amount > 0 && amount <= balance) balance -= amount;.",
    source: "Page 28",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 461,
    question: "Balance changes only via what in BankAccount?",
    options: [
      "Business rules.",
      "Direct assignment.",
      "Public access.",
      "No changes allowed.",
    ],
    correctAnswer: "A",
    explanation: "Balance can only be changed through business rules.",
    source: "Page 28",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 462,
    question: "Invalid operations like negative deposit are handled how?",
    options: [
      "Rejected.",
      "Allowed.",
      "Converted to positive.",
      "Cause error.",
    ],
    correctAnswer: "A",
    explanation: "Invalid operations (e.g., negative deposit) are rejected.",
    source: "Page 28",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 463,
    question: "In BankAccount usage, what is protected from invalid changes?",
    options: [
      "Internal state.",
      "External methods.",
      "Balance value.",
      "Deposit method.",
    ],
    correctAnswer: "A",
    explanation: "The internal state is protected.",
    source: "Page 29",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 464,
    question: "Usage of BankAccount permits only what kind of operations?",
    options: [
      "Valid operations.",
      "All operations.",
      "No operations.",
      "Invalid only.",
    ],
    correctAnswer: "A",
    explanation: "Only valid operations are allowed.",
    source: "Page 29",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 465,
    question: "In Country class, 'name' is set where?",
    options: [
      "In constructor once.",
      "In setter.",
      "Directly external.",
      "In getter.",
    ],
    correctAnswer: "A",
    explanation: "The field name is initialized once in the constructor.",
    source: "Page 30",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 466,
    question: "Absence of setter in Country ensures what?",
    options: [
      "Value cannot change later.",
      "Value changes freely.",
      "Multiple initializations.",
      "External modifications.",
    ],
    correctAnswer: "A",
    explanation: "No setter means the value cannot be changed later.",
    source: "Page 30",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 467,
    question: "Fields in immutable Student are what?",
    options: [
      "private and final.",
      "public and modifiable.",
      "protected and static.",
      "default and volatile.",
    ],
    correctAnswer: "A",
    explanation: "Fields are private and final.",
    source: "Page 31",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 468,
    question: "In immutable Student, what is not provided?",
    options: [
      "Setters.",
      "Getters.",
      "Constructor.",
      "Fields.",
    ],
    correctAnswer: "A",
    explanation: "No setters are provided.",
    source: "Page 31",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 469,
    question: "Values in immutable Student are set how?",
    options: [
      "Once via constructor.",
      "Multiple times via setters.",
      "Directly on fields.",
      "In getters.",
    ],
    correctAnswer: "A",
    explanation: "Values are set once via the constructor.",
    source: "Page 31",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 470,
    question: "Use private for what in encapsulation summary?",
    options: [
      "Hide internal fields.",
      "Expose fields.",
      "Define packages.",
      "Import classes.",
    ],
    correctAnswer: "A",
    explanation: "Use private to hide internal fields.",
    source: "Page 32",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 471,
    question: "Methods are used to do what in practice?",
    options: [
      "Validate and control access.",
      "Direct modifications.",
      "Avoid access.",
      "Static definitions.",
    ],
    correctAnswer: "A",
    explanation: "Use methods to validate and control access.",
    source: "Page 32",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 472,
    question: "Avoid setters when fields are intended as what?",
    options: [
      "Read-only.",
      "Modifiable.",
      "Public.",
      "Static.",
    ],
    correctAnswer: "A",
    explanation: "Do not provide setters when fields should be read-only.",
    source: "Page 32",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 473,
    question: "Immutable classes provide what for internal state?",
    options: [
      "Full protection.",
      "No protection.",
      "Partial exposure.",
      "External control.",
    ],
    correctAnswer: "A",
    explanation: "Immutable classes ensure full protection of internal state.",
    source: "Page 32",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 474,
    question: "A Java package acts as what for organizing classes/interfaces?",
    options: [
      "Namespace.",
      "Class extender.",
      "Method wrapper.",
      "Field hider.",
    ],
    correctAnswer: "A",
    explanation: "A package is a namespace that organizes a set of related classes and interfaces.",
    source: "Page 33",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 475,
    question: "What best practice uses private in encapsulation?",
    options: [
      "Hide internal fields.",
      "Expose fields.",
      "Define packages.",
      "Import classes.",
    ],
    correctAnswer: "A",
    explanation: "Use private to hide internal fields.",
    source: "Page 32",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 476,
    question: "What best practice uses methods in encapsulation?",
    options: [
      "Validate and control access.",
      "Direct access.",
      "Avoid methods.",
      "Use static only.",
    ],
    correctAnswer: "A",
    explanation: "Use methods to validate and control access.",
    source: "Page 32",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 477,
    question: "When should setters not be provided?",
    options: [
      "When fields should be read-only.",
      "Always provide setters.",
      "For public fields.",
      "For private fields.",
    ],
    correctAnswer: "A",
    explanation: "Do not provide setters when fields should be read-only.",
    source: "Page 32",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 478,
    question: "What do immutable classes ensure?",
    options: [
      "Full protection of internal state.",
      "Partial protection.",
      "No protection.",
      "External changes.",
    ],
    correctAnswer: "A",
    explanation: "Immutable classes ensure full protection of internal state.",
    source: "Page 32",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 479,
    question: "A Java package acts as what for organizing classes/interfaces?",
    options: [
      "Namespace.",
      "Class extender.",
      "Method wrapper.",
      "Field hider.",
    ],
    correctAnswer: "A",
    explanation: "A package is a namespace that organizes a set of related classes and interfaces.",
    source: "Page 33",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 480,
    question: "Packages help prevent what with class names?",
    options: [
      "Conflicts.",
      "Grouping.",
      "Maintenance.",
      "Access.",
    ],
    correctAnswer: "A",
    explanation: "Prevents class name conflicts.",
    source: "Page 33",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 481,
    question: "What do packages do with similar classes?",
    options: [
      "Group them together.",
      "Separate them.",
      "Delete duplicates.",
      "Make abstract.",
    ],
    correctAnswer: "A",
    explanation: "Groups similar classes together.",
    source: "Page 33",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 482,
    question: "Packages aid in maintaining what scale of projects?",
    options: [
      "Large projects.",
      "Small only.",
      "No projects.",
      "Medium only.",
    ],
    correctAnswer: "A",
    explanation: "Helps maintain large projects.",
    source: "Page 33",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 483,
    question: "Package declaration appears where in .java file?",
    options: [
      "At the top.",
      "At bottom.",
      "In class.",
      "In main.",
    ],
    correctAnswer: "A",
    explanation: "At the top of your .java file, declare the package:.",
    source: "Page 34",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 484,
    question: "What is an example of package declaration?",
    options: [
      "package myschool.student;",
      "import myschool.student;",
      "class myschool.student;",
      "public myschool.student;",
    ],
    correctAnswer: "A",
    explanation: "package myschool.student;.",
    source: "Page 34",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 485,
    question: "To use a class from another package, what statement?",
    options: [
      "import myschool.student.Student;",
      "package myschool.student;",
      "extend myschool.student;",
      "new myschool.student;",
    ],
    correctAnswer: "A",
    explanation: "import myschool.student.Student;.",
    source: "Page 34",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 486,
    question: "java.lang package offers what and import status?",
    options: [
      "Core features, automatically imported.",
      "Data structures, manual import.",
      "IO, manual.",
      "Date time, auto.",
    ],
    correctAnswer: "A",
    explanation: "java.lang – core language features (automatically imported).",
    source: "Page 35",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 487,
    question: "What does java.util provide?",
    options: [
      "Data structures and utilities.",
      "Core features.",
      "Input output.",
      "Math operations.",
    ],
    correctAnswer: "A",
    explanation: "java.util – data structures and utilities.",
    source: "Page 35",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 488,
    question: "java.io is for what?",
    options: [
      "Input/output.",
      "Date and time.",
      "Math.",
      "Core.",
    ],
    correctAnswer: "A",
    explanation: "java.io – input/output.",
    source: "Page 35",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 489,
    question: "java.time handles what?",
    options: [
      "Date and time.",
      "Math operations.",
      "IO.",
      "Utilities.",
    ],
    correctAnswer: "A",
    explanation: "java.time – date and time.",
    source: "Page 35",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 490,
    question: "What is java.math for?",
    options: [
      "Mathematical operations.",
      "Date time.",
      "Core features.",
      "Data structures.",
    ],
    correctAnswer: "A",
    explanation: "java.math – mathematical operations.",
    source: "Page 35",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 491,
    question: "What import is used for Scanner in the example?",
    options: [
      "import java.util.Scanner;",
      "import java.lang.Scanner;",
      "import java.io.Scanner;",
      "No import needed.",
    ],
    correctAnswer: "A",
    explanation: "import java.util.Scanner;.",
    source: "Page 36",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 492,
    question: "Scanner in the code reads what?",
    options: [
      "Input from System.in, like nextLine().",
      "Output to console.",
      "Math calculations.",
      "File handling.",
    ],
    correctAnswer: "A",
    explanation: "Scanner sc = new Scanner(System.in); String name = sc.nextLine();.",
    source: "Page 36",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 493,
    question: "Scanner belongs to which package?",
    options: [
      "java.util.",
      "java.lang.",
      "java.io.",
      "java.math.",
    ],
    correctAnswer: "A",
    explanation: "Scanner is part of the java.util package.",
    source: "Page 36",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 494,
    question: "Importing Scanner allows what in the program?",
    options: [
      "Use in the code.",
      "Hiding Scanner.",
      "Deleting class.",
      "Making private.",
    ],
    correctAnswer: "A",
    explanation: "We import it to use in our program.",
    source: "Page 36",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 495,
    question: "Public allows access from same and different packages how?",
    options: [
      "Yes from both.",
      "Yes same, no different.",
      "No both.",
      "Yes same, yes if subclass different.",
    ],
    correctAnswer: "A",
    explanation: "public ✅ ✅.",
    source: "Page 37",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 496,
    question: "Protected permits access from same package and different how?",
    options: [
      "Yes same, yes if subclass different.",
      "Yes both.",
      "Yes same, no different.",
      "No both.",
    ],
    correctAnswer: "A",
    explanation: "protected ✅ ✅ (if subclass).",
    source: "Page 37",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 497,
    question: "Default allows access from same and different packages how?",
    options: [
      "Yes same, no different.",
      "Yes both.",
      "No both.",
      "Yes same, yes subclass.",
    ],
    correctAnswer: "A",
    explanation: "default ✅ ❌.",
    source: "Page 37",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 498,
    question: "Private restricts access from same and different to what?",
    options: [
      "No from both.",
      "Yes both.",
      "Yes same, no different.",
      "Yes same, yes subclass.",
    ],
    correctAnswer: "A",
    explanation: "private ❌ ❌.",
    source: "Page 37",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 499,
    question: "Packages combine with what to control visibility across files?",
    options: [
      "Access modifiers.",
      "Classes.",
      "Methods.",
      "Fields.",
    ],
    correctAnswer: "A",
    explanation: "Key Point: Packages work with access modifiers to control visibility across files.",
    source: "Page 37",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 500,
    question: "Java API is a collection of what provided by the platform?",
    options: [
      "Prewritten classes.",
      "User classes.",
      "Modifiers only.",
      "Packages only.",
    ],
    correctAnswer: "A",
    explanation: "The Java API is a collection of prewritten classes provided by the Java platform.",
    source: "Page 38",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 501,
    question: "API includes classes for what examples?",
    options: [
      "Strings, files, networking, collections, etc.",
      "Only modifiers.",
      "Only access control.",
      "Only encapsulation.",
    ],
    correctAnswer: "A",
    explanation: "Includes classes for strings, files, networking, collections, etc.",
    source: "Page 38",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 502,
    question: "API saves time by avoiding what?",
    options: [
      "Reinventing the wheel.",
      "Using imports.",
      "Defining classes.",
      "Writing code.",
    ],
    correctAnswer: "A",
    explanation: "Saves time – no need to reinvent the wheel.",
    source: "Page 38",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 503,
    question: "How is the API documented?",
    options: [
      "Well-documented with examples.",
      "No documentation.",
      "Poorly.",
      "Examples only.",
    ],
    correctAnswer: "A",
    explanation: "Well-documented with examples.",
    source: "Page 38",
    topic: "Modifiers & Encapsulation",
  },
  {
    id: 504,
    question: "What is inheritance in Java?",
    options: [
      "A mechanism that allows one class to inherit fields and methods from another class.",
      "A way to create multiple instances of the same class.",
      "A keyword used to declare variables.",
      "A process to hide methods from subclasses."
    ],
    correctAnswer: "A",
    explanation: "Inheritance is a mechanism that allows one class to inherit fields and methods from another class.",
    source: "Page 2",
    topic: "Inheritance"
  },
  {
    id: 505,
    question: "What is a superclass?",
    options: [
      "The parent class containing common properties and methods.",
      "The child class that extends and adds to the parent class.",
      "A class that cannot be extended.",
      "A class with only static methods."
    ],
    correctAnswer: "A",
    explanation: "Superclass: the parent class containing common properties and methods.",
    source: "Page 2",
    topic: "Inheritance"
  },
  {
    id: 506,
    question: "What is a subclass?",
    options: [
      "The child class that extends and adds to the parent class.",
      "The parent class containing common properties and methods.",
      "A class that implements interfaces only.",
      "A final class that cannot be inherited."
    ],
    correctAnswer: "A",
    explanation: "Subclass: the child class that extends and adds to the parent class.",
    source: "Page 2",
    topic: "Inheritance"
  },
  {
    id: 507,
    question: "How is inheritance implemented in Java?",
    options: [
      "Using the extends keyword.",
      "Using the implements keyword.",
      "Using the final keyword.",
      "Using the static keyword."
    ],
    correctAnswer: "A",
    explanation: "In Java, inheritance is implemented using the extends keyword.",
    source: "Page 2",
    topic: "Inheritance"
  },
  {
    id: 508,
    question: "According to the code example in the slide, what does the Animal class contain?",
    options: [
      "A method void speak() that prints \"Animal sound\".",
      "A method void bark() that prints \"Woof!\".",
      "A constructor Animal(String name).",
      "A field String name."
    ],
    correctAnswer: "A",
    explanation: "class Animal { void speak() { System.out.println(\"Animal sound\"); } }",
    source: "Page 3",
    topic: "Inheritance"
  },
  {
    id: 509,
    question: "According to the code example in the slide, what does the Dog class extend and contain?",
    options: [
      "It extends Animal and has a method void bark() that prints \"Woof!\".",
      "It extends Dog and has a method void speak() that prints \"Animal sound\".",
      "It implements Flyable and has a method void fly().",
      "It extends Person and has a constructor Dog(String name)."
    ],
    correctAnswer: "A",
    explanation: "class Dog extends Animal { void bark() { System.out.println(\"Woof!\"); } }",
    source: "Page 3",
    topic: "Inheritance"
  },
  {
    id: 510,
    question: "According to the code example in the slide, what happens when this code is executed? Dog d = new Dog(); d.speak(); d.bark();",
    options: [
      "d.speak() is inherited from Animal and d.bark() is defined in Dog.",
      "d.speak() prints \"Woof!\" and d.bark() prints \"Animal sound\".",
      "d.speak() causes a compile error because it's not defined in Dog.",
      "d.bark() is inherited from Animal."
    ],
    correctAnswer: "A",
    explanation: "Dog d = new Dog(); d.speak(); // Inherited from Animal d.bark(); // Defined in Dog",
    source: "Page 3",
    topic: "Inheritance"
  },
  {
    id: 511,
    question: "What is the super keyword used for?",
    options: [
      "To access the constructor or methods of the superclass.",
      "To declare a final variable.",
      "To implement multiple inheritance.",
      "To hide fields in subclasses."
    ],
    correctAnswer: "A",
    explanation: "Used to access the constructor or methods of the superclass.",
    source: "Page 4",
    topic: "Inheritance"
  },
  {
    id: 512,
    question: "According to the code example in the slide, what does the Animal class have in its constructor?",
    options: [
      "Animal(String name) { this.name = name; }",
      "Animal() { System.out.println(\"Animal created\"); }",
      "Animal(String name) { super(name); }",
      "Animal() { System.out.println(\"Dog created\"); }"
    ],
    correctAnswer: "A",
    explanation: "class Animal { String name; Animal(String name) { this.name = name; } }",
    source: "Page 4",
    topic: "Inheritance"
  },
  {
    id: 513,
    question: "According to the code example in the slide, how does the Dog constructor use super?",
    options: [
      "Dog(String name) { super(name); // Calls the super class constructor }",
      "Dog() { System.out.println(\"Dog created\"); }",
      "Dog(String name) { this.name = name; }",
      "Dog() { super(); }"
    ],
    correctAnswer: "A",
    explanation: "class Dog extends Animal { Dog(String name) { super(name); // Calls the superclass constructor } }",
    source: "Page 4",
    topic: "Inheritance"
  },
  {
    id: 514,
    question: "What does overriding allow a subclass to do?",
    options: [
      "Provide a different implementation for a method defined in the superclass.",
      "Inherit constructors from the superclass.",
      "Declare fields as final.",
      "Implement multiple classes."
    ],
    correctAnswer: "A",
    explanation: "Overriding allows a subclass to provide a different implementation for a method defined in the superclass",
    source: "Page 5",
    topic: "Inheritance"
  },
  {
    id: 515,
    question: "According to the code example in the slide, what does the speak method in Animal do?",
    options: [
      "void speak() { System.out.println(\"Animal sound\"); }",
      "void speak() { System.out.println(\"Woof!\"); }",
      "void bark() { System.out.println(\"Woof!\"); }",
      "void speak() { super.speak(); }"
    ],
    correctAnswer: "A",
    explanation: "class Animal { void speak() { System.out.println(\"Animal sound\"); } }",
    source: "Page 5",
    topic: "Inheritance"
  },
  {
    id: 516,
    question: "According to the code example in the slide, what does the speak method in Dog do?",
    options: [
      "@Override void speak() { System.out.println(\"Woof!\"); }",
      "void speak() { System.out.println(\"Animal sound\"); }",
      "void bark() { System.out.println(\"Woof!\"); }",
      "void speak() { System.out.println(\"Dog barks\"); }"
    ],
    correctAnswer: "A",
    explanation: "class Dog extends Animal { @Override void speak() { System.out.println(\"Woof!\"); } }",
    source: "Page 5",
    topic: "Inheritance"
  },
  {
    id: 517,
    question: "According to the table in the slide, what are the columns for access modifiers in inheritance?",
    options: [
      "Modifier, Inherited?, Accessible from subclass?",
      "Modifier, Can Override?, Notes",
      "Keyword, Meaning, Used for",
      "Feature, Overriding, Hiding (Static)"
    ],
    correctAnswer: "A",
    explanation: "Modifier Inherited? Accessible from subclass?",
    source: "Page 6",
    topic: "Inheritance"
  },
  {
    id: 518,
    question: "According to the table in the slide, for private modifier, is it inherited and accessible from subclass?",
    options: [
      "No, No.",
      "Yes (same package), Yes (same package).",
      "Yes, Yes.",
      "Yes, Yes."
    ],
    correctAnswer: "A",
    explanation: "private No No",
    source: "Page 6",
    topic: "Inheritance"
  },
  {
    id: 519,
    question: "According to the table in the slide, for (default) modifier, is it inherited and accessible from subclass?",
    options: [
      "Yes (same package), Yes (same package).",
      "No, No.",
      "Yes, Yes.",
      "Yes, Yes."
    ],
    correctAnswer: "A",
    explanation: "(default) Yes (same package) Yes (same package)",
    source: "Page 6",
    topic: "Inheritance"
  },
  {
    id: 520,
    question: "According to the table in the slide, for protected modifier, is it inherited and accessible from subclass?",
    options: [
      "Yes, Yes.",
      "No, No.",
      "Yes (same package), Yes (same package).",
      "Yes, Yes."
    ],
    correctAnswer: "A",
    explanation: "protected Yes Yes",
    source: "Page 6",
    topic: "Inheritance"
  },
  {
    id: 521,
    question: "According to the table in the slide, for public modifier, is it inherited and accessible from subclass?",
    options: [
      "Yes, Yes.",
      "No, No.",
      "Yes (same package), Yes (same package).",
      "Yes, Yes."
    ],
    correctAnswer: "A",
    explanation: "public Yes Yes",
    source: "Page 6",
    topic: "Inheritance"
  },
  {
    id: 522,
    question: "What does a final class mean?",
    options: [
      "Cannot be extended.",
      "Cannot be overridden.",
      "Value cannot be changed after assignment.",
      "Can be inherited multiple times."
    ],
    correctAnswer: "A",
    explanation: "final class: cannot be extended.",
    source: "Page 7",
    topic: "Inheritance"
  },
  {
    id: 523,
    question: "What does a final method mean?",
    options: [
      "Cannot be overridden.",
      "Cannot be extended.",
      "Value cannot be changed after assignment.",
      "Can be hidden in subclasses."
    ],
    correctAnswer: "A",
    explanation: "final method: cannot be overridden.",
    source: "Page 7",
    topic: "Inheritance"
  },
  {
    id: 524,
    question: "What does a final variable mean?",
    options: [
      "Value cannot be changed after assignment.",
      "Cannot be extended.",
      "Cannot be overridden.",
      "Can be accessed only in the same package."
    ],
    correctAnswer: "A",
    explanation: "final variable: value cannot be changed after assignment.",
    source: "Page 7",
    topic: "Inheritance"
  },
  {
    id: 525,
    question: "Does Java support multiple inheritance using classes?",
    options: [
      "No, a class cannot extend more than one class.",
      "Yes, using the extends keyword for multiple classes.",
      "Yes, but only with interfaces.",
      "No, but it allows method hiding."
    ],
    correctAnswer: "A",
    explanation: "Java does not support multiple inheritance using classes. In Java, a class cannot extend more than one class.",
    source: "Page 8",
    topic: "Inheritance"
  },
  {
    id: 526,
    question: "Why does Java restrict multiple inheritance with classes?",
    options: [
      "To avoid ambiguity, especially in cases where two superclasses define the same method or field.",
      "To allow covariant return types.",
      "To support constructor chaining.",
      "To enable field shadowing."
    ],
    correctAnswer: "A",
    explanation: "This restriction exists to avoid ambiguity, especially in cases where two superclasses define the same method or field.",
    source: "Page 8",
    topic: "Inheritance"
  },
  {
    id: 527,
    question: "According to the code example in the slide, what does class A contain?",
    options: [
      "void print() { System.out.println(\"From A\"); }",
      "void print() { System.out.println(\"From B\"); }",
      "void fly() { System.out.println(\"Duck flies\"); }",
      "void swim() { System.out.println(\"Duck swims\"); }"
    ],
    correctAnswer: "A",
    explanation: "class A{ void print() { System.out.println(\"From A\"); } }",
    source: "Page 9",
    topic: "Inheritance"
  },
  {
    id: 528,
    question: "According to the code example in the slide, what does class B contain?",
    options: [
      "void print() { System.out.println(\"From B\"); }",
      "void print() { System.out.println(\"From A\"); }",
      "void fly() { System.out.println(\"Duck flies\"); }",
      "void swim() { System.out.println(\"Duck swims\"); }"
    ],
    correctAnswer: "A",
    explanation: "class B { void print() { System.out.println(\"From B\"); } }",
    source: "Page 9",
    topic: "Inheritance"
  },
  {
    id: 529,
    question: "According to the code example in the slide, why is class C extends A, B not allowed?",
    options: [
      "Which print() should C inherit?",
      "It supports multiple interfaces.",
      "Constructors are not inherited.",
      "It causes field shadowing."
    ],
    correctAnswer: "A",
    explanation: "// Not allowed in Java class C extends A, B { // Which print() should C inherit? }",
    source: "Page 9",
    topic: "Inheritance"
  },
  {
    id: 530,
    question: "Why does Java disallow multiple class inheritance?",
    options: [
      "To avoid the diamond problem and keep the class hierarchy simple and predictable.",
      "To allow method overriding.",
      "To support constructor chaining.",
      "To enable polymorphic arrays."
    ],
    correctAnswer: "A",
    explanation: "Java disallows this to avoid the diamond problem and keep the class hierarchy simple and predictable.",
    source: "Page 9",
    topic: "Inheritance"
  },
  {
    id: 531,
    question: "Does Java support multiple inheritance of behavior?",
    options: [
      "Yes, using interfaces.",
      "No, only with classes.",
      "Yes, but only one interface.",
      "No, to avoid ambiguity."
    ],
    correctAnswer: "A",
    explanation: "Java supports multiple inheritance of behavior using interfaces. Java allows a class to implement multiple interfaces.",
    source: "Page 10",
    topic: "Inheritance"
  },
  {
    id: 532,
    question: "What do interfaces contain that avoids conflict?",
    options: [
      "Only method declarations (no conflict of implementation).",
      "Full method implementations.",
      "Final variables only.",
      "Constructors."
    ],
    correctAnswer: "A",
    explanation: "Interfaces contain only method declarations (no conflict of implementation).",
    source: "Page 10",
    topic: "Inheritance"
  },
  {
    id: 533,
    question: "How is ambiguity avoided in multiple interface inheritance?",
    options: [
      "The class must provide its own implementation, so ambiguity is avoided.",
      "By using the extends keyword.",
      "By declaring fields as private.",
      "By using final methods."
    ],
    correctAnswer: "A",
    explanation: "The class must provide its own implementation, so ambiguity is avoided.",
    source: "Page 10",
    topic: "Inheritance"
  },
  {
    id: 534,
    question: "According to the code example in the slide, what does interface Flyable declare?",
    options: [
      "void fly();",
      "void swim();",
      "void speak();",
      "void bark();"
    ],
    correctAnswer: "A",
    explanation: "interface Flyable { void fly(); }",
    source: "Page 11",
    topic: "Inheritance"
  },
  {
    id: 535,
    question: "According to the code example in the slide, what does interface Swimmable declare?",
    options: [
      "void swim();",
      "void fly();",
      "void speak();",
      "void bark();"
    ],
    correctAnswer: "A",
    explanation: "interface Swimmable { void swim(); }",
    source: "Page 11",
    topic: "Inheritance"
  },
  {
    id: 536,
    question: "According to the code example in the slide, what does class Duck implement and provide?",
    options: [
      "Implements Flyable, Swimmable with public void fly() { System.out.println(\"Duck flies\"); } and public void swim() { System.out.println(\"Duck swims\"); }",
      "Extends Animal with void speak() { System.out.println(\"Woof!\"); }",
      "Implements Flyable only with void fly() { System.out.println(\"Duck swims\"); }",
      "Extends Person with Student(String name) { super(name); }"
    ],
    correctAnswer: "A",
    explanation: "class Duck implements Flyable, Swimmable { public void fly() { System.out.println(\"Duck flies\"); } public void swim() { System.out.println(\"Duck swims\"); } }",
    source: "Page 11",
    topic: "Inheritance"
  },
  {
    id: 537,
    question: "Why is multiple interface inheritance safe and flexible in Java?",
    options: [
      "This is a safe and flexible way to achieve multiple inheritance of behavior in Java.",
      "It causes the diamond problem.",
      "It allows class extension.",
      "It inherits constructors."
    ],
    correctAnswer: "A",
    explanation: "This is a safe and flexible way to achieve multiple inheritance of behavior in Java.",
    source: "Page 11",
    topic: "Inheritance"
  },
  {
    id: 538,
    question: "According to the summary table in the slide, is multiple inheritance of classes supported in Java and how?",
    options: [
      "No, Not allowed (extends only one class).",
      "Yes, Using interface.",
      "Yes, Not allowed (extends only one class).",
      "No, Using interface."
    ],
    correctAnswer: "A",
    explanation: "Multiple inheritance of classes No Not allowed (extends only one class)",
    source: "Page 12",
    topic: "Inheritance"
  },
  {
    id: 539,
    question: "According to the summary table in the slide, is multiple inheritance of behavior supported in Java and how?",
    options: [
      "Yes, Using interface.",
      "No, Not allowed (extends only one class).",
      "No, Using interface.",
      "Yes, Not allowed (extends only one class)."
    ],
    correctAnswer: "A",
    explanation: "Multiple inheritance of behavior Yes Using interface",
    source: "Page 12",
    topic: "Inheritance"
  },
  {
    id: 540,
    question: "What is the topic of Slide 13?",
    options: [
      "Constructors and Inheritance in Java.",
      "Method Overriding in Java.",
      "What is Inheritance?",
      "The final Keyword."
    ],
    correctAnswer: "A",
    explanation: "Constructors and Inheritance in Java",
    source: "Page 13",
    topic: "Inheritance"
  },
  {
    id: 541,
    question: "Are constructors inherited by subclasses in Java?",
    options: [
      "No, constructors are not inherited by subclasses.",
      "Yes, constructors are automatically inherited.",
      "Yes, but only no-arg constructors.",
      "No, but they can be overridden."
    ],
    correctAnswer: "A",
    explanation: "In Java, constructors are not inherited by subclasses.",
    source: "Page 14",
    topic: "Inheritance"
  },
  {
    id: 542,
    question: "What must a subclass do regarding the superclass constructor?",
    options: [
      "A subclass must call a constructor of its superclass.",
      "A subclass must override the superclass constructor.",
      "A subclass can ignore the superclass constructor.",
      "A subclass inherits the constructor automatically."
    ],
    correctAnswer: "A",
    explanation: "Asubclass must call a constructor of its superclass.",
    source: "Page 14",
    topic: "Inheritance"
  },
  {
    id: 543,
    question: "How is the call to the superclass constructor made?",
    options: [
      "Using the keyword super(...).",
      "Using the keyword this(...).",
      "@Override.",
      "Using final."
    ],
    correctAnswer: "A",
    explanation: "The call is made using the keyword super(...).",
    source: "Page 14",
    topic: "Inheritance"
  },
  {
    id: 544,
    question: "What happens if you don't call super(...) ?",
    options: [
      "If you don't call super(...), Java attempts to insert a no-argument super() automatically.",
      "It always causes a compile error.",
      "It calls this(...) instead.",
      "It overrides the constructor."
    ],
    correctAnswer: "A",
    explanation: "If you don't call super(...), Java attempts to insert a no-argument super() automatically.",
    source: "Page 14",
    topic: "Inheritance"
  },
  {
    id: 545,
    question: "When does the automatic insertion of no-argument super() work?",
    options: [
      "This only works if the superclass has a no-arg constructor.",
      "It works only if the subclass has parameters.",
      "It works for final classes.",
      "It works for interfaces."
    ],
    correctAnswer: "A",
    explanation: "This only works if the superclass has a no-arg constructor.",
    source: "Page 14",
    topic: "Inheritance"
  },
  {
    id: 546,
    question: "Where must super(...) be placed in a subclass constructor?",
    options: [
      "super(...) must be the first statement in a subclass constructor.",
      "super(...) can be anywhere in the constructor.",
      "super(...) after this(...).",
      "super(...) is optional always."
    ],
    correctAnswer: "A",
    explanation: "super(...) must be the first statement in a subclass constructor.",
    source: "Page 15",
    topic: "Inheritance"
  },
  {
    id: 547,
    question: "When must you call super(...) explicitly?",
    options: [
      "You must call super(...) explicitly if the superclass does not have a no-argument constructor.",
      "Only if the subclass has no parameters.",
      "If the method is final.",
      "For static methods."
    ],
    correctAnswer: "A",
    explanation: "You must call super(...) explicitly if the superclass does not have a no-argument constructor.",
    source: "Page 15",
    topic: "Inheritance"
  },
  {
    id: 548,
    question: "According to the code example in the slide, what is the Person constructor?",
    options: [
      "Person(String name) { System.out.println(\"Hello, \" + name); }",
      "Person() { System.out.println(\"Animal created\"); }",
      "Person(String name) {}",
      "Person(String name, int age) {}"
    ],
    correctAnswer: "A",
    explanation: "class Person { Person(String name) { System.out.println(\"Hello, \" + name); } }",
    source: "Page 15",
    topic: "Inheritance"
  },
  {
    id: 549,
    question: "According to the code example in the slide, how does Student call super?",
    options: [
      "Student(String name) { super(name); // Required, no default constructor in Person }",
      "Student() { System.out.println(\"Dog created\"); }",
      "Student(String name) { this.name = name; }",
      "Student() { super(); }"
    ],
    correctAnswer: "A",
    explanation: "class Student extends Person { Student(String name) { super(name); // Required, no default constructor in Person } }",
    source: "Page 15",
    topic: "Inheritance"
  },
  {
    id: 550,
    question: "What does Java do if the superclass has a no-arg constructor?",
    options: [
      "If the superclass has a no-arg constructor, Java inserts super() by default.",
      "It always causes a compile-time error.",
      "It calls this(...) instead.",
      "It overrides the method."
    ],
    correctAnswer: "A",
    explanation: "If the superclass has a no-arg constructor, Java inserts super() by default.",
    source: "Page 16",
    topic: "Inheritance"
  },
  {
    id: 551,
    question: "What happens if the superclass has no no-arg constructor and you omit super(...) ?",
    options: [
      "If not, and you omit super(...), a compile-time error will occur.",
      "Java ignores it.",
      "It automatically creates a no-arg constructor.",
      "It hides the constructor."
    ],
    correctAnswer: "A",
    explanation: "If not, and you omit super(...), a compile-time error will occur.",
    source: "Page 16",
    topic: "Inheritance"
  },
  {
    id: 552,
    question: "According to the code example in the slide, what is Person's constructor?",
    options: [
      "Person(String name) {}",
      "Person() { System.out.println(\"Hello, \" + name); }",
      "Person(String name) { System.out.println(\"Hello, \" + name); }",
      "Person() {}"
    ],
    correctAnswer: "A",
    explanation: "class Person { Person(String name) {} }",
    source: "Page 16",
    topic: "Inheritance"
  },
  {
    id: 553,
    question: "According to the code example in the slide, why does Student() cause an error?",
    options: [
      "// Compile-time error: constructor Person() is undefined",
      "It overrides correctly.",
      "super() is inserted automatically.",
      "It calls this()."
    ],
    correctAnswer: "A",
    explanation: "class Student extends Person { Student() { // Compile-time error: constructor Person() is undefined } }",
    source: "Page 16",
    topic: "Inheritance"
  },
  {
    id: 554,
    question: "What happens if the superclass defines a no-argument constructor?",
    options: [
      "The subclass is not required to call super() explicitly. Java will automatically insert super() at the beginning of the subclass constructor.",
      "It must call super(...) explicitly always.",
      "It causes a compile error.",
      "Constructors are inherited."
    ],
    correctAnswer: "A",
    explanation: "If the superclass defines a no-argument constructor, the subclass is not required to call super() explicitly. Java will automatically insert super() at the beginning of the subclass constructor.",
    source: "Page 17",
    topic: "Inheritance"
  },
  {
    id: 555,
    question: "According to the code example in the slide, what is Animal's constructor?",
    options: [
      "Animal() { System.out.println(\"Animal created\"); }",
      "Animal(String name) { System.out.println(\"Animal: \" + name); }",
      "Animal(String name) { this.name = name; }",
      "Animal() { System.out.println(\"Dog created\"); }"
    ],
    correctAnswer: "A",
    explanation: "class Animal { Animal() { System.out.println(\"Animal created\"); } }",
    source: "Page 17",
    topic: "Inheritance"
  },
  {
    id: 556,
    question: "According to the code example in the slide, what is Dog's constructor?",
    options: [
      "Dog() { System.out.println(\"Dog created\"); }",
      "Dog(String name) { super(name); }",
      "Dog() { System.out.println(\"Dog created\"); }",
      "Dog(String name, int age) { super(name); }"
    ],
    correctAnswer: "A",
    explanation: "class Dog extends Animal { Dog() { System.out.println(\"Dog created\"); } }",
    source: "Page 17",
    topic: "Inheritance"
  },
  {
    id: 557,
    question: "According to the table in the slide, what are the columns for super vs this?",
    options: [
      "Keyword, Description",
      "Modifier, Inherited?, Accessible from subclass?",
      "Keyword, Meaning, Used for",
      "Feature, Overriding, Hiding (Static)"
    ],
    correctAnswer: "A",
    explanation: "Keyword Description",
    source: "Page 18",
    topic: "Inheritance"
  },
  {
    id: 558,
    question: "What does super(...) do?",
    options: [
      "Calls a constructor from the superclass.",
      "Calls another constructor in the same class.",
      "Calls a method from the superclass.",
      "Calls a static method."
    ],
    correctAnswer: "A",
    explanation: "super(...) Calls a constructor from the superclass",
    source: "Page 18",
    topic: "Inheritance"
  },
  {
    id: 559,
    question: "What does this(...) do?",
    options: [
      "Calls another constructor in the same class.",
      "Calls a constructor from the superclass.",
      "Accesses a shadowed field.",
      "Overrides a method."
    ],
    correctAnswer: "A",
    explanation: "this(...) Calls another constructor in the same class",
    source: "Page 18",
    topic: "Inheritance"
  },
  {
    id: 560,
    question: "How many constructor calls are allowed and where?",
    options: [
      "Only one constructor call is allowed in a constructor, and it must be the first statement.",
      "Multiple calls are allowed anywhere.",
      "Only super(...) is allowed.",
      "They can be used together."
    ],
    correctAnswer: "A",
    explanation: "Only one constructor call is allowed in a constructor, and it must be the first statement.",
    source: "Page 18",
    topic: "Inheritance"
  },
  {
    id: 561,
    question: "Can you use super(...) and this(...) together?",
    options: [
      "You cannot use super(...) and this(...) together in the same constructor.",
      "Yes, but super first.",
      "Yes, but this first.",
      "Yes, anywhere."
    ],
    correctAnswer: "A",
    explanation: "You cannot use super(...) and this(...) together in the same constructor.",
    source: "Page 18",
    topic: "Inheritance"
  },
  {
    id: 562,
    question: "According to the code example in the slide, what is Animal's constructor?",
    options: [
      "Animal(String name) { System.out.println(\"Animal: \" + name); }",
      "Animal() { System.out.println(\"Animal created\"); }",
      "Animal(String name) { this.name = name; }",
      "Animal() { System.out.println(\"Dog created\"); }"
    ],
    correctAnswer: "A",
    explanation: "class Animal { Animal(String name) { System.out.println(\"Animal: \" + name); } }",
    source: "Page 19",
    topic: "Inheritance"
  },
  {
    id: 563,
    question: "According to the code example in the slide, what is Dog's constructor?",
    options: [
      "Dog() { super(\"Dog\"); System.out.println(\"Dog created\"); }",
      "Dog(String name) { super(name); }",
      "Dog() { System.out.println(\"Dog created\"); }",
      "Dog(String name, int age) { super(name); }"
    ],
    correctAnswer: "A",
    explanation: "class Dog extends Animal { Dog() { super(\"Dog\"); System.out.println(\"Dog created\"); } }",
    source: "Page 19",
    topic: "Inheritance"
  },
  {
    id: 564,
    question: "According to the code example in the slide, what is the output of creating a Dog object?",
    options: [
      "Animal: Dog Dog created",
      "Dog created Animal: Dog",
      "Animal created Dog created",
      "Hello, Dog"
    ],
    correctAnswer: "A",
    explanation: "Output: makefile Animal: Dog Dog created",
    source: "Page 19",
    topic: "Inheritance"
  },
  {
    id: 565,
    question: "Can constructors be overridden?",
    options: [
      "Constructors are not inherited, so they cannot be overridden.",
      "Yes, using @Override.",
      "Yes, if parameters match.",
      "Constructors are hidden instead."
    ],
    correctAnswer: "A",
    explanation: "Constructors are not inherited, so they cannot be overridden.",
    source: "Page 20",
    topic: "Inheritance"
  },
  {
    id: 566,
    question: "Even if parameter lists are the same, what about subclass constructors?",
    options: [
      "Even if parameter lists are the same, subclass constructors are separate.",
      "They automatically override.",
      "They must use final.",
      "They are static."
    ],
    correctAnswer: "A",
    explanation: "Even if parameter lists are the same, subclass constructors are separate.",
    source: "Page 20",
    topic: "Inheritance"
  },
  {
    id: 567,
    question: "Is @Override allowed for constructors?",
    options: [
      "No @Override allowed.",
      "Yes, to catch errors.",
      "Yes, for polymorphism.",
      "Only for methods."
    ],
    correctAnswer: "A",
    explanation: "No @Override allowed.",
    source: "Page 20",
    topic: "Inheritance"
  },
  {
    id: 568,
    question: "According to the code example in the slide, what is Person's constructor?",
    options: [
      "Person(String name) { System.out.println(\"Person: \" + name); }",
      "Person() { System.out.println(\"Animal created\"); }",
      "Person(String name) {}",
      "Person(String name, int age) {}"
    ],
    correctAnswer: "A",
    explanation: "class Person { Person(String name) { System.out.println(\"Person: \" + name); } }",
    source: "Page 20",
    topic: "Inheritance"
  },
  {
    id: 569,
    question: "According to the code example in the slide, what is Student's constructor?",
    options: [
      "Student(String name) { super(name); System.out.println(\"Student: \" + name); } // Not an override",
      "Student() { super(\"Dog\"); System.out.println(\"Dog created\"); }",
      "Student(String name, int age) { super(name); }",
      "Student() { // Compile-time error }"
    ],
    correctAnswer: "A",
    explanation: "class Student extends Person { Student(String name) { // Not an override super(name); // Call superclass constructor System.out.println(\"Student: \" + name); } }",
    source: "Page 20",
    topic: "Inheritance"
  },
  {
    id: 570,
    question: "What happens if you use @Override on a constructor?",
    options: [
      "Using @Override here would cause a compile-time error.",
      "It enables overriding.",
      "It is required.",
      "It hides the constructor."
    ],
    correctAnswer: "A",
    explanation: "Using @Override here would cause a compile-time error.",
    source: "Page 20",
    topic: "Inheritance"
  },
  {
    id: 571,
    question: "Can subclass constructors have different parameters?",
    options: [
      "Subclass constructors can use different parameters.",
      "They must match exactly.",
      "Only if no-arg.",
      "Constructors cannot differ."
    ],
    correctAnswer: "A",
    explanation: "Subclass constructors can use different parameters.",
    source: "Page 21",
    topic: "Inheritance"
  },
  {
    id: 572,
    question: "What must subclass constructors do even with different parameters?",
    options: [
      "Still, they must explicitly call one superclass constructor.",
      "They can skip super.",
      "They override automatically.",
      "They hide fields."
    ],
    correctAnswer: "A",
    explanation: "Still, they must explicitly call one superclass constructor.",
    source: "Page 21",
    topic: "Inheritance"
  },
  {
    id: 573,
    question: "According to the code example in the slide, what is Person's constructor?",
    options: [
      "Person(String name) { System.out.println(\"Person: \" + name); }",
      "Person(String name, int age) {}",
      "Person() { System.out.println(\"Person: \" + name); }",
      "Person(String name) {}"
    ],
    correctAnswer: "A",
    explanation: "class Person { Person(String name) { System.out.println(\"Person: \" + name); } }",
    source: "Page 21",
    topic: "Inheritance"
  },
  {
    id: 574,
    question: "According to the code example in the slide, what is Student's constructor?",
    options: [
      "Student(String name, int age) { super(name); System.out.println(\"Age: \" + age); }",
      "Student(String name) { super(name); System.out.println(\"Student: \" + name); }",
      "Student() { super(\"Dog\"); }",
      "Student() {}"
    ],
    correctAnswer: "A",
    explanation: "class Student extends Person { Student(String name, int age) { super(name); // Call Person(String) System.out.println(\"Age: \" + age); } }",
    source: "Page 21",
    topic: "Inheritance"
  },
  {
    id: 575,
    question: "What is the rule even with different parameters?",
    options: [
      "Even with different parameters, super(...) is required unless the superclass has a no-arg constructor.",
      "super is optional.",
      "It causes shadowing.",
      "It allows overriding."
    ],
    correctAnswer: "A",
    explanation: "Even with different parameters, super(...) is required unless the superclass has a no-arg constructor.",
    source: "Page 21",
    topic: "Inheritance"
  },
  {
    id: 576,
    question: "Can constructors be overridden?",
    options: [
      "Constructors cannot be overridden — do not use @Override.",
      "Yes, with @Override.",
      "Only static ones.",
      "With final."
    ],
    correctAnswer: "A",
    explanation: "Constructors cannot be overridden —do not use @Override.",
    source: "Page 22",
    topic: "Inheritance"
  },
  {
    id: 577,
    question: "What if superclass has no default constructor?",
    options: [
      "If superclass has no default constructor, super(...) is required.",
      "Java always inserts it.",
      "It is optional.",
      "Use this(...)."
    ],
    correctAnswer: "A",
    explanation: "If superclass has no default constructor, super(...) is required.",
    source: "Page 22",
    topic: "Inheritance"
  },
  {
    id: 578,
    question: "Where must super(...) be?",
    options: [
      "super(...) must be the first line.",
      "Anywhere.",
      "After this(...).",
      "At the end."
    ],
    correctAnswer: "A",
    explanation: "super(...) must be the first line.",
    source: "Page 22",
    topic: "Inheritance"
  },
  {
    id: 579,
    question: "Can you mix super(...) and this(...) ?",
    options: [
      "Do not mix super(...) and this(...).",
      "Yes, in any order.",
      "Only in methods.",
      "For fields only."
    ],
    correctAnswer: "A",
    explanation: "Do not mix super(...) and this(...).",
    source: "Page 22",
    topic: "Inheritance"
  },
  {
    id: 580,
    question: "According to the code example in the slide, what is Person's constructor?",
    options: [
      "Person(String name) {}",
      "Person() {}",
      "Person(String name) { System.out.println(\"Hello, \" + name); }",
      "Person(String name, int age) {}"
    ],
    correctAnswer: "A",
    explanation: "class Person { Person(String name) {} }",
    source: "Page 22",
    topic: "Inheritance"
  },
  {
    id: 581,
    question: "According to the code example in the slide, why is there an error in Student() ?",
    options: [
      "// Error: no matching Person() // Java inserts super(), but Person has no no-arg constructor",
      "It overrides correctly.",
      "super is called.",
      "this is used."
    ],
    correctAnswer: "A",
    explanation: "class Student extends Person { Student() { // Error: no matching Person() // Java inserts super(), but Person has no no-arg constructor } }",
    source: "Page 22",
    topic: "Inheritance"
  },
  {
    id: 582,
    question: "How to avoid the mistake in the example?",
    options: [
      "Avoid this mistake by explicitly calling super(name) if needed.",
      "Use @Override.",
      "Make it static.",
      "Use final."
    ],
    correctAnswer: "A",
    explanation: "Avoid this mistake by explicitly calling super(name) if needed.",
    source: "Page 22",
    topic: "Inheritance"
  },
  {
    id: 583,
    question: "When a subclass overrides a method, how can it call the original?",
    options: [
      "It can still call the original method using super.methodName().",
      "Using this.methodName().",
      "Using @Override.",
      "It cannot call the original."
    ],
    correctAnswer: "A",
    explanation: "When a subclass overrides a method from its superclass, it can still call the original method using super.methodName().",
    source: "Page 23",
    topic: "Inheritance"
  },
  {
    id: 584,
    question: "According to the code example in the slide, what does Animal's speak method do?",
    options: [
      "void speak() { System.out.println(\"Animal sound\"); }",
      "void speak() { System.out.println(\"Dog barks\"); }",
      "void log(String msg) { System.out.println(\"LOG: \" + msg); }",
      "void speak() { super.speak(); }"
    ],
    correctAnswer: "A",
    explanation: "class Animal { void speak() { System.out.println(\"Animal sound\"); } }",
    source: "Page 23",
    topic: "Inheritance"
  },
  {
    id: 585,
    question: "According to the code example in the slide, how does Dog's speak use super?",
    options: [
      "void speak() { super.speak(); System.out.println(\"Dog barks\"); }",
      "void speak() { System.out.println(\"Animal sound\"); }",
      "void log(String msg) { super.log(msg); }",
      "@Override void speak() { System.out.println(\"Woof!\"); }"
    ],
    correctAnswer: "A",
    explanation: "class Dog extends Animal { void speak() { super.speak(); // call the superclass version System.out.println(\"Dog barks\"); } }",
    source: "Page 23",
    topic: "Inheritance"
  },
  {
    id: 586,
    question: "According to the code example in the slide, what is the output of Dog's speak?",
    options: [
      "Animal sound Dog barks",
      "Dog barks Animal sound",
      "Woof!",
      "LOG: msg"
    ],
    correctAnswer: "A",
    explanation: "Output: nginx Animal sound Dog barks",
    source: "Page 23",
    topic: "Inheritance"
  },
  {
    id: 587,
    question: "One reason to use super.method() ?",
    options: [
      "To reuse logic from the superclass instead of duplicating it.",
      "To hide the method.",
      "To make it final.",
      "To cause ambiguity."
    ],
    correctAnswer: "A",
    explanation: "To reuse logic from the superclass instead of duplicating it.",
    source: "Page 24",
    topic: "Inheritance"
  },
  {
    id: 588,
    question: "Another reason to use super.method() ?",
    options: [
      "To extend rather than completely replace behavior.",
      "To reduce visibility.",
      "To override constructors.",
      "To enable field shadowing."
    ],
    correctAnswer: "A",
    explanation: "To extend rather than completely replace behavior.",
    source: "Page 24",
    topic: "Inheritance"
  },
  {
    id: 589,
    question: "Where is super.method() common?",
    options: [
      "Common in UI code, logging, validation, etc.",
      "Only in constructors.",
      "In static methods.",
      "In interfaces."
    ],
    correctAnswer: "A",
    explanation: "Common in UI code, logging, validation, etc.",
    source: "Page 24",
    topic: "Inheritance"
  },
  {
    id: 590,
    question: "According to the code example in the slide, what is Logger's log method?",
    options: [
      "void log(String msg) { System.out.println(\"LOG: \" + msg); }",
      "void log(String msg) { System.out.println(\"Write to file\"); }",
      "void speak() { System.out.println(\"Animal sound\"); }",
      "void log(String msg) { super.log(msg); }"
    ],
    correctAnswer: "A",
    explanation: "class Logger { void log(String msg) { System.out.println(\"LOG: \" + msg); } }",
    source: "Page 24",
    topic: "Inheritance"
  },
  {
    id: 591,
    question: "According to the code example in the slide, how does FileLogger's log use super?",
    options: [
      "void log(String msg) { super.log(msg); System.out.println(\"Write to file\"); }",
      "void log(String msg) { System.out.println(\"LOG: \" + msg); }",
      "void speak() { super.speak(); }",
      "@Override void log(String msg) { }"
    ],
    correctAnswer: "A",
    explanation: "class FileLogger extends Logger { void log(String msg) { super.log(msg); // Log to console System.out.println(\"Write to file\"); // Add new behavior } }",
    source: "Page 24",
    topic: "Inheritance"
  },
  {
    id: 592,
    question: "What principle should be followed?",
    options: [
      "Avoid rewriting everything — call super.method() first, then add what's new.",
      "Always confuse.",
      "Use this instead.",
      "Make it private."
    ],
    correctAnswer: "A",
    explanation: "Avoid rewriting everything —call super.method() first, then add what's new.",
    source: "Page 24",
    topic: "Inheritance"
  },
  {
    id: 593,
    question: "According to the table in the slide, what are the columns for super vs this?",
    options: [
      "Keyword, Meaning, Used for",
      "Modifier, Inherited?, Accessible from subclass?",
      "Feature, Overriding, Hiding (Static)",
      "Modifier in Superclass, Allowed in Subclass, Notes"
    ],
    correctAnswer: "A",
    explanation: "Keyword Meaning Used for",
    source: "Page 25",
    topic: "Inheritance"
  },
  {
    id: 594,
    question: "What is 'this'?",
    options: [
      "Current class reference, Call current method or constructor",
      "Immediate superclass reference, Call superclass method or constructor",
      "Shadowed field access",
      "Static reference"
    ],
    correctAnswer: "A",
    explanation: "this Current class reference Call current method or constructor",
    source: "Page 25",
    topic: "Inheritance"
  },
  {
    id: 595,
    question: "What is 'super'?",
    options: [
      "Immediate superclass reference, Call superclass method or constructor",
      "Current class reference, Call current method or constructor",
      "For fields only",
      "For constructors only"
    ],
    correctAnswer: "A",
    explanation: "super Immediate superclass reference Call superclass method or constructor",
    source: "Page 25",
    topic: "Inheritance"
  },
  {
    id: 596,
    question: "In an overridden method, what does super.method() access?",
    options: [
      "super.method() accesses the original version, while this.method() calls the current (possibly overridden) one.",
      "Both access the current version.",
      "super calls current, this calls original.",
      "They are the same."
    ],
    correctAnswer: "A",
    explanation: "In an overridden method, super.method() accesses the original version, while this.method() calls the current (possibly overridden) one.",
    source: "Page 25",
    topic: "Inheritance"
  },
  {
    id: 597,
    question: "According to the example in the slide, what does super.toString() do?",
    options: [
      "Call parent's toString",
      "Call current class's version",
      "Cause error",
      "Hide the method"
    ],
    correctAnswer: "A",
    explanation: "super.toString(); // Call parent's toString",
    source: "Page 25",
    topic: "Inheritance"
  },
  {
    id: 598,
    question: "According to the example in the slide, what does this.toString() do?",
    options: [
      "Call current class's version (if overridden)",
      "Call parent's toString",
      "Access shadowed field",
      "Call constructor"
    ],
    correctAnswer: "A",
    explanation: "this.toString(); // Call current class's version (if overridden)",
    source: "Page 25",
    topic: "Inheritance"
  },
  {
    id: 599,
    question: "When should you use super?",
    options: [
      "Use super when you want to intentionally bypass the overridden method in the subclass.",
      "To call current method.",
      "For static methods.",
      "To shadow fields."
    ],
    correctAnswer: "A",
    explanation: "Use super when you want to intentionally bypass the overridden method in the subclass.",
    source: "Page 25",
    topic: "Inheritance"
  },
  {
    id: 600,
    question: "What happens if a subclass declares a field with the same name?",
    options: [
      "The subclass field shadows the superclass field.",
      "It overrides the field.",
      "It hides the method.",
      "It causes compile error."
    ],
    correctAnswer: "A",
    explanation: "If a subclass declares a field with the same name as one in the superclass, the subclass field shadows the superclass field.",
    source: "Page 26",
    topic: "Inheritance"
  },
  {
    id: 601,
    question: "How to access the shadowed field?",
    options: [
      "To access the shadowed field, use super.fieldName.",
      "Use this.fieldName.",
      "Use final.",
      "Use private."
    ],
    correctAnswer: "A",
    explanation: "To access the shadowed field, use super.fieldName.",
    source: "Page 26",
    topic: "Inheritance"
  },
  {
    id: 602,
    question: "According to the code example in the slide, what is Animal's name field?",
    options: [
      "String name = \"Generic Animal\";",
      "String name = \"Dog\";",
      "int x = 10;",
      "int x = 20;"
    ],
    correctAnswer: "A",
    explanation: "class Animal { String name = \"Generic Animal\"; }",
    source: "Page 26",
    topic: "Inheritance"
  },
  {
    id: 603,
    question: "According to the code example in the slide, what is Dog's name field and printNames method?",
    options: [
      "String name = \"Dog\"; void printNames() { System.out.println(name); System.out.println(super.name); }",
      "String name = \"Generic Animal\"; void printNames() { System.out.println(super.name); }",
      "int x = 20; void print() { System.out.println(x); }",
      "int x = 10;"
    ],
    correctAnswer: "A",
    explanation: "class Dog extends Animal { String name = \"Dog\"; void printNames() { System.out.println(name); // Accesses Dog's name System.out.println(super.name); // Accesses Animal's name } }",
    source: "Page 26",
    topic: "Inheritance"
  },
  {
    id: 604,
    question: "According to the code example in the slide, what is the output of printNames() ?",
    options: [
      "Dog Generic Animal",
      "Generic Animal Dog",
      "10 20",
      "20 10"
    ],
    correctAnswer: "A",
    explanation: "Output: Dog Generic Animal",
    source: "Page 26",
    topic: "Inheritance"
  },
  {
    id: 605,
    question: "What does the subclass name do to the superclass name?",
    options: [
      "The subclass name hides the superclass name. Using super.name allows access to the hidden field in the superclass.",
      "It overrides it.",
      "It makes it final.",
      "It causes ambiguity."
    ],
    correctAnswer: "A",
    explanation: "The subclass name hides the superclass name. Using super.name allows access to the hidden field in the superclass.",
    source: "Page 26",
    topic: "Inheritance"
  },
  {
    id: 606,
    question: "Why can field shadowing be confusing?",
    options: [
      "It becomes harder to track which variable is used.",
      "It enables polymorphism.",
      "It allows overriding.",
      "It is required for inheritance."
    ],
    correctAnswer: "A",
    explanation: "When subclass fields have the same name as superclass fields: It becomes harder to track which variable is used.",
    source: "Page 27",
    topic: "Inheritance"
  },
  {
    id: 607,
    question: "In shadowing, what do this.field and super.field refer to?",
    options: [
      "this.field and super.field refer to different values.",
      "They refer to the same value.",
      "Only this is used.",
      "super is not allowed."
    ],
    correctAnswer: "A",
    explanation: "this.field and super.field refer to different values.",
    source: "Page 27",
    topic: "Inheritance"
  },
  {
    id: 608,
    question: "How may method behavior depend in shadowing?",
    options: [
      "Method behavior may depend on reference type, but field access depends on declared type.",
      "Always on runtime type.",
      "Only on subclass.",
      "On interface."
    ],
    correctAnswer: "A",
    explanation: "Method behavior may depend on reference type, but field access depends on declared type.",
    source: "Page 27",
    topic: "Inheritance"
  },
  {
    id: 609,
    question: "According to the code example in the slide, what is A's x?",
    options: [
      "int x = 10;",
      "int x = 20;",
      "String name = \"Generic Animal\";",
      "String name = \"Dog\";"
    ],
    correctAnswer: "A",
    explanation: "class A{ int x = 10; }",
    source: "Page 27",
    topic: "Inheritance"
  },
  {
    id: 610,
    question: "According to the code example in the slide, what is B's x?",
    options: [
      "int x = 20;",
      "int x = 10;",
      "String name = \"Dog\";",
      "String name = \"Generic Animal\";"
    ],
    correctAnswer: "A",
    explanation: "class B extends A { int x = 20; }",
    source: "Page 27",
    topic: "Inheritance"
  },
  {
    id: 611,
    question: "According to the code example in the slide, what does A obj = new B(); System.out.println(obj.x); print?",
    options: [
      "Prints 10 - uses A's field, not B's",
      "Prints 20",
      "Prints Dog",
      "Prints Generic Animal"
    ],
    correctAnswer: "A",
    explanation: "Aobj = new B(); System.out.println(obj.x); // Prints 10 - uses A's field, not B's",
    source: "Page 27",
    topic: "Inheritance"
  },
  {
    id: 612,
    question: "How is the field x resolved in the example?",
    options: [
      "Even though obj refers to a B, the field x is resolved at compile-time using the declared type (A), not the runtime type.",
      "At runtime using B.",
      "Using super.",
      "Causes error."
    ],
    correctAnswer: "A",
    explanation: "Even though obj refers to a B, the field x is resolved at compile-time using the declared type (A), not the runtime type.",
    source: "Page 27",
    topic: "Inheritance"
  },
  {
    id: 613,
    question: "What should you avoid in field names?",
    options: [
      "Avoid reusing field names from superclass unless necessary.",
      "Always reuse for polymorphism.",
      "Make them final.",
      "Use private always."
    ],
    correctAnswer: "A",
    explanation: "Avoid reusing field names from superclass unless necessary.",
    source: "Page 28",
    topic: "Inheritance"
  },
  {
    id: 614,
    question: "What to prefer for polymorphic behavior?",
    options: [
      "Prefer method overriding when you want polymorphic behavior.",
      "Prefer field shadowing.",
      "Prefer static methods.",
      "Prefer constructors."
    ],
    correctAnswer: "A",
    explanation: "Prefer method overriding when you want polymorphic behavior.",
    source: "Page 28",
    topic: "Inheritance"
  },
  {
    id: 615,
    question: "When to use super.field?",
    options: [
      "Use super.field only when you need to explicitly access hidden state from the parent.",
      "Always for all fields.",
      "For methods only.",
      "To hide it."
    ],
    correctAnswer: "A",
    explanation: "Use super.field only when you need to explicitly access hidden state from the parent.",
    source: "Page 28",
    topic: "Inheritance"
  },
  {
    id: 616,
    question: "According to the example in the slide, what is the bad way?",
    options: [
      "class B extends A { int value; // shadows A.value }",
      "class B extends A { int bonus; // different field name, no confusion }",
      "class A { int x = 10; }",
      "class B { int x = 20; }"
    ],
    correctAnswer: "A",
    explanation: "Example - Instead of this: class B extends A { int value; // shadows A.value }",
    source: "Page 28",
    topic: "Inheritance"
  },
  {
    id: 617,
    question: "According to the example in the slide, what is the preferred way?",
    options: [
      "class B extends A { int bonus; // different field name, no confusion }",
      "class B extends A { int value; // shadows A.value }",
      "class A { int value; }",
      "Use super.value;"
    ],
    correctAnswer: "A",
    explanation: "Prefer this: class B extends A{ int bonus; // different field name, no confusion }",
    source: "Page 28",
    topic: "Inheritance"
  },
  {
    id: 618,
    question: "What does keeping field names distinct do?",
    options: [
      "Keeping field names distinct across the class hierarchy improves code clarity and maintainability.",
      "It causes shadowing.",
      "It reduces visibility.",
      "It allows multiple inheritance."
    ],
    correctAnswer: "A",
    explanation: "Keeping field names distinct across the class hierarchy improves code clarity and maintainability.",
    source: "Page 28",
    topic: "Inheritance"
  },
  {
    id: 619,
    question: "What is the topic of Slide 29?",
    options: [
      "Method Overriding in Java",
      "Constructors and Inheritance in Java",
      "What is Inheritance?",
      "Summary"
    ],
    correctAnswer: "A",
    explanation: "Method Overriding in Java",
    source: "Page 29",
    topic: "Inheritance"
  },
  {
    id: 620,
    question: "One reason to use overriding?",
    options: [
      "To customize behavior in a subclass.",
      "To inherit constructors.",
      "To shadow fields.",
      "To make static."
    ],
    correctAnswer: "A",
    explanation: "To customize behavior in a subclass.",
    source: "Page 30",
    topic: "Inheritance"
  },
  {
    id: 621,
    question: "Another reason?",
    options: [
      "To support runtime polymorphism.",
      "To hide methods.",
      "To call super always.",
      "To reduce access."
    ],
    correctAnswer: "A",
    explanation: "To support runtime polymorphism.",
    source: "Page 30",
    topic: "Inheritance"
  },
  {
    id: 622,
    question: "Another reason?",
    options: [
      "To keep a consistent interface while allowing different behavior.",
      "To change parameters.",
      "To make final.",
      "To cause errors."
    ],
    correctAnswer: "A",
    explanation: "To keep a consistent interface while allowing different behavior.",
    source: "Page 30",
    topic: "Inheritance"
  },
  {
    id: 623,
    question: "According to the code example in the slide, what does Animal a = new Dog(); a.speak(); do?",
    options: [
      "Outputs: Dog barks",
      "Outputs: Animal sound",
      "Causes compile error",
      "Calls bark()"
    ],
    correctAnswer: "A",
    explanation: "Animal a = new Dog(); a.speak(); // Outputs: Dog barks",
    source: "Page 30",
    topic: "Inheritance"
  },
  {
    id: 624,
    question: "What determines the method called?",
    options: [
      "The method called depends on the actual object (Dog), not the variable type (Animal).",
      "On variable type only.",
      "On compile time.",
      "On static type."
    ],
    correctAnswer: "A",
    explanation: "The method called depends on the actual object (Dog), not the variable type (Animal).",
    source: "Page 30",
    topic: "Inheritance"
  },
  {
    id: 625,
    question: "The method must exist in the superclass.",
    options: [
      "The method must exist in the superclass.",
      "It must be private.",
      "Parameters different.",
      "Return type different."
    ],
    correctAnswer: "A",
    explanation: "To override a method correctly, all these conditions must be met: The method must exist in the superclass.",
    source: "Page 31",
    topic: "Inheritance"
  },
  {
    id: 626,
    question: "What must the subclass method have?",
    options: [
      "The same method name.",
      "Different name.",
      "Static modifier.",
      "Final modifier."
    ],
    correctAnswer: "A",
    explanation: "The subclass method must have: The same method name.",
    source: "Page 31",
    topic: "Inheritance"
  },
  {
    id: 627,
    question: "Another requirement for subclass method?",
    options: [
      "The same parameter list.",
      "Different parameters.",
      "No parameters.",
      "Covariant parameters."
    ],
    correctAnswer: "A",
    explanation: "The same parameter list.",
    source: "Page 31",
    topic: "Inheritance"
  },
  {
    id: 628,
    question: "Return type requirement?",
    options: [
      "A return type that is the same or a subtype (covariant return).",
      "Always different.",
      "Primitive only.",
      "Void only."
    ],
    correctAnswer: "A",
    explanation: "A return type that is the same or a subtype (covariant return).",
    source: "Page 31",
    topic: "Inheritance"
  },
  {
    id: 629,
    question: "Access modifier rule?",
    options: [
      "Access modifier must be equal or more accessible.",
      "Less accessible.",
      "Private only.",
      "Default only."
    ],
    correctAnswer: "A",
    explanation: "Access modifier must be equal or more accessible.",
    source: "Page 31",
    topic: "Inheritance"
  },
  {
    id: 630,
    question: "What must the method not be in superclass?",
    options: [
      "The method must not be private, static, or final in the superclass.",
      "It must be private.",
      "It must be static.",
      "It must be final."
    ],
    correctAnswer: "A",
    explanation: "The method must not be private, static, or final in the superclass.",
    source: "Page 31",
    topic: "Inheritance"
  },
  {
    id: 631,
    question: "Where must it be?",
    options: [
      "Must be inside a subclass, not the same class.",
      "In the same class.",
      "In interface.",
      "In abstract class."
    ],
    correctAnswer: "A",
    explanation: "Must be inside a subclass, not the same class.",
    source: "Page 31",
    topic: "Inheritance"
  },
  {
    id: 632,
    question: "Recommendation for overriding?",
    options: [
      "Use @Override to catch mistakes at compile time.",
      "Avoid @Override.",
      "Use final.",
      "Use static."
    ],
    correctAnswer: "A",
    explanation: "Use @Override to catch mistakes at compile time.",
    source: "Page 31",
    topic: "Inheritance"
  },
  {
    id: 633,
    question: "For public in superclass, what is allowed in subclass?",
    options: [
      "public only",
      "protected, public",
      "(default), protected, public",
      "❌ Not inherited"
    ],
    correctAnswer: "A",
    explanation: "public public only Cannot reduce visibility",
    source: "Page 32",
    topic: "Inheritance"
  },
  {
    id: 634,
    question: "For protected in superclass, what is allowed?",
    options: [
      "protected, public",
      "public only",
      "(default), protected, public",
      "❌ Not inherited"
    ],
    correctAnswer: "A",
    explanation: "protected protected, public Subclass can widen visibility",
    source: "Page 32",
    topic: "Inheritance"
  },
  {
    id: 635,
    question: "For (default) in superclass, what is allowed?",
    options: [
      "(default), protected, public Only if in the same package",
      "public only",
      "protected, public",
      "❌ Not inherited"
    ],
    correctAnswer: "A",
    explanation: "(default) (package-private) (default), protected, public Only if in the same package",
    source: "Page 32",
    topic: "Inheritance"
  },
  {
    id: 636,
    question: "For private in superclass?",
    options: [
      "❌ Not inherited Cannot override a private method",
      "public only",
      "protected, public",
      "(default), protected, public"
    ],
    correctAnswer: "A",
    explanation: "private ❌ Not inherited Cannot override a private method",
    source: "Page 32",
    topic: "Inheritance"
  },
  {
    id: 637,
    question: "What happens if you make overridden method less accessible?",
    options: [
      "If you make the overridden method less accessible (e.g., from public to protected), the code will not compile.",
      "It compiles fine.",
      "It hides it.",
      "It overrides correctly."
    ],
    correctAnswer: "A",
    explanation: "If you make the overridden method less accessible (e.g., from public to protected), the code will not compile.",
    source: "Page 33",
    topic: "Inheritance"
  },
  {
    id: 638,
    question: "According to the code example in the slide, what is A's show?",
    options: [
      "public void show() {}",
      "protected void show() {}",
      "private void show() {}",
      "void show() {}"
    ],
    correctAnswer: "A",
    explanation: "class A{ public void show() {} }",
    source: "Page 33",
    topic: "Inheritance"
  },
  {
    id: 639,
    question: "According to the code example in the slide, why error in B?",
    options: [
      "@Override protected void show() {} // Error: cannot reduce visibility",
      "public void show() {}",
      "It compiles.",
      "Use final."
    ],
    correctAnswer: "A",
    explanation: "class B extends A { @Override protected void show() {} // Error: cannot reduce visibility }",
    source: "Page 33",
    topic: "Inheritance"
  },
  {
    id: 640,
    question: "For primitive types, return type must be?",
    options: [
      "Exactly the same.",
      "A subtype.",
      "Different.",
      "Void."
    ],
    correctAnswer: "A",
    explanation: "For primitive types, the return type must be exactly the same.",
    source: "Page 34",
    topic: "Inheritance"
  },
  {
    id: 641,
    question: "For object types, return type in subclass can be?",
    options: [
      "The return type in the subclass can be a subclass of the original (called covariant return).",
      "Any type.",
      "Primitive.",
      "Incompatible."
    ],
    correctAnswer: "A",
    explanation: "For object types, the return type in the subclass can be a subclass of the original (called covariant return).",
    source: "Page 34",
    topic: "Inheritance"
  },
  {
    id: 642,
    question: "According to the code example in the slide, what does A's get?",
    options: [
      "A get() { return this; }",
      "B get() { return this; }",
      "int getName() { return 1; }",
      "String getName() { return \"A\"; }"
    ],
    correctAnswer: "A",
    explanation: "class A { A get() { return this; } }",
    source: "Page 34",
    topic: "Inheritance"
  },
  {
    id: 643,
    question: "According to the code example in the slide, what does B's get?",
    options: [
      "@Override B get() { return this; } // OK: B is a subclass of A",
      "A get() { return this; }",
      "String getName() { return \"A\"; }",
      "int getName() { return 1; }"
    ],
    correctAnswer: "A",
    explanation: "class B extends A { @Override B get() { return this; } // OK: B is a subclass of A }",
    source: "Page 34",
    topic: "Inheritance"
  },
  {
    id: 644,
    question: "For static, can override?",
    options: [
      "❌ Method hiding, not overriding",
      "Yes",
      "❌ Not inherited at all",
      "❌ Compiler error if overridden"
    ],
    correctAnswer: "A",
    explanation: "static ❌ Method hiding, not overriding",
    source: "Page 35",
    topic: "Inheritance"
  },
  {
    id: 645,
    question: "For private?",
    options: [
      "❌ Not inherited at all",
      "❌ Method hiding, not overriding",
      "❌ Compiler error if overridden",
      "Yes"
    ],
    correctAnswer: "A",
    explanation: "private ❌ Not inherited at all",
    source: "Page 35",
    topic: "Inheritance"
  },
  {
    id: 646,
    question: "For final?",
    options: [
      "❌ Compiler error if overridden",
      "❌ Method hiding, not overriding",
      "❌ Not inherited at all",
      "Yes"
    ],
    correctAnswer: "A",
    explanation: "final ❌ Compiler error if overridden",
    source: "Page 35",
    topic: "Inheritance"
  },
  {
    id: 647,
    question: "What happens if you try to override static, private, or final?",
    options: [
      "Trying to override these will result in a compile-time error.",
      "It overrides successfully.",
      "It hides only.",
      "It shadows."
    ],
    correctAnswer: "A",
    explanation: "Trying to override these will result in a compile-time error.",
    source: "Page 35",
    topic: "Inheritance"
  },
  {
    id: 648,
    question: "To what do static methods belong?",
    options: [
      "Static methods belong to the class, not to instances.",
      "To instances.",
      "To interfaces.",
      "To constructors."
    ],
    correctAnswer: "A",
    explanation: "In Java, static methods belong to the class, not to instances.",
    source: "Page 36",
    topic: "Inheritance"
  },
  {
    id: 649,
    question: "If you declare a static method in subclass with same name?",
    options: [
      "It's called method hiding, not overriding.",
      "It's overriding.",
      "It's shadowing.",
      "It's polymorphism."
    ],
    correctAnswer: "A",
    explanation: "So when you declare a static method in a subclass with the same name as in the superclass, it's called method hiding, not overriding.",
    source: "Page 36",
    topic: "Inheritance"
  },
  {
    id: 650,
    question: "According to the code example in the slide, what does A's greet?",
    options: [
      "static void greet() { System.out.println(\"Hello from A\"); }",
      "static void greet() { System.out.println(\"Hello from B\"); }",
      "void greet() { System.out.println(\"A\"); }",
      "void greet() { System.out.println(\"B\"); }"
    ],
    correctAnswer: "A",
    explanation: "class A { static void greet() { System.out.println(\"Hello from A\"); } }",
    source: "Page 36",
    topic: "Inheritance"
  },
  {
    id: 651,
    question: "According to the code example in the slide, what is B's greet?",
    options: [
      "static void greet() { System.out.println(\"Hello from B\"); }",
      "static void greet() { System.out.println(\"Hello from A\"); }",
      "void greet() { System.out.println(\"B\"); }",
      "@Override void greet() { }"
    ],
    correctAnswer: "A",
    explanation: "class B extends A { static void greet() { System.out.println(\"Hello from B\"); } }",
    source: "Page 36",
    topic: "Inheritance"
  },
  {
    id: 652,
    question: "According to the code example in the slide, what does A obj = new B(); obj.greet(); output?",
    options: [
      "Hello from A",
      "Hello from B",
      "A",
      "B"
    ],
    correctAnswer: "A",
    explanation: "Aobj = new B(); obj.greet(); // Output: Hello from A",
    source: "Page 36",
    topic: "Inheritance"
  },
  {
    id: 653,
    question: "Why is the output Hello from A?",
    options: [
      "Although obj refers to a B, the method greet() is resolved at compile time using the reference type (A), because it's static.",
      "At runtime using B.",
      "Because of overriding.",
      "Due to polymorphism."
    ],
    correctAnswer: "A",
    explanation: "Although obj refers to a B, the method greet() is resolved at compile time using the reference type (A), because it's static.",
    source: "Page 36",
    topic: "Inheritance"
  },
  {
    id: 654,
    question: "To what does overriding apply?",
    options: [
      "Overriding applies to instance methods.",
      "To static methods.",
      "To fields.",
      "To constructors."
    ],
    correctAnswer: "A",
    explanation: "Overriding applies to instance methods.",
    source: "Page 37",
    topic: "Inheritance"
  },
  {
    id: 655,
    question: "To what does hiding apply?",
    options: [
      "Hiding applies to static methods with the same name in a subclass.",
      "To instance methods.",
      "To constructors.",
      "To interfaces."
    ],
    correctAnswer: "A",
    explanation: "Hiding applies to static methods with the same name in a subclass.",
    source: "Page 37",
    topic: "Inheritance"
  },
  {
    id: 656,
    question: "What is the key difference between overriding and hiding?",
    options: [
      "The key difference is when and how the method is resolved.",
      "No difference.",
      "Overriding at compile.",
      "Hiding at runtime."
    ],
    correctAnswer: "A",
    explanation: "The key difference is when and how the method is resolved.",
    source: "Page 37",
    topic: "Inheritance"
  },
  {
    id: 657,
    question: "According to the overriding example, what does the output of A obj = new B(); obj.greet();?",
    options: [
      "B",
      "A",
      "Hello from A",
      "Hello from B"
    ],
    correctAnswer: "A",
    explanation: "class A { void greet() { System.out.println(\"A\"); } } class B extends A { @Override void greet() { System.out.println(\"B\"); } } A obj = new B(); obj.greet(); // Output: B",
    source: "Page 37",
    topic: "Inheritance"
  },
  {
    id: 658,
    question: "How is the method resolved in overriding?",
    options: [
      "Method is resolved at runtime using the actual object type.",
      "At compile time.",
      "Using reference type.",
      "No polymorphism."
    ],
    correctAnswer: "A",
    explanation: "Method is resolved at runtime using the actual object type.",
    source: "Page 37",
    topic: "Inheritance"
  },
  {
    id: 659,
    question: "According to the hiding example, what is the output of A obj = new B(); obj.greet();?",
    options: [
      "A",
      "B",
      "Hello from A",
      "Hello from B"
    ],
    correctAnswer: "A",
    explanation: "class A { static void greet() { System.out.println(\"A\"); } } class B extends A { static void greet() { System.out.println(\"B\"); } } A obj = new B(); obj.greet(); // Output: A",
    source: "Page 37",
    topic: "Inheritance"
  },
  {
    id: 660,
    question: "How is static method resolved in hiding?",
    options: [
      "Static method is resolved at compile time using the reference type.",
      "At runtime.",
      "Using object type.",
      "With polymorphism."
    ],
    correctAnswer: "A",
    explanation: "Static method is resolved at compile time using the reference type.",
    source: "Page 37",
    topic: "Inheritance"
  },
  {
    id: 661,
    question: "According to the table, overriding applies to?",
    options: [
      "Instance methods",
      "Static methods",
      "Fields",
      "Constructors"
    ],
    correctAnswer: "A",
    explanation: "Overriding: Instance methods",
    source: "Page 38",
    topic: "Inheritance"
  },
  {
    id: 662,
    question: "Overriding resolved at?",
    options: [
      "Runtime",
      "Compile time",
      "Both",
      "None"
    ],
    correctAnswer: "A",
    explanation: "Overriding: Resolved at Runtime",
    source: "Page 38",
    topic: "Inheritance"
  },
  {
    id: 663,
    question: "For overriding, reference type used?",
    options: [
      "No",
      "Yes",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "A",
    explanation: "Overriding: Reference type used? No",
    source: "Page 38",
    topic: "Inheritance"
  },
  {
    id: 664,
    question: "Overriding supports polymorphism?",
    options: [
      "Supported",
      "Not supported",
      "Partially",
      "No"
    ],
    correctAnswer: "A",
    explanation: "Overriding: Polymorphism Supported",
    source: "Page 38",
    topic: "Inheritance"
  },
  {
    id: 665,
    question: "For overriding, @Override allowed?",
    options: [
      "Yes",
      "No",
      "Sometimes",
      "Required"
    ],
    correctAnswer: "A",
    explanation: "Overriding: @Override allowed? Yes",
    source: "Page 38",
    topic: "Inheritance"
  },
  {
    id: 666,
    question: "Are private methods inherited?",
    options: [
      "Private methods are not inherited by subclasses.",
      "Yes, they are.",
      "Only if protected.",
      "If public."
    ],
    correctAnswer: "A",
    explanation: "Private methods are not inherited by subclasses.",
    source: "Page 39",
    topic: "Inheritance"
  },
  {
    id: 667,
    question: "Private methods visibility?",
    options: [
      "They are not visible outside their own class, so they cannot be overridden.",
      "Visible in subclass.",
      "Overridable.",
      "Polymorphic."
    ],
    correctAnswer: "A",
    explanation: "They are not visible outside their own class, so they cannot be overridden.",
    source: "Page 39",
    topic: "Inheritance"
  },
  {
    id: 668,
    question: "According to the code example, what does A's secret?",
    options: [
      "private void secret() { System.out.println(\"A\"); }",
      "void secret() { System.out.println(\"B\"); }",
      "final void show() { System.out.println(\"A\"); }",
      "void show() { System.out.println(\"B\"); }"
    ],
    correctAnswer: "A",
    explanation: "class A { private void secret() { System.out.println(\"A\"); } }",
    source: "Page 39",
    topic: "Inheritance"
  },
  {
    id: 669,
    question: "In the example, B's secret?",
    options: [
      "void secret() { System.out.println(\"B\"); }",
      "private void secret() { System.out.println(\"A\"); }",
      "@Override void secret() { }",
      "final void secret() { }"
    ],
    correctAnswer: "A",
    explanation: "class B extends A { void secret() { System.out.println(\"B\"); } }",
    source: "Page 39",
    topic: "Inheritance"
  },
  {
    id: 670,
    question: "What does B obj = new B(); obj.secret(); output?",
    options: [
      "B",
      "A",
      "Error",
      "Nothing"
    ],
    correctAnswer: "A",
    explanation: "B obj = new B(); obj.secret(); // Output: B",
    source: "Page 39",
    topic: "Inheritance"
  },
  {
    id: 671,
    question: "Is B.secret() overriding?",
    options: [
      "This is not overriding. B.secret() is a new, unrelated method.",
      "Yes, it is.",
      "It hides.",
      "It shadows."
    ],
    correctAnswer: "A",
    explanation: "This is not overriding. B.secret() is a new, unrelated method.",
    source: "Page 39",
    topic: "Inheritance"
  },
  {
    id: 672,
    question: "Can a final method be overridden?",
    options: [
      "A method marked final cannot be overridden in a subclass.",
      "Yes.",
      "Only if static.",
      "If private."
    ],
    correctAnswer: "A",
    explanation: "A method marked final cannot be overridden in a subclass.",
    source: "Page 40",
    topic: "Inheritance"
  },
  {
    id: 673,
    question: "What happens if you try to override final?",
    options: [
      "Trying to do so causes a compile-time error.",
      "It succeeds.",
      "It hides.",
      "It shadows."
    ],
    correctAnswer: "A",
    explanation: "Trying to do so causes a compile-time error.",
    source: "Page 40",
    topic: "Inheritance"
  },
  {
    id: 674,
    question: "What is A's show?",
    options: [
      "final void show() { System.out.println(\"A\"); }",
      "void show() { System.out.println(\"B\"); }",
      "private void show() { }",
      "static void show() { }"
    ],
    correctAnswer: "A",
    explanation: "class A { final void show() { System.out.println(\"A\"); } }",
    source: "Page 40",
    topic: "Inheritance"
  },
  {
    id: 675,
    question: "Why error in B?",
    options: [
      "// Compile-time error void show() { System.out.println(\"B\"); }",
      "It overrides.",
      "No error.",
      "Use @Override."
    ],
    correctAnswer: "A",
    explanation: "class B extends A { // Compile-time error void show() { System.out.println(\"B\"); } }",
    source: "Page 40",
    topic: "Inheritance"
  },
  {
    id: 676,
    question: "What is the compiler error?",
    options: [
      "\"Cannot override the final method from A.\"",
      "\"Cannot reduce visibility\"",
      "\"Incompatible return type\"",
      "\"Signature mismatch\""
    ],
    correctAnswer: "A",
    explanation: "\"Cannot override the final method from A.\"",
    source: "Page 40",
    topic: "Inheritance"
  },
  {
    id: 677,
    question: "When to use @Override?",
    options: [
      "Always use @Override when overriding a method.",
      "Never use it.",
      "Only for finals.",
      "For statics."
    ],
    correctAnswer: "A",
    explanation: "Always use @Override when overriding a method.",
    source: "Page 41",
    topic: "Inheritance"
  },
  {
    id: 678,
    question: "What does @Override help?",
    options: [
      "Helps catch mistakes (wrong parameters, typo in name).",
      "Reduces visibility.",
      "Allows hiding.",
      "Shadows fields."
    ],
    correctAnswer: "A",
    explanation: "Helps catch mistakes (wrong parameters, typo in name).",
    source: "Page 41",
    topic: "Inheritance"
  },
  {
    id: 679,
    question: "If not overriding, what happens with @Override?",
    options: [
      "If the method is not actually overriding, the compiler shows an error.",
      "No error.",
      "Runtime error.",
      "Hiding."
    ],
    correctAnswer: "A",
    explanation: "If the method is not actually overriding, the compiler shows an error.",
    source: "Page 41",
    topic: "Inheritance"
  },
  {
    id: 680,
    question: "According to the code example in the slide, what is A's show?",
    options: [
      "void show(int x) { }",
      "void show(double x) { }",
      "void setName(String name) { }",
      "void setName(double name) { }"
    ],
    correctAnswer: "A",
    explanation: "class A { void show(int x) { } }",
    source: "Page 41",
    topic: "Inheritance"
  },
  {
    id: 681,
    question: "According to the code example in the slide, why error in B?",
    options: [
      "@Override void show(double x) { } // Compile error: not overriding (different parameter)",
      "void show(int x) { }",
      "It compiles.",
      "No @Override."
    ],
    correctAnswer: "A",
    explanation: "class B extends A { @Override void show(double x) { } // Compile error: not overriding (different parameter) }",
    source: "Page 41",
    topic: "Inheritance"
  },
  {
    id: 682,
    question: "What if @Override is missing?",
    options: [
      "If @Override is missing, Java won't detect signature mistakes.",
      "Always detects.",
      "Runtime detection.",
      "No mistakes possible."
    ],
    correctAnswer: "A",
    explanation: "If @Override is missing, Java won't detect signature mistakes.",
    source: "Page 42",
    topic: "Inheritance"
  },
  {
    id: 683,
    question: "What can missing @Override lead to?",
    options: [
      "This can lead to methods that are intended to override, but don't.",
      "Always overrides.",
      "Hiding only.",
      "Shadowing."
    ],
    correctAnswer: "A",
    explanation: "This can lead to methods that are intended to override, but don't.",
    source: "Page 42",
    topic: "Inheritance"
  },
  {
    id: 684,
    question: "According to the code example in the slide, what is A's setName?",
    options: [
      "void setName(String name) { }",
      "void setName(double name) { }",
      "void show(int x) { }",
      "void show(double x) { }"
    ],
    correctAnswer: "A",
    explanation: "class A { void setName(String name) { } }",
    source: "Page 42",
    topic: "Inheritance"
  },
  {
    id: 685,
    question: "What happens in B?",
    options: [
      "void setName(double name) { } // Not overriding",
      "@Override void setName(double name) { }",
      "It causes error without @Override.",
      "It overrides."
    ],
    correctAnswer: "A",
    explanation: "class B extends A { void setName(double name) { } // Not overriding }",
    source: "Page 42",
    topic: "Inheritance"
  },
  {
    id: 686,
    question: "Does it compile without error?",
    options: [
      "Java compiles this without error, but setName(double) is a new method, not an override.",
      "Compile error.",
      "Runtime error.",
      "Must use @Override."
    ],
    correctAnswer: "A",
    explanation: "Java compiles this without error, but setName(double) is a new method, not an override.",
    source: "Page 42",
    topic: "Inheritance"
  },
  {
    id: 687,
    question: "What would @Override do here?",
    options: [
      "Using @Override here would cause a compile-time error, which helps catch the mistake.",
      "No effect.",
      "Allow override.",
      "Hide it."
    ],
    correctAnswer: "A",
    explanation: "Using @Override here would cause a compile-time error, which helps catch the mistake.",
    source: "Page 42",
    topic: "Inheritance"
  },
  {
    id: 688,
    question: "What does overriding require for name and parameters?",
    options: [
      "Overriding requires the exact same method name and parameter list.",
      "Different parameters.",
      "Same name, different list.",
      "Different name."
    ],
    correctAnswer: "A",
    explanation: "Overriding requires the exact same method name and parameter list.",
    source: "Page 43",
    topic: "Inheritance"
  },
  {
    id: 689,
    question: "What does changing parameter type create?",
    options: [
      "Changing parameter type creates an overloaded method, not an override.",
      "An override.",
      "A hidden method.",
      "A shadowed field."
    ],
    correctAnswer: "A",
    explanation: "Changing parameter type creates an overloaded method, not an override.",
    source: "Page 43",
    topic: "Inheritance"
  },
  {
    id: 690,
    question: "According to the code example in the slide, what does A's show?",
    options: [
      "void show(int x) { System.out.println(\"A\"); }",
      "void show(double x) { System.out.println(\"B\"); }",
      "String getName() { return \"A\"; }",
      "int getName() { return 1; }"
    ],
    correctAnswer: "A",
    explanation: "class A { void show(int x) { System.out.println(\"A\"); } }",
    source: "Page 43",
    topic: "Inheritance"
  },
  {
    id: 691,
    question: "What is B's show?",
    options: [
      "void show(double x) { System.out.println(\"B\"); }",
      "void show(int x) { System.out.println(\"B\"); }",
      "@Override void show(int x) { }",
      "final void show() { }"
    ],
    correctAnswer: "A",
    explanation: "class B extends A { void show(double x) { System.out.println(\"B\"); } }",
    source: "Page 43",
    topic: "Inheritance"
  },
  {
    id: 692,
    question: "What does B obj = new B(); obj.show(5); output?",
    options: [
      "A -- no override",
      "B",
      "Error",
      "Nothing"
    ],
    correctAnswer: "A",
    explanation: "B obj = new B(); obj.show(5); // Output: A-- no override",
    source: "Page 43",
    topic: "Inheritance"
  },
  {
    id: 693,
    question: "Why no override?",
    options: [
      "This does not override A.show(int). The method in B has a different signature.",
      "It does override.",
      "Because static.",
      "Final."
    ],
    correctAnswer: "A",
    explanation: "This does not override A.show(int). The method in B has a different signature.",
    source: "Page 43",
    topic: "Inheritance"
  },
  {
    id: 694,
    question: "What must return type be in overridden method?",
    options: [
      "The return type in an overridden method must be the same or a subtype (covariant return).",
      "Always incompatible.",
      "Primitive different.",
      "Void."
    ],
    correctAnswer: "A",
    explanation: "The return type in an overridden method must be the same or a subtype (covariant return).",
    source: "Page 44",
    topic: "Inheritance"
  },
  {
    id: 695,
    question: "What if using incompatible return type?",
    options: [
      "Using an incompatible return type causes a compile error.",
      "Compiles fine.",
      "Runtime error.",
      "Hiding."
    ],
    correctAnswer: "A",
    explanation: "Using an incompatible return type causes a compile error.",
    source: "Page 44",
    topic: "Inheritance"
  },
  {
    id: 696,
    question: "According to the code example in the slide, what is A's getName?",
    options: [
      "String getName() { return \"A\"; }",
      "int getName() { return 1; }",
      "void show(int x) { }",
      "void show(double x) { }"
    ],
    correctAnswer: "A",
    explanation: "class A { String getName() { return \"A\"; } }",
    source: "Page 44",
    topic: "Inheritance"
  },
  {
    id: 697,
    question: "Why error in B?",
    options: [
      "// Compile-time error int getName() { return 1; }",
      "String getName() { return \"A\"; }",
      "It compiles.",
      "Use covariant."
    ],
    correctAnswer: "A",
    explanation: "class B extends A { // Compile-time error int getName() { return 1; } }",
    source: "Page 44",
    topic: "Inheritance"
  },
  {
    id: 698,
    question: "What is the error?",
    options: [
      "\"getName() in B cannot override getName() in A — return type is incompatible.\"",
      "\"Cannot reduce visibility\"",
      "\"Cannot override final\"",
      "\"Signature mismatch\""
    ],
    correctAnswer: "A",
    explanation: "\"getName() in B cannot override getName() in A — return type is incompatible.\"",
    source: "Page 44",
    topic: "Inheritance"
  },
  {
    id: 699,
    question: "First best practice?",
    options: [
      "Always match parameters exactly.",
      "Change them slightly.",
      "Use different types.",
      "Make optional."
    ],
    correctAnswer: "A",
    explanation: "Always match parameters exactly.",
    source: "Page 45",
    topic: "Inheritance"
  },
  {
    id: 700,
    question: "Another?",
    options: [
      "Use @Override to prevent silent errors.",
      "Avoid it.",
      "Only for errors.",
      "For static."
    ],
    correctAnswer: "A",
    explanation: "Use @Override to prevent silent errors.",
    source: "Page 45",
    topic: "Inheritance"
  },
  {
    id: 701,
    question: "Avoid what with access?",
    options: [
      "Avoid changing access level to more restrictive.",
      "Always reduce.",
      "Make private.",
      "Default."
    ],
    correctAnswer: "A",
    explanation: "Avoid changing access level to more restrictive.",
    source: "Page 45",
    topic: "Inheritance"
  },
  {
    id: 702,
    question: "Be clear about?",
    options: [
      "Be clear about behavior: override to specialize, not to confuse.",
      "Always confuse.",
      "Hide behavior.",
      "Shadow."
    ],
    correctAnswer: "A",
    explanation: "Be clear about behavior: override to specialize, not to confuse.",
    source: "Page 45",
    topic: "Inheritance"
  },
  {
    id: 703,
    question: "Consider what?",
    options: [
      "Consider calling super.method() when you want to reuse original behavior.",
      "Never call super.",
      "Always confuse.",
      "Use this only."
    ],
    correctAnswer: "A",
    explanation: "Consider calling super.method() when you want to reuse original behavior.",
    source: "Page 45",
    topic: "Inheritance"
  },
  {
    id: 704,
    question: "What is Slide 46 about?",
    options: [
      "More about Java Inheritance",
      "Method Overriding in Java",
      "Constructors and Inheritance",
      "Summary"
    ],
    correctAnswer: "A",
    explanation: "More about Java Inheritance",
    source: "Page 46",
    topic: "Inheritance"
  },
  {
    id: 705,
    question: "Does Java support multilevel inheritance?",
    options: [
      "Java supports multilevel inheritance: a class can inherit from a subclass, which itself inherits from another class.",
      "No.",
      "Only two levels.",
      "With interfaces only."
    ],
    correctAnswer: "A",
    explanation: "Java supports multilevel inheritance: a class can inherit from a subclass, which itself inherits from another class.",
    source: "Page 47",
    topic: "Inheritance"
  },
  {
    id: 706,
    question: "According to the example, the chain is?",
    options: [
      "class A { ... } class B extends A { ... } class C extends B { ... }",
      "class C extends A, B",
      "interface A",
      "abstract class A"
    ],
    correctAnswer: "A",
    explanation: "class A { void msg() { System.out.println(\"A\"); } } class B extends A { void msg() { System.out.println(\"B\"); } } class C extends B { void msg() { System.out.println(\"C\"); } }",
    source: "Page 47",
    topic: "Inheritance"
  },
  {
    id: 707,
    question: "What does A obj = new C(); obj.msg(); output?",
    options: [
      "C",
      "A",
      "B",
      "Error"
    ],
    correctAnswer: "A",
    explanation: "Aobj = new C(); obj.msg(); // Output: C",
    source: "Page 47",
    topic: "Inheritance"
  },
  {
    id: 708,
    question: "How is method resolved in multilevel?",
    options: [
      "Method resolution follows the inheritance chain, starting from the actual object (C) upward.",
      "From A down.",
      "Compile time only.",
      "No chain."
    ],
    correctAnswer: "A",
    explanation: "Method resolution follows the inheritance chain, starting from the actual object (C) upward.",
    source: "Page 47",
    topic: "Inheritance"
  },
  {
    id: 709,
    question: "What does instanceof check?",
    options: [
      "The instanceof keyword checks if an object is an instance of a given class or subclass.",
      "If method overridden.",
      "Field value.",
      "Constructor call."
    ],
    correctAnswer: "A",
    explanation: "The instanceof keyword checks if an object is an instance of a given class or subclass.",
    source: "Page 48",
    topic: "Inheritance"
  },
  {
    id: 710,
    question: "In the example, A obj = new C(); if (obj instanceof C) ... outputs C, B, A?",
    options: [
      "Yes, outputs C B A",
      "Only C",
      "Only A",
      "Error"
    ],
    correctAnswer: "A",
    explanation: "Aobj = new C(); if (obj instanceof C) System.out.println(\"C\"); if (obj instanceof B) System.out.println(\"B\"); if (obj instanceof A) System.out.println(\"A\"); Output: C B A",
    source: "Page 48",
    topic: "Inheritance"
  },
  {
    id: 711,
    question: "What is instanceof used for?",
    options: [
      "Used to safely downcast or verify object type at runtime",
      "To override",
      "To hide",
      "To shadow"
    ],
    correctAnswer: "A",
    explanation: "Used to safely downcast or verify object type at runtime.",
    source: "Page 48",
    topic: "Inheritance"
  },
  {
    id: 712,
    question: "What do all classes extend implicitly?",
    options: [
      "All classes in Java implicitly extend the Object class",
      "Animal class",
      "No class",
      "Interface"
    ],
    correctAnswer: "A",
    explanation: "All classes in Java implicitly extend the Object class.",
    source: "Page 49",
    topic: "Inheritance"
  },
  {
    id: 713,
    question: "Common methods in Object?",
    options: [
      "toString(), equals(Object obj), hashCode()",
      "speak(), bark()",
      "fly(), swim()",
      "log(), write()"
    ],
    correctAnswer: "A",
    explanation: "Common methods include: toString(), equals(Object obj), hashCode()",
    source: "Page 49",
    topic: "Inheritance"
  },
  {
    id: 714,
    question: "What can be done with Object methods?",
    options: [
      "These can be overridden to customize behavior",
      "Cannot override",
      "Static only",
      "Final"
    ],
    correctAnswer: "A",
    explanation: "These can be overridden to customize behavior.",
    source: "Page 49",
    topic: "Inheritance"
  },
  {
    id: 715,
    question: "In the example, Person overrides toString to?",
    options: [
      "return \"Person: \" + name;",
      "System.out.println(\"Alice\");",
      "equals(Object obj)",
      "hashCode()"
    ],
    correctAnswer: "A",
    explanation: "class Person { String name; Person(String name) { this.name = name; } @Override public String toString() { r eturn \" Person: \" + name; } }",
    source: "Page 49",
    topic: "Inheritance"
  },
  {
    id: 716,
    question: "What does System.out.println(new Person(\" Alice\" )); output?",
    options: [
      "Person: Alice",
      "Alice",
      "Generic Animal",
      "Dog"
    ],
    correctAnswer: "A",
    explanation: "System.out.println(new Person(\"Alice\")); // Output: Person: Alice",
    source: "Page 49",
    topic: "Inheritance"
  },
  {
    id: 717,
    question: "Can abstract class be instantiated?",
    options: [
      "An abstract class cannot be instantiated",
      "Yes",
      "Only subclasses",
      "With new"
    ],
    correctAnswer: "A",
    explanation: "An abstract class cannot be instantiated.",
    source: "Page 50",
    topic: "Inheritance"
  },
  {
    id: 718,
    question: "What may abstract class contain?",
    options: [
      "It may contain abstract methods — methods without a body — to be implemented by subclasses",
      "Only concrete methods",
      "Constructors only",
      "Fields only"
    ],
    correctAnswer: "A",
    explanation: "It may contain abstract methods —methods without a body —to be implemented by subclasses.",
    source: "Page 50",
    topic: "Inheritance"
  },
  {
    id: 719,
    question: "What is abstract Animal?",
    options: [
      "abstract class Animal { abstract void makeSound(); }",
      "class Dog { void makeSound() { System.out.println(\"Bark\"); } }",
      "interface Flyable { void fly(); }",
      "class Person { }"
    ],
    correctAnswer: "A",
    explanation: "abstract class Animal { abstract void makeSound(); }",
    source: "Page 50",
    topic: "Inheritance"
  },
  {
    id: 720,
    question: "How does Dog implement?",
    options: [
      "class Dog extends Animal { void makeSound() { System.out.println(\"Bark\"); } }",
      "abstract void makeSound();",
      "implements Flyable",
      "extends Person"
    ],
    correctAnswer: "A",
    explanation: "class Dog extends Animal { void makeSound() { System.out.println(\"Bark\"); } }",
    source: "Page 50",
    topic: "Inheritance"
  },
  {
    id: 721,
    question: "When to use abstract classes?",
    options: [
      "Used when you want to define a common base class but enforce method implementation in subclasses",
      "For multiple inheritance",
      "To instantiate directly",
      "For static methods"
    ],
    correctAnswer: "A",
    explanation: "Used when you want to define a common base class but enforce method implementation in subclasses.",
    source: "Page 50",
    topic: "Inheritance"
  },
  {
    id: 722,
    question: "In Java, can a superclass reference point to subclass object?",
    options: [
      "A reference variable of a superclass can point to an object of its subclass",
      "No",
      "Only same class",
      "Interfaces only"
    ],
    correctAnswer: "A",
    explanation: "In Java, a reference variable of a superclass can point to an object of its subclass.",
    source: "Page 51",
    topic: "Inheritance"
  },
  {
    id: 723,
    question: "In the example, Animal a1 = new Animal(); Animal a2 = new Dog(); is legal because?",
    options: [
      "Dog \"is-a\" Animal",
      "Cat is-a Animal",
      "Method calls",
      "Output Dog"
    ],
    correctAnswer: "A",
    explanation: "This is legal because Dog 'is-a' Animal.",
    source: "Page 51",
    topic: "Inheritance"
  },
  {
    id: 724,
    question: "Method calls in Reference?",
    options: [
      "Method calls depend on actual object type (polymorphism), which will be covered next.",
      "On reference type only",
      "Compile time",
      "Static"
    ],
    correctAnswer: "A",
    explanation: "Method calls depend on actual object type (polymorphism), which will be covered next.",
    source: "Page 51",
    topic: "Inheritance"
  },
  {
    id: 725,
    question: "Can you create array of superclass type with subclass objects?",
    options: [
      "You can create an array of superclass type, and store different subclass objects",
      "No",
      "Only same type",
      "Interfaces only"
    ],
    correctAnswer: "A",
    explanation: "You can create an array of superclass type, and store different subclass objects.",
    source: "Page 52",
    topic: "Inheritance"
  },
  {
    id: 726,
    question: "In the example, Animal[] animals = { new Dog(), new Cat(), new Animal() }; each element is?",
    options: [
      "Treated as Animal, but may behave differently",
      "As Dog only",
      "Error",
      "No polymorphism"
    ],
    correctAnswer: "A",
    explanation: "Each element is treated as Animal, but may behave differently.",
    source: "Page 52",
    topic: "Inheritance"
  },
  {
    id: 727,
    question: "What will be explored next?",
    options: [
      "We'll explore how method calls work with this in Polymorphism",
      "Constructors",
      "Overriding",
      "Hiding"
    ],
    correctAnswer: "A",
    explanation: "We'll explore how method calls work with this in Polymorphism.",
    source: "Page 52",
    topic: "Inheritance"
  },
  {
    id: 728,
    question: "What are basic concepts in summary?",
    options: [
      "extends keyword, superclass vs subclass \"is-a\" relationship Benefits: code reuse, hierarchy",
      "private: not accessible",
      "Constructors not inherited",
      "Same name, parameters"
    ],
    correctAnswer: "A",
    explanation: "Basic Concepts: extends keyword, superclass vs subclass 'is-a' relationship Benefits: code reuse, hierarchy",
    source: "Page 53",
    topic: "Inheritance"
  },
  {
    id: 729,
    question: "Access modifiers in inheritance?",
    options: [
      "private: not accessible in subclass, protected: accessible in subclass, public: accessible everywhere, (default): package-level access, Applied to fields and methods",
      "Constructors not inherited",
      "Same name, parameters",
      "Cannot reduce visibility"
    ],
    correctAnswer: "A",
    explanation: "Access Modifier and Inheritance: private: not accessible in subclass, protected: accessible in subclass, public: accessible everywhere, (default): package-level access, Applied to fields and methods",
    source: "Page 53",
    topic: "Inheritance"
  },
  {
    id: 730,
    question: "Constructors in inheritance?",
    options: [
      "Constructors are not inherited, Using super(...) to call superclass constructor, super(...) must be the first statement, Constructor overloading ≠ overriding",
      "Same name, parameters",
      "Static methods belong to class",
      "Same-named field hides"
    ],
    correctAnswer: "A",
    explanation: "Constructors and Inheritance: Constructors are not inherited, Using super(...) to call superclass constructor, super(...) must be the first statement, Constructor overloading ≠ overriding",
    source: "Page 53",
    topic: "Inheritance"
  },
  {
    id: 731,
    question: "Method overriding summary?",
    options: [
      "Same name, parameters, and compatible return type, Resolved at runtime (dynamic dispatch), Enables polymorphism, Use @Override to ensure correctness",
      "Constructors are not inherited",
      "Static: hiding, not overriding",
      "Signature mismatch"
    ],
    correctAnswer: "A",
    explanation: "Method Overriding: Same name, parameters, and compatible return type, Resolved at runtime (dynamic dispatch), Enables polymorphism, Use @Override to ensure correctness",
    source: "Page 53",
    topic: "Inheritance"
  },
  {
    id: 732,
    question: "Access rules for overriding?",
    options: [
      "Cannot reduce visibility when overriding, public → public, protected → protected/public, Overriding private method not allowed (not inherited)",
      "Same name, parameters",
      "Class C extends B extends A",
      "All classes inherit from Object"
    ],
    correctAnswer: "A",
    explanation: "Access Modifier Rules for Overriding: Cannot reduce visibility when overriding, public → public, protected → protected/public, Overriding private method not allowed (not inherited)",
    source: "Page 53",
    topic: "Inheritance"
  },
  {
    id: 733,
    question: "Static methods summary?",
    options: [
      "Static methods belong to class, Method hiding: resolved at compile time by reference type, No polymorphism",
      "Same name, parameters",
      "Signature mismatch",
      "Superclass reference can point to subclass object"
    ],
    correctAnswer: "A",
    explanation: "Static Methods: Hiding, Not Overriding: Static methods belong to class, Method hiding: resolved at compile time by reference type, No polymorphism",
    source: "Page 53",
    topic: "Inheritance"
  },
  {
    id: 734,
    question: "Field hiding?",
    options: [
      "Same-named field in subclass hides superclass field, Resolved at compile time using reference type, Use super.field to access hidden field",
      "Constructors are not inherited",
      "Cannot reduce visibility",
      "All classes inherit from Object"
    ],
    correctAnswer: "A",
    explanation: "Field Hiding: Same-named field in subclass hides superclass field, Resolved at compile time using reference type, Use super.field to access hidden field",
    source: "Page 53",
    topic: "Inheritance"
  },
  {
    id: 735,
    question: "Common mistakes in overriding?",
    options: [
      "Signature mismatch, Incompatible return type, Reducing access modifier, Trying to override final, private, or static method, Forgetting @Override (leads to silent errors)",
      "extends keyword",
      "super(...) first",
      "Enables polymorphism"
    ],
    correctAnswer: "A",
    explanation: "Common Mistakes in Overriding: Signature mismatch, Incompatible return type, Reducing access modifier, Trying to override final, private, or static method, Forgetting @Override (leads to silent errors)",
    source: "Page 53",
    topic: "Inheritance"
  },
  {
    id: 736,
    question: "Multilevel inheritance?",
    options: [
      "Class C extends B extends A, super() calls go one level up",
      "private not accessible",
      "Constructors not inherited",
      "Same name, parameters"
    ],
    correctAnswer: "A",
    explanation: "Multilevel Inheritance: Class C extends B extends A, super() calls go one level up",
    source: "Page 53",
    topic: "Inheritance"
  },
  {
    id: 737,
    question: "Object class in Java?",
    options: [
      "All classes inherit from Object, Common methods: toString(), equals(), hashCode()",
      "Static belong to class",
      "Same-named hides",
      "Signature mismatch"
    ],
    correctAnswer: "A",
    explanation: "Object Class in Java: All classes inherit from Object, Common methods: toString(), equals(), hashCode()",
    source: "Page 53",
    topic: "Inheritance"
  },
  {
    id: 738,
    question: "Reference and arrays?",
    options: [
      "Superclass reference can point to subclass object, Arrays of superclass type can hold different subclass objects, Sets the foundation for polymorphism",
      "extends keyword",
      "private not accessible",
      "Constructors not inherited"
    ],
    correctAnswer: "A",
    explanation: "Reference Type and Arrays: Superclass reference can point to subclass object, Arrays of superclass type can hold different subclass objects, Sets the foundation for polymorphism",
    source: "Page 53",
    topic: "Inheritance"
  },
  {
    id: 739,
    question: "What is the title of the presentation?",
    options: [
      "Inheritance",
      "Polymorphism",
      "Encapsulation",
      "Abstraction"
    ],
    correctAnswer: "B",
    explanation: "Polymorphism",
    source: "Slide 1",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 740,
    question: "Who is the author of the presentation?",
    options: [
      "Elon Musk",
      "Trong-Hop Do",
      "Bill Gates",
      "Mark Zuckerberg"
    ],
    correctAnswer: "B",
    explanation: "Tác giả: Trong-Hop Do",
    source: "Slide 1",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 741,
    question: "What is the definition of Polymorphism?",
    options: [
      "The ability of an object to take only one form.",
      "The ability of an object to take many forms.",
      "The process of hiding data.",
      "The process of inheriting properties."
    ],
    correctAnswer: "B",
    explanation: "Polymorphism is the ability of an object to take many forms.",
    source: "Slide 2",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 742,
    question: "In object-oriented programming (OOP), what does polymorphism refer to?",
    options: [
      "Multiple interfaces with one implementation.",
      "One interface with multiple possible implementations.",
      "No interfaces at all.",
      "Interfaces without implementations."
    ],
    correctAnswer: "B",
    explanation: "In object-oriented programming (OOP), it refers to one interface with multiple possible implementations.",
    source: "Slide 2",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 743,
    question: "What is a real-world analogy for Polymorphism?",
    options: [
      "A key that opens only one lock.",
      "A remote control can operate different devices such as a TV, an air conditioner, or a speaker.",
      "A book that has only one page.",
      "A car that drives in only one direction."
    ],
    correctAnswer: "B",
    explanation: "Aremote control can operate different devices such as a TV, an air conditioner, or a speaker.",
    source: "Slide 2",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 744,
    question: "In the real-world analogy, what does the same button (e.g., \"power on\") do?",
    options: [
      "Always triggers the same behavior regardless of the device.",
      "Triggers different behaviors depending on the device.",
      "Does nothing.",
      "Breaks the device."
    ],
    correctAnswer: "B",
    explanation: "The same button (e.g., \"power on\") triggers different behaviors depending on the device.",
    source: "Slide 2",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 745,
    question: "In Java, what can a superclass reference do?",
    options: [
      "Refer only to superclass objects.",
      "Refer to different subclass objects.",
      "Refer to no objects.",
      "Refer only to interfaces."
    ],
    correctAnswer: "B",
    explanation: "Asuperclass reference can refer to different subclass objects.",
    source: "Slide 3",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 746,
    question: "According to the code in the slide, what does the makeSound() method in class Animal print?",
    options: [
      "\"Dog barks\"",
      "\"Cat meows\"",
      "\"Some generic animal sound\"",
      "\"Animal sound\""
    ],
    correctAnswer: "C",
    explanation: "class Animal { void makeSound() { System.out.println(\"Some generic animal sound\"); } }",
    source: "Slide 3",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 747,
    question: "According to the code in the slide, what does the overridden makeSound() method in class Dog print?",
    options: [
      "\"Some generic animal sound\"",
      "\"Dog barks\"",
      "\"Cat meows\"",
      "\"Animal sound\""
    ],
    correctAnswer: "B",
    explanation: "class Dog extends Animal { @Override void makeSound() { System.out.println(\"Dog barks\"); } }",
    source: "Slide 3",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 748,
    question: "According to the code in the slide, what does the overridden makeSound() method in class Cat print?",
    options: [
      "\"Some generic animal sound\"",
      "\"Dog barks\"",
      "\"Cat meows\"",
      "\"Animal sound\""
    ],
    correctAnswer: "C",
    explanation: "class Cat extends Animal { @Override void makeSound() { System.out.println(\"Cat meows\"); } }",
    source: "Slide 3",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 749,
    question: "According to the code in the slide, what is the output of a1.makeSound() where Animal a1 = new Dog()?",
    options: [
      "\"Some generic animal sound\"",
      "\"Dog barks\"",
      "\"Cat meows\"",
      "\"Animal sound\""
    ],
    correctAnswer: "B",
    explanation: "Animal a1 = new Dog(); a1.makeSound(); // Dog barks",
    source: "Slide 3",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 750,
    question: "According to the code in the slide, what is the output of a2.makeSound() where Animal a2 = new Cat()?",
    options: [
      "\"Some generic animal sound\"",
      "\"Dog barks\"",
      "\"Cat meows\"",
      "\"Animal sound\""
    ],
    correctAnswer: "C",
    explanation: "Animal a2 = new Cat(); a2.makeSound(); // Cat meows",
    source: "Slide 3",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 751,
    question: "Why does polymorphism matter?",
    options: [
      "It decreases flexibility and reusability.",
      "It increases flexibility and reusability.",
      "It has no effect on code.",
      "It makes code harder to maintain."
    ],
    correctAnswer: "B",
    explanation: "Polymorphism increases flexibility and reusability.",
    source: "Slide 3",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 752,
    question: "What does polymorphism allow in terms of handling object types?",
    options: [
      "Non-uniform handling of different object types.",
      "Uniform handling of different object types, making code easier to extend and maintain.",
      "Ignoring object types.",
      "Deleting object types."
    ],
    correctAnswer: "B",
    explanation: "It allows uniform handling of different object types, making code easier to extend and maintain.",
    source: "Slide 3",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 753,
    question: "How many types of polymorphism does Java support?",
    options: [
      "One",
      "Two",
      "Three",
      "Four"
    ],
    correctAnswer: "B",
    explanation: "Java supports two types of polymorphism:",
    source: "Slide 4",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 754,
    question: "What is the first type of polymorphism in Java?",
    options: [
      "Runtime Polymorphism",
      "Compile-time Polymorphism",
      "Static Polymorphism",
      "Dynamic Polymorphism"
    ],
    correctAnswer: "B",
    explanation: "1. Compile-time Polymorphism",
    source: "Slide 4",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 755,
    question: "What is Compile-time Polymorphism also called?",
    options: [
      "Method Overriding",
      "Method Overloading",
      "Method Hiding",
      "Method Shadowing"
    ],
    correctAnswer: "B",
    explanation: "Also called Method Overloading",
    source: "Slide 4",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 756,
    question: "When is the method to be executed determined in Compile-time Polymorphism?",
    options: [
      "At runtime",
      "At compile time",
      "At load time",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "The method to be executed is determined at compile time.",
    source: "Slide 4",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 757,
    question: "What is Compile-time Polymorphism based on?",
    options: [
      "Object type",
      "Method signatures (name + parameters)",
      "Reference type",
      "Return type"
    ],
    correctAnswer: "B",
    explanation: "Based on method signatures (name + parameters).",
    source: "Slide 4",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 758,
    question: "What is the second type of polymorphism in Java?",
    options: [
      "Compile-time Polymorphism",
      "Runtime Polymorphism",
      "Static Polymorphism",
      "Overloading Polymorphism"
    ],
    correctAnswer: "B",
    explanation: "2. Runtime Polymorphism",
    source: "Slide 4",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 759,
    question: "What is Runtime Polymorphism also called?",
    options: [
      "Method Overloading",
      "Method Overriding",
      "Method Hiding",
      "Method Shadowing"
    ],
    correctAnswer: "B",
    explanation: "Also called Method Overriding",
    source: "Slide 4",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 760,
    question: "When is the method to be executed determined in Runtime Polymorphism?",
    options: [
      "At compile time",
      "At runtime",
      "At load time",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "The method to be executed is determined at runtime.",
    source: "Slide 4",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 761,
    question: "What is Runtime Polymorphism based on?",
    options: [
      "The reference type",
      "The actual object type, not the reference type",
      "Method name only",
      "Parameters only"
    ],
    correctAnswer: "B",
    explanation: "Based on the actual object type, not the reference type.",
    source: "Slide 4",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 762,
    question: "What do these two forms of polymorphism enable?",
    options: [
      "Rigidity and code duplication",
      "Flexibility and code reuse in different ways",
      "Errors in code",
      "Deletion of methods"
    ],
    correctAnswer: "B",
    explanation: "These two forms of polymorphism enable flexibility and code reuse in different ways.",
    source: "Slide 4",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 763,
    question: "What is the definition of Compile-time Polymorphism (Method Overloading)?",
    options: [
      "Two or more methods in different classes with the same name.",
      "Two or more methods in the same class share the same name but have different parameter lists.",
      "Methods with the same parameters but different names.",
      "Methods that cannot be called."
    ],
    correctAnswer: "B",
    explanation: "Two or more methods in the same class share the same name but have different parameter lists.",
    source: "Slide 5",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 764,
    question: "What must methods differ in for Method Overloading?",
    options: [
      "Return type only",
      "Number, type, or order of parameters",
      "Method name only",
      "Visibility only"
    ],
    correctAnswer: "B",
    explanation: "Must differ in number, type, or order of parameters.",
    source: "Slide 5",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 765,
    question: "What is not enough alone to distinguish methods in Method Overloading?",
    options: [
      "Number of parameters",
      "Type of parameters",
      "Return type",
      "Order of parameters"
    ],
    correctAnswer: "C",
    explanation: "Return type alone is not enough to distinguish methods.",
    source: "Slide 5",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 766,
    question: "According to the code in the slide, what does the add(int a, int b) method in class Calculator return?",
    options: [
      "a - b",
      "a + b",
      "a * b",
      "a / b"
    ],
    correctAnswer: "B",
    explanation: "int add(int a, int b) { r eturn a + b; }",
    source: "Slide 6",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 767,
    question: "According to the code in the slide, what does the add(double a, double b) method in class Calculator return?",
    options: [
      "a - b",
      "a + b",
      "a * b",
      "a / b"
    ],
    correctAnswer: "B",
    explanation: "double add(double a, double b) { r eturn a + b; }",
    source: "Slide 6",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 768,
    question: "According to the code in the slide, what does the add(int a, int b, int c) method in class Calculator return?",
    options: [
      "a + b + c",
      "a - b - c",
      "a * b * c",
      "a / b / c"
    ],
    correctAnswer: "A",
    explanation: "int add(int a, int b, int c) { r eturn a + b + c; }",
    source: "Slide 6",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 769,
    question: "According to the code in the slide, which version does c.add(2, 3) call where Calculator c = new Calculator()?",
    options: [
      "double version",
      "3-parameter version",
      "int version",
      "No version"
    ],
    correctAnswer: "C",
    explanation: "c.add(2, 3); // Calls int version",
    source: "Slide 6",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 770,
    question: "According to the code in the slide, which version does c.add(2.5, 3.5) call where Calculator c = new Calculator()?",
    options: [
      "int version",
      "double version",
      "No version",
      "Three parameter version"
    ],
    correctAnswer: "B",
    explanation: "c.add(2.5, 3.5); // Calls double version",
    source: "Slide 6",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 771,
    question: "According to the code in the slide, which version does c.add(1, 2, 3) call where Calculator c = new Calculator()?",
    options: [
      "int version",
      "double version",
      "3-parameter version",
      "No version"
    ],
    correctAnswer: "C",
    explanation: "c.add(1, 2, 3); // Calls 3-parameter version",
    source: "Slide 6",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 772,
    question: "What is the definition of Runtime Polymorphism (Method Overriding)?",
    options: [
      "A superclass redefines a method from its subclass.",
      "A subclass redefines a method inherited from its superclass.",
      "Methods with different names.",
      "Methods that are not inherited."
    ],
    correctAnswer: "B",
    explanation: "Asubclass redefines a method inherited from its superclass.",
    source: "Slide 7",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 773,
    question: "What must be identical in Method Overriding?",
    options: [
      "Method names and parameter lists",
      "Only method names",
      "Only parameter lists",
      "Return types only"
    ],
    correctAnswer: "A",
    explanation: "Method names and parameter lists must be identical.",
    source: "Slide 7",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 774,
    question: "What annotation should be used to ensure correctness in Method Overriding?",
    options: [
      "@Deprecated",
      "@Override",
      "@SuppressWarnings",
      "@FunctionalInterface"
    ],
    correctAnswer: "B",
    explanation: "Use @Override annotation to ensure correctness.",
    source: "Slide 7",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 775,
    question: "When is the decision of which method to call made in Method Overriding?",
    options: [
      "At compile time",
      "At runtime",
      "At load time",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "Decision of which method to call is made at runtime.",
    source: "Slide 7",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 776,
    question: "According to the code in the slide, what does the makeSound() method in class Animal print?",
    options: [
      "\"Dog barks\"",
      "\"Animal sound\"",
      "\"Cat meows\"",
      "\"Some generic animal sound\""
    ],
    correctAnswer: "B",
    explanation: "void makeSound() { System.out.println(\"Animal sound\"); }",
    source: "Slide 8",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 777,
    question: "According to the code in the slide, what does the overridden makeSound() method in class Dog print?",
    options: [
      "\"Animal sound\"",
      "\"Dog barks\"",
      "\"Cat meows\"",
      "\"Some generic animal sound\""
    ],
    correctAnswer: "B",
    explanation: "@Override void makeSound() { System.out.println(\"Dog barks\"); }",
    source: "Slide 8",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 778,
    question: "According to the code in the slide, what is the output of a.makeSound() where Animal a = new Dog()?",
    options: [
      "\"Animal sound\"",
      "\"Dog barks\"",
      "\"Cat meows\"",
      "\"Some generic animal sound\""
    ],
    correctAnswer: "B",
    explanation: "Animal a = new Dog(); a.makeSound(); // Output: Dog barks",
    source: "Slide 8",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 779,
    question: "What does runtime polymorphism allow code to work with?",
    options: [
      "Specific types only",
      "General types (superclasses) while executing specific behavior (subclass methods)",
      "No types",
      "Abstract types only"
    ],
    correctAnswer: "B",
    explanation: "Allows code to work with general types (superclasses) while executing specific behavior (subclass methods).",
    source: "Slide 9",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 780,
    question: "How does runtime polymorphism make it easy to extend the system?",
    options: [
      "By changing existing code",
      "By adding new subclasses without changing existing code",
      "By deleting subclasses",
      "By ignoring superclasses"
    ],
    correctAnswer: "B",
    explanation: "Makes it easy to extend the system by adding new subclasses without changing existing code.",
    source: "Slide 9",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 781,
    question: "What does runtime polymorphism help achieve?",
    options: [
      "Tight coupling",
      "Loose coupling: components depend on abstract types, not concrete implementations",
      "No coupling",
      "Dependent coupling"
    ],
    correctAnswer: "B",
    explanation: "Helps achieve loose coupling: components depend on abstract types, not concrete implementations.",
    source: "Slide 9",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 782,
    question: "Why is runtime polymorphism essential?",
    options: [
      "For building rigid systems",
      "For building scalable, maintainable, and flexible object-oriented systems",
      "For non-object-oriented systems",
      "For deleting code"
    ],
    correctAnswer: "B",
    explanation: "Runtime polymorphism is essential for building scalable, maintainable, and flexible object-oriented systems.",
    source: "Slide 9",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 783,
    question: "In the comparison table, what is the name for Compile-time Polymorphism?",
    options: [
      "Method Overriding",
      "Method Overloading",
      "Method Hiding",
      "Method Shadowing"
    ],
    correctAnswer: "B",
    explanation: "Method Overloading",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 784,
    question: "In the comparison table, what is the name for Runtime Polymorphism?",
    options: [
      "Method Overloading",
      "Method Overriding",
      "Method Hiding",
      "Method Shadowing"
    ],
    correctAnswer: "B",
    explanation: "Method Overriding",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 785,
    question: "In the comparison table, when is Compile-time Polymorphism decided?",
    options: [
      "At runtime",
      "At compile time",
      "At load time",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "At compile time",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 786,
    question: "In the comparison table, when is Runtime Polymorphism decided?",
    options: [
      "At compile time",
      "At runtime",
      "At load time",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "At runtime",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 787,
    question: "In the comparison table, does Compile-time Polymorphism require extends?",
    options: [
      "Yes",
      "No",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "No",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 788,
    question: "In the comparison table, does Runtime Polymorphism require extends?",
    options: [
      "No",
      "Yes",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "Yes",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 789,
    question: "In the comparison table, what are the parameters for Compile-time Polymorphism?",
    options: [
      "Same",
      "Different",
      "None",
      "Optional"
    ],
    correctAnswer: "B",
    explanation: "Different",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 790,
    question: "In the comparison table, what are the parameters for Runtime Polymorphism?",
    options: [
      "Different",
      "Same",
      "None",
      "Optional"
    ],
    correctAnswer: "B",
    explanation: "Same",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 791,
    question: "In the comparison table, what class is involved in Compile-time Polymorphism?",
    options: [
      "Yes",
      "Same class",
      "Different classes",
      "No class"
    ],
    correctAnswer: "B",
    explanation: "Same class",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 792,
    question: "In the comparison table, what classes are involved in Runtime Polymorphism?",
    options: [
      "Same class",
      "Superclass & Subclass",
      "No classes",
      "Unrelated classes"
    ],
    correctAnswer: "B",
    explanation: "Superclass & Subclass",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 793,
    question: "In the comparison table, what is the flexibility for Compile-time Polymorphism?",
    options: [
      "More flexible",
      "Less flexible",
      "No flexibility",
      "High flexibility"
    ],
    correctAnswer: "B",
    explanation: "Less flexible",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 794,
    question: "In the comparison table, what is the flexibility for Runtime Polymorphism?",
    options: [
      "Less flexible",
      "More flexible",
      "No flexibility",
      "Low flexibility"
    ],
    correctAnswer: "B",
    explanation: "More flexible",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 795,
    question: "According to the easy rule, what is Overloading?",
    options: [
      "Same parameters (subclass overrides)",
      "Different parameters (same class)",
      "No parameters",
      "Optional parameters"
    ],
    correctAnswer: "B",
    explanation: "Overloading = different parameters (same class)",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 796,
    question: "According to the easy rule, what is Overriding?",
    options: [
      "Different parameters (same class)",
      "Same parameters (subclass overrides)",
      "No parameters",
      "Optional parameters"
    ],
    correctAnswer: "B",
    explanation: "Overriding = same parameters (subclass overrides)",
    source: "Slide 10",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 797,
    question: "According to the Method Overloading example in the slide, what does add(int a, int b) return?",
    options: [
      "a - b",
      "a + b",
      "a * b",
      "a / b"
    ],
    correctAnswer: "B",
    explanation: "int add(int a, int b) { r eturn a + b; }",
    source: "Slide 11",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 798,
    question: "According to the Method Overloading example in the slide, what does add(double a, double b) return?",
    options: [
      "a - b",
      "a + b",
      "a * b",
      "a / b"
    ],
    correctAnswer: "B",
    explanation: "double add(double a, double b) { r eturn a + b; }",
    source: "Slide 11",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 799,
    question: "According to the Method Overriding example in the slide, what does makeSound() in class Animal print?",
    options: [
      "\"Dog barks\"",
      "\"Animal sound\"",
      "\"Cat meows\"",
      "\"Some generic animal sound\""
    ],
    correctAnswer: "B",
    explanation: "void makeSound() { System.out.println(\"Animal sound\"); }",
    source: "Slide 11",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 800,
    question: "According to the Method Overriding example in the slide, what does overridden makeSound() in class Dog print?",
    options: [
      "\"Animal sound\"",
      "\"Dog barks\"",
      "\"Cat meows\"",
      "\"Some generic animal sound\""
    ],
    correctAnswer: "B",
    explanation: "@Override void makeSound() { System.out.println(\"Dog barks\"); }",
    source: "Slide 11",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 801,
    question: "According to the Method Overriding example in the slide, what is the output of a.makeSound() where Animal a = new Dog()?",
    options: [
      "\"Animal sound\"",
      "\"Dog barks\"",
      "\"Cat meows\"",
      "\"Some generic animal sound\""
    ],
    correctAnswer: "B",
    explanation: "Animal a = new Dog(); a.makeSound(); // Output: Dog barks",
    source: "Slide 11",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 802,
    question: "What is the key distinction between Method Overloading and Method Overriding?",
    options: [
      "Subclass overrides method from superclass vs Same class – different parameters",
      "Same class – different parameters vs Subclass overrides method from superclass",
      "No distinction",
      "Both are the same"
    ],
    correctAnswer: "B",
    explanation: "Same class – different parameters vs Subclass overrides method from superclass",
    source: "Slide 11",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 803,
    question: "What is the problem described in Dynamic Dispatch?",
    options: [
      "How does Java decide which version of the method to call given a subclass reference pointing to a superclass object?",
      "Given a superclass reference pointing to a subclass object, how does Java decide which version of the method to call?",
      "How to avoid method calls.",
      "How to delete methods."
    ],
    correctAnswer: "B",
    explanation: "Given a superclass reference pointing to a subclass object, how does Java decide which version of the method to call?",
    source: "Slide 12",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 804,
    question: "What is the answer to how Java calls methods at runtime?",
    options: [
      "Static Method Dispatch",
      "Dynamic Method Dispatch",
      "No dispatch",
      "Compile-time dispatch"
    ],
    correctAnswer: "B",
    explanation: "Answer: Dynamic Method Dispatch",
    source: "Slide 12",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 805,
    question: "At runtime, what does Java use to resolve which method to invoke?",
    options: [
      "The reference type",
      "The actual type of the object",
      "The method name only",
      "The parameters only"
    ],
    correctAnswer: "B",
    explanation: "At runtime, Java uses the actual type of the object to resolve which method to invoke —not the reference type.",
    source: "Slide 12",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 806,
    question: "According to the illustration in the slide, what is the reference type in Animal a = new Dog()?",
    options: [
      "Dog",
      "Animal",
      "Cat",
      "Object"
    ],
    correctAnswer: "B",
    explanation: "Animal a = new Dog(); // reference type: Animal",
    source: "Slide 13",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 807,
    question: "According to the illustration in the slide, what is the actual object in Animal a = new Dog()?",
    options: [
      "Animal",
      "Dog",
      "Cat",
      "Object"
    ],
    correctAnswer: "B",
    explanation: "a.makeSound(); // actual object: Dog",
    source: "Slide 13",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 808,
    question: "In the process of Dynamic Dispatch, what does Java check at runtime?",
    options: [
      "That a refers to an Animal object.",
      "That a refers to a Dog object.",
      "That a refers to a Cat object.",
      "Nothing."
    ],
    correctAnswer: "B",
    explanation: "At runtime, Java checks that a refers to a Dog object.",
    source: "Slide 13",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 809,
    question: "In the process of Dynamic Dispatch, what does Java look up?",
    options: [
      "The overridden version of makeSound() in the Animal class.",
      "The overridden version of makeSound() in the Dog class.",
      "No method.",
      "A different method."
    ],
    correctAnswer: "B",
    explanation: "It looks up the overridden version of makeSound() in the Dog class.",
    source: "Slide 13",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 810,
    question: "In the process of Dynamic Dispatch, what is executed?",
    options: [
      "Animal.makeSound()",
      "Dog.barks()",
      "No method",
      "Different method"
    ],
    correctAnswer: "B",
    explanation: "Dog.barks() is executed.",
    source: "Slide 13",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 811,
    question: "What does each class have in the JVM for method dispatch?",
    options: [
      "A physical table",
      "A virtual method table (vtable)",
      "No table",
      "A static table"
    ],
    correctAnswer: "B",
    explanation: "Each class has a virtual method table (vtable).",
    source: "Slide 14",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 812,
    question: "When a.makeSound() is called, what does the JVM use to find the right method?",
    options: [
      "The vtable of the reference type",
      "The vtable of the actual object type (Dog)",
      "No vtable",
      "A different table"
    ],
    correctAnswer: "B",
    explanation: "When a.makeSound() is called, JVM uses the vtable of the actual object type (Dog) to find the right method.",
    source: "Slide 14",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 813,
    question: "What does the vtable enable?",
    options: [
      "Polymorphism with changing the calling code",
      "Polymorphism without changing the calling code",
      "No polymorphism",
      "Deleting code"
    ],
    correctAnswer: "B",
    explanation: "This enables polymorphism without changing the calling code.",
    source: "Slide 14",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 814,
    question: "What does Dynamic Dispatch allow writing?",
    options: [
      "Inflexible and specific code",
      "Flexible and generic code",
      "No code",
      "Error-prone code"
    ],
    correctAnswer: "B",
    explanation: "Allows writing flexible and generic code",
    source: "Slide 14",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 815,
    question: "What principle does Dynamic Dispatch support?",
    options: [
      "Closed-Open Principle",
      "Open-Closed Principle: open for extension, closed for modification",
      "No principle",
      "Modification Principle"
    ],
    correctAnswer: "B",
    explanation: "Supports Open-Closed Principle: open for extension, closed for modification",
    source: "Slide 14",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 816,
    question: "In the under the hood diagram, how is the reference connected to the object?",
    options: [
      "Animal a ————————————→ new Dog()",
      "Dog a ————————————→ new Animal()",
      "No connection",
      "Animal a → new Animal()"
    ],
    correctAnswer: "A",
    explanation: "[Reference Variable] [Actual Object] Animal a ————————————→ new Dog()",
    source: "Slide 15",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 817,
    question: "In the under the hood diagram, what call is made?",
    options: [
      "Call: a.eat()",
      "Call: a.makeSound()",
      "No call",
      "Call: a.speak()"
    ],
    correctAnswer: "B",
    explanation: "Call: a.makeSound()",
    source: "Slide 15",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 818,
    question: "In the under the hood diagram, what does the JVM check?",
    options: [
      "Actual object type: Animal",
      "Actual object type: Dog",
      "Actual object type: Cat",
      "No check"
    ],
    correctAnswer: "B",
    explanation: "→ Check actual object type: Dog",
    source: "Slide 15",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 819,
    question: "In the under the hood diagram, what does the JVM look up?",
    options: [
      "Vtable for Animal",
      "Vtable for Dog",
      "Vtable for Cat",
      "No lookup"
    ],
    correctAnswer: "B",
    explanation: "→ Look up vtable for Dog",
    source: "Slide 15",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 820,
    question: "In the under the hood diagram, what does the JVM find?",
    options: [
      "Overridden method: Animal.makeSound()",
      "Overridden method: Dog.makeSound()",
      "No method",
      "Different method"
    ],
    correctAnswer: "B",
    explanation: "→ Find overridden method: Dog.makeSound()",
    source: "Slide 15",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 821,
    question: "In the under the hood diagram, what does the JVM execute?",
    options: [
      "\"Animal sound\"",
      "\"Dog barks\"",
      "\"Cat meows\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "→ Execute: \"Dog barks\"",
    source: "Slide 15",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 822,
    question: "Why does this matter in the visualization?",
    options: [
      "You can write code that only works with Dog.",
      "You can write code like: void playSound(Animal a) { a.makeSound(); } and pass in any subclass (Dog, Cat, Cow), and the correct behavior will still happen — without changing this method.",
      "It doesn't matter.",
      "It requires changing the method."
    ],
    correctAnswer: "B",
    explanation: "You can write code like: void playSound(Animal a) { a.makeSound(); } and pass in any subclass (Dog, Cat, Cow), and the correct behavior will still happen —without changing this method.",
    source: "Slide 15",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 823,
    question: "In the comparison table, what is required for virtual keyword in C++?",
    options: [
      "Not needed",
      "Required (virtual)",
      "Optional",
      "Forbidden"
    ],
    correctAnswer: "B",
    explanation: "Virtual keyword Required (virtual) Not needed (default behavior)",
    source: "Slide 16",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 824,
    question: "In the comparison table, what is the virtual keyword in Java?",
    options: [
      "Required (virtual)",
      "Not needed (default behavior)",
      "Optional",
      "Forbidden"
    ],
    correctAnswer: "B",
    explanation: "Virtual keyword Required (virtual) Not needed (default behavior)",
    source: "Slide 16",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 825,
    question: "In the comparison table, what is the default method type in C++?",
    options: [
      "Virtual",
      "Non-virtual",
      "Static",
      "Final"
    ],
    correctAnswer: "B",
    explanation: "Default method type Non-virtual Virtual (unless final, static, private)",
    source: "Slide 16",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 826,
    question: "In the comparison table, what is the default method type in Java?",
    options: [
      "Non-virtual",
      "Virtual (unless final, static, private)",
      "Static",
      "Private"
    ],
    correctAnswer: "B",
    explanation: "Default method type Non-virtual Virtual (unless final, static, private)",
    source: "Slide 16",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 827,
    question: "In the comparison table, when does runtime dispatch occur in C++?",
    options: [
      "Always for overridable methods",
      "Only for virtual methods",
      "Never",
      "For static methods"
    ],
    correctAnswer: "B",
    explanation: "Runtime dispatch Only for virtual methods Always for overridable methods",
    source: "Slide 16",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 828,
    question: "In the comparison table, when does runtime dispatch occur in Java?",
    options: [
      "Only for virtual methods",
      "Always for overridable methods",
      "Never",
      "For private methods"
    ],
    correctAnswer: "B",
    explanation: "Runtime dispatch Only for virtual methods Always for overridable methods",
    source: "Slide 16",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 829,
    question: "In the comparison table, what is the override annotation in C++?",
    options: [
      "Recommended: @Override",
      "Optional (override from C++11)",
      "Required",
      "Not available"
    ],
    correctAnswer: "B",
    explanation: "Override annotation Optional (override from C++11) Recommended: @Override",
    source: "Slide 16",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 830,
    question: "In the comparison table, what is the override annotation in Java?",
    options: [
      "Optional (override from C++11)",
      "Recommended: @Override",
      "Required",
      "Not available"
    ],
    correctAnswer: "B",
    explanation: "Override annotation Optional (override from C++11) Recommended: @Override",
    source: "Slide 16",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 831,
    question: "In the comparison table, what is a common mistake in C++?",
    options: [
      "Rare, polymorphism works by default",
      "Forgetting virtual → no polymorphism",
      "Forgetting @Override",
      "No mistakes"
    ],
    correctAnswer: "B",
    explanation: "Common mistake Forgetting virtual → no polymorphism Rare, polymorphism works by default",
    source: "Slide 16",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 832,
    question: "In the comparison table, what is a common mistake in Java?",
    options: [
      "Forgetting virtual → no polymorphism",
      "Rare, polymorphism works by default",
      "Forgetting extends",
      "Always mistakes"
    ],
    correctAnswer: "B",
    explanation: "Common mistake Forgetting virtual → no polymorphism Rare, polymorphism works by default",
    source: "Slide 16",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 833,
    question: "In the conclusion, what must you do in C++ to enable polymorphism?",
    options: [
      "Nothing, it's default.",
      "Explicitly declare virtual methods to enable polymorphism.",
      "Use @Override.",
      "Avoid virtual."
    ],
    correctAnswer: "B",
    explanation: "In C++, you must explicitly declare virtual methods to enable polymorphism.",
    source: "Slide 16",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 834,
    question: "In the conclusion, how do instance methods behave in Java?",
    options: [
      "All instance methods are non-virtual by default.",
      "All instance methods are virtual by default unless restricted.",
      "No virtual methods.",
      "Only static are virtual."
    ],
    correctAnswer: "B",
    explanation: "In Java, all instance methods are virtual by default unless restricted.",
    source: "Slide 16",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 835,
    question: "What is the first objective in the programming exercise?",
    options: [
      "Practice method overloading",
      "Practice inheritance and method overriding",
      "Practice encapsulation",
      "Practice abstraction"
    ],
    correctAnswer: "B",
    explanation: "Practice inheritance and method overriding",
    source: "Slide 17",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 836,
    question: "What is the second objective in the programming exercise?",
    options: [
      "Use subclass references",
      "Use superclass references to call overridden methods",
      "Avoid methods",
      "Delete classes"
    ],
    correctAnswer: "B",
    explanation: "Use superclass references to call overridden methods",
    source: "Slide 17",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 837,
    question: "What is the third objective in the programming exercise?",
    options: [
      "Understand compile-time decisions",
      "Understand how Java decides which method to execute at runtime",
      "Ignore runtime",
      "Focus on static methods"
    ],
    correctAnswer: "B",
    explanation: "Understand how Java decides which method to execute at runtime",
    source: "Slide 17",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 838,
    question: "What is the fourth objective in the programming exercise?",
    options: [
      "Confuse overriding with overloading",
      "Distinguish method overriding from overloading",
      "Use only overloading",
      "Avoid distinction"
    ],
    correctAnswer: "B",
    explanation: "Distinguish method overriding from overloading",
    source: "Slide 17",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 839,
    question: "What is the program to simulate in the problem statement?",
    options: [
      "A simple animal system",
      "A simple payment system with multiple payment types",
      "A calculator",
      "A game"
    ],
    correctAnswer: "B",
    explanation: "Write a program to simulate a simple payment system with multiple payment types.",
    source: "Slide 18",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 840,
    question: "What is the superclass to define in the problem statement?",
    options: [
      "Animal",
      "Payment",
      "Calculator",
      "Shape"
    ],
    correctAnswer: "B",
    explanation: "Define a superclass Payment:",
    source: "Slide 18",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 841,
    question: "According to the code in the slide, what does the process() method in class Payment print?",
    options: [
      "\"Processing cash payment...\"",
      "\"Processing generic payment...\"",
      "\"Processing credit card payment...\"",
      "\"Processing e-wallet payment...\""
    ],
    correctAnswer: "B",
    explanation: "void process() { System.out.println(\"Processing generic payment...\"); }",
    source: "Slide 18",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 842,
    question: "How many subclasses to create in the problem statement?",
    options: [
      "Two",
      "Three",
      "Four",
      "One"
    ],
    correctAnswer: "B",
    explanation: "Create three subclasses:",
    source: "Slide 19",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 843,
    question: "What does the overridden process() in CashPayment print?",
    options: [
      "\"Processing generic payment...\"",
      "\"Processing cash payment...\"",
      "\"Processing credit card payment...\"",
      "\"Processing e-wallet payment...\""
    ],
    correctAnswer: "B",
    explanation: "CashPayment: overrides process() to print \"Processing cash payment...\"",
    source: "Slide 19",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 844,
    question: "What does the overridden process() in CreditCardPayment print?",
    options: [
      "\"Processing generic payment...\"",
      "\"Processing cash payment...\"",
      "\"Processing credit card payment...\"",
      "\"Processing e-wallet payment...\""
    ],
    correctAnswer: "C",
    explanation: "CreditCardPayment: prints \"Processing credit card payment...\"",
    source: "Slide 19",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 845,
    question: "What does the overridden process() in EWalletPayment print?",
    options: [
      "\"Processing generic payment...\"",
      "\"Processing cash payment...\"",
      "\"Processing credit card payment...\"",
      "\"Processing e-wallet payment...\""
    ],
    correctAnswer: "D",
    explanation: "EWalletPayment: prints \"Processing e-wallet payment...\"",
    source: "Slide 19",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 846,
    question: "In the main method, what should be created?",
    options: [
      "An array of subclass references",
      "An array of Payment references",
      "No array",
      "A list of objects"
    ],
    correctAnswer: "B",
    explanation: "Create an array of Payment references.",
    source: "Slide 19",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 847,
    question: "In the main method, what should each element refer to?",
    options: [
      "The same subclass object",
      "An object of a different subclass",
      "Superclass objects only",
      "No objects"
    ],
    correctAnswer: "B",
    explanation: "Each element should refer to an object of a different subclass.",
    source: "Slide 19",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 848,
    question: "In the main method, what should be done with the array?",
    options: [
      "Delete it",
      "Loop through the array and call process() on each element",
      "Ignore it",
      "Print the array"
    ],
    correctAnswer: "B",
    explanation: "Loop through the array and call process() on each element.",
    source: "Slide 19",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 849,
    question: "According to the example in main, what is the first element in Payment[] payments?",
    options: [
      "new CreditCardPayment()",
      "new CashPayment()",
      "new EWalletPayment()",
      "new Payment()"
    ],
    correctAnswer: "B",
    explanation: "Payment[] payments = { new CashPayment(), new CreditCardPayment(), new EWalletPayment() };",
    source: "Slide 20",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 850,
    question: "According to the example in main, what is the second element in Payment[] payments?",
    options: [
      "new CashPayment()",
      "new CreditCardPayment()",
      "new EWalletPayment()",
      "new Payment()"
    ],
    correctAnswer: "B",
    explanation: "Payment[] payments = { new CashPayment(), new CreditCardPayment(), new EWalletPayment() };",
    source: "Slide 20",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 851,
    question: "According to the example in main, what is the third element in Payment[] payments?",
    options: [
      "new CashPayment()",
      "new CreditCardPayment()",
      "new EWalletPayment()",
      "new Payment()"
    ],
    correctAnswer: "C",
    explanation: "Payment[] payments = { new CashPayment(), new CreditCardPayment(), new EWalletPayment() };",
    source: "Slide 20",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 852,
    question: "What is the loop structure in the example?",
    options: [
      "for (int i = 0; i < payments.length; i++)",
      "for (Payment p : payments) { p.process(); }",
      "while loop",
      "No loop"
    ],
    correctAnswer: "B",
    explanation: "for (Payment p : payments) { p.process(); }",
    source: "Slide 20",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 853,
    question: "What is the first line of expected output?",
    options: [
      "Processing credit card payment...",
      "Processing cash payment...",
      "Processing e-wallet payment...",
      "Processing generic payment..."
    ],
    correctAnswer: "B",
    explanation: "Processing cash payment...",
    source: "Slide 20",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 854,
    question: "What is the second line of expected output?",
    options: [
      "Processing cash payment...",
      "Processing credit card payment...",
      "Processing e-wallet payment...",
      "Processing generic payment..."
    ],
    correctAnswer: "B",
    explanation: "Processing credit card payment...",
    source: "Slide 20",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 855,
    question: "What is the third line of expected output?",
    options: [
      "Processing cash payment...",
      "Processing credit card payment...",
      "Processing e-wallet payment...",
      "Processing generic payment..."
    ],
    correctAnswer: "C",
    explanation: "Processing e-wallet payment...",
    source: "Slide 20",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 856,
    question: "Why does the subclass version of process() get called instead of the superclass version?",
    options: [
      "Because of compile-time resolution",
      "Because of runtime polymorphism and dynamic dispatch",
      "Randomly",
      "Because of static methods"
    ],
    correctAnswer: "B",
    explanation: "Why does the subclass version of process() get called instead of the superclass version?",
    source: "Slide 21",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 857,
    question: "What happens if you forget to use @Override and make a mistake in the method name or parameter list?",
    options: [
      "It still overrides correctly",
      "The method is not overridden, leading to unexpected behavior",
      "Compilation error",
      "No effect"
    ],
    correctAnswer: "B",
    explanation: "What happens if you forget to use @Override and make a mistake in the method name or parameter list?",
    source: "Slide 21",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 858,
    question: "What would happen if process() were declared as static?",
    options: [
      "It would still be polymorphic",
      "It would not be overridden, resolved at compile time based on reference type",
      "It would be abstract",
      "It would be final"
    ],
    correctAnswer: "B",
    explanation: "What would happen if process() were declared as static?",
    source: "Slide 21",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 859,
    question: "What should not be used in the requirements?",
    options: [
      "Concrete classes",
      "Abstract classes or interfaces",
      "Methods",
      "Arrays"
    ],
    correctAnswer: "B",
    explanation: "Do not use abstract classes or interfaces",
    source: "Slide 22",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 860,
    question: "What annotation should be used properly?",
    options: [
      "@Deprecated",
      "@Override",
      "@SuppressWarnings",
      "@FunctionalInterface"
    ],
    correctAnswer: "B",
    explanation: "Use @Override annotation properly",
    source: "Slide 22",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 861,
    question: "What should not be used in the requirements?",
    options: [
      "Overriding",
      "Instanceof or type casting",
      "Loops",
      "Arrays"
    ],
    correctAnswer: "B",
    explanation: "Do not use instanceof or type casting",
    source: "Slide 22",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 862,
    question: "What is the topic on Slide 23?",
    options: [
      "Inheritance vs Polymorphism",
      "Method Modifiers vs Polymorphism",
      "Encapsulation",
      "Abstraction"
    ],
    correctAnswer: "B",
    explanation: "Method Modifiers vs Polymorphism",
    source: "Slide 23",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 863,
    question: "What do static methods belong to?",
    options: [
      "The object",
      "The class, not the object",
      "The instance",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Belong to the class, not the object",
    source: "Slide 24",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 864,
    question: "How are static methods declared?",
    options: [
      "Using final keyword",
      "Using static keyword",
      "Using private keyword",
      "Using protected keyword"
    ],
    correctAnswer: "B",
    explanation: "Declared using static keyword",
    source: "Slide 24",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 865,
    question: "What do static methods belong to?",
    options: [
      "Instances",
      "The class, not instances",
      "Objects only",
      "Subclasses only"
    ],
    correctAnswer: "B",
    explanation: "Belong to the class, not instances",
    source: "Slide 24",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 866,
    question: "Can static methods be overridden?",
    options: [
      "Yes",
      "Cannot be overridden – only hidden",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "Cannot be overridden – only hidden",
    source: "Slide 24",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 867,
    question: "When are static methods resolved?",
    options: [
      "At runtime",
      "At compile time, based on reference type",
      "At load time",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "Resolved at compile time, based on reference type",
    source: "Slide 24",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 868,
    question: "According to the example, what does static void greet() in class A print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "static void greet() { System.out.println(\"A\"); }",
    source: "Slide 25",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 869,
    question: "According to the example, what does static void greet() in class B print?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "static void greet() { System.out.println(\"B\"); }",
    source: "Slide 25",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 870,
    question: "According to the example, what is the output of ref.greet() where A ref = new B()?",
    options: [
      "\"B\"",
      "\"A\"",
      "Nothing",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "Aref = new B(); ref.greet(); // Output: A",
    source: "Slide 25",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 871,
    question: "Why does ref.greet() call A.greet()?",
    options: [
      "Because ref is of type B",
      "Because ref is of type A",
      "Randomly",
      "Because it's overridden"
    ],
    correctAnswer: "B",
    explanation: "Explanation: ref.greet() calls A.greet() because ref is of type A.",
    source: "Slide 25",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 872,
    question: "What are private methods in subclasses?",
    options: [
      "Visible and overridden",
      "Completely hidden from subclasses",
      "Partially visible",
      "Always overridden"
    ],
    correctAnswer: "B",
    explanation: "Completely hidden from subclasses",
    source: "Slide 26",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 873,
    question: "Are private methods inherited?",
    options: [
      "Yes",
      "Private methods are not inherited",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "private methods are not inherited",
    source: "Slide 26",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 874,
    question: "Can private methods be overridden?",
    options: [
      "Yes",
      "Cannot be overridden",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "Cannot be overridden",
    source: "Slide 26",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 875,
    question: "What is a same-named method in subclass for private methods?",
    options: [
      "Overridden method",
      "A new method",
      "Hidden method",
      "Deleted method"
    ],
    correctAnswer: "B",
    explanation: "Same-named method in subclass is a new method",
    source: "Slide 26",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 876,
    question: "Where are private methods not visible?",
    options: [
      "Inside the class",
      "Not visible outside the class",
      "In subclasses only",
      "Everywhere"
    ],
    correctAnswer: "B",
    explanation: "Not visible outside the class",
    source: "Slide 26",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 877,
    question: "According to the example, what does private void show() in class A print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "private void show() { System.out.println(\"A\"); }",
    source: "Slide 27",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 878,
    question: "What does public void callShow() in class A do?",
    options: [
      "Nothing",
      "show();",
      "callOwnShow();",
      "print(\"A\")"
    ],
    correctAnswer: "B",
    explanation: "public void callShow() { show(); }",
    source: "Slide 27",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 879,
    question: "According to the example, what does private void show() in class B print?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "private void show() { System.out.println(\"B\"); }",
    source: "Slide 27",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 880,
    question: "What does public void callOwnShow() in class B do?",
    options: [
      "Nothing",
      "show();",
      "callShow();",
      "print(\"B\")"
    ],
    correctAnswer: "B",
    explanation: "public void callOwnShow() { show(); }",
    source: "Slide 27",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 881,
    question: "According to the example, what is the output of obj.callShow() where B obj = new B()?",
    options: [
      "\"B\"",
      "\"A\"",
      "Nothing",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "obj.callShow(); // Output: A",
    source: "Slide 27",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 882,
    question: "According to the example, what is the output of obj.callOwnShow() where B obj = new B()?",
    options: [
      "\"A\"",
      "\"B\"",
      "Nothing",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "obj.callOwnShow(); // Output: B",
    source: "Slide 27",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 883,
    question: "What do protected methods support?",
    options: [
      "No polymorphism",
      "Polymorphism – with access restrictions",
      "Only compile-time polymorphism",
      "Static polymorphism"
    ],
    correctAnswer: "B",
    explanation: "Supports polymorphism – with access restrictions",
    source: "Slide 28",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 884,
    question: "Ar e protected methods inherited and overridable?",
    options: [
      "No",
      "Protected methods are inherited and can be overridden",
      "Inherited but not overridable",
      "Overridable but not inherited"
    ],
    correctAnswer: "B",
    explanation: "protected methods are inherited and can be overridden",
    source: "Slide 28",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 885,
    question: "Do protected methods participate in runtime polymorphism?",
    options: [
      "No",
      "Fully participate in runtime polymorphism",
      "Partially",
      "Only in compile-time"
    ],
    correctAnswer: "B",
    explanation: "Fully participate in runtime polymorphism",
    source: "Slide 28",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 886,
    question: "From wher e can protected methods be accessed?",
    options: [
      "Only from unrelated classes",
      "From: Subclasses (even across packages) and Classes in the same package",
      "Nowhere",
      "Only within the class"
    ],
    correctAnswer: "B",
    explanation: "But: can only be accessed from: Subclasses (even across packages) and Classes in the same package",
    source: "Slide 28",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 887,
    question: "Can protected methods be accessed by unr elated classes in other packages?",
    options: [
      "Yes",
      "Cannot be accessed by unrelated unrelated classes in other packages",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "Cannot be accessed by unrelated unrelated classes in other packages",
    source: "Slide 28",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 888,
    question: "According to the example, what does protected void dr aw() in class A print?",
    options: [
      "\"Draw B\"",
      "\"Draw A\"",
      "\"Draw C\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "protected void draw() { System.out.println(\"Draw A\"); }",
    source: "Slide 29",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 889,
    question: "According to the example, what does overridden protected void dr aw() in class B print?",
    options: [
      "\"Draw A\"",
      "\"Draw B\"",
      "\"Draw C\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "@Override protected void draw() { System.out.println(\"Draw B\"); }",
    source: "Slide 29",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 890,
    question: "According to the example, what is the output of r ef.dr aw() wher e A r ef = new B()?",
    options: [
      "\"Draw A\"",
      "\"Draw B\"",
      "Nothing",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "Aref = new B(); ref.draw(); // Output: Draw B",
    source: "Slide 29",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 891,
    question: "What occurs in the protected method example?",
    options: [
      "Static dispatch",
      "Dynamic dispatch occurs: the method in B is invoked",
      "No dispatch",
      "Compile-time error"
    ],
    correctAnswer: "B",
    explanation: "Explanation: Dynamic dispatch occurs: the method in B is invoked.",
    source: "Slide 29",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 892,
    question: "According to the cross-package example, what does protected void speak() in package p1 class A print?",
    options: [
      "\"B\"",
      "\"A\"",
      "Nothing",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "protected void speak() { System.out.println(\"A\"); }",
    source: "Slide 30",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 893,
    question: "In the cross-package example in package p2, what happens when calling a.speak() wher e A a = new A()?",
    options: [
      "Prints \"A\"",
      "Compile-time error",
      "Prints \"B\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "a.speak(); // ❌ Compile-time error",
    source: "Slide 30",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 894,
    question: "In the cross-package example, why is speak() not accessible?",
    options: [
      "It is accessible outside p1",
      "Speak() is inherited but not accessible outside p1 unless from a subclass",
      "It is not inherited",
      "It is private"
    ],
    correctAnswer: "B",
    explanation: "Explanation: speak() is inherited but not accessible outside p1 unless from a subclass.",
    source: "Slide 30",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 895,
    question: "What is the cross-package example about?",
    options: [
      "Polymorphism itself",
      "Access control, not about polymorphism itself",
      "Deletion",
      "No access"
    ],
    correctAnswer: "B",
    explanation: "This is about access control, not about polymorphism itself.",
    source: "Slide 30",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 896,
    question: "In the summary table, is private inherited?",
    options: [
      "Yes",
      "No",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "❌ No",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 897,
    question: "In the summary table, is private overridable?",
    options: [
      "Yes",
      "No",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "❌ No",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 898,
    question: "In the summary table, is private polymorphic?",
    options: [
      "Yes",
      "No",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "❌ No",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 899,
    question: "In the summary table, is private accessible from subclass?",
    options: [
      "Yes",
      "No",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "❌ No",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 900,
    question: "In the summary table, is private accessible from unrelated class?",
    options: [
      "Yes",
      "No",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "❌ No",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 901,
    question: "In the summary table, is protected inherited?",
    options: [
      "No",
      "Yes",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "✅ Yes",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 902,
    question: "In the summary table, is protected overridable?",
    options: [
      "No",
      "Yes",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "✅ Yes",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 903,
    question: "In the summary table, is protected polymorphic?",
    options: [
      "No",
      "Yes",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "✅ Yes",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 904,
    question: "In the summary table, is protected accessible from subclass?",
    options: [
      "No",
      "Yes",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "✅ Yes",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 905,
    question: "In the summary table, is protected accessible from unrelated class?",
    options: [
      "Yes",
      "No (unless in same package)",
      "Always",
      "Sometimes"
    ],
    correctAnswer: "B",
    explanation: "❌ No (unless in same package)",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 906,
    question: "In the summary table, is public inherited?",
    options: [
      "No",
      "Yes",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "✅ Yes",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 907,
    question: "In the summary table, is public overridable?",
    options: [
      "No",
      "Yes",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "✅ Yes",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 908,
    question: "In the summary table, is public polymorphic?",
    options: [
      "No",
      "Yes",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "✅ Yes",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 909,
    question: "In the summary table, is public accessible from subclass?",
    options: [
      "No",
      "Yes",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "✅ Yes",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 910,
    question: "In the summary table, is public accessible from unrelated class?",
    options: [
      "No",
      "Yes",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "✅ Yes",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 911,
    question: "In the summary table, is static inherited?",
    options: [
      "No",
      "Yes (usable)",
      "No",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "✅ (usable)",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 912,
    question: "In the summary table, is static overridable?",
    options: [
      "Yes",
      "No (hidden only)",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "❌ No (hidden only)",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 913,
    question: "In the summary table, is static polymorphic?",
    options: [
      "Yes",
      "No",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "❌ No",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 914,
    question: "In the summary table, is static accessible from subclass?",
    options: [
      "No",
      "Yes (via class name)",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "✅ Yes (via class name)",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 915,
    question: "In the summary table, is static accessible from unrelated class?",
    options: [
      "No",
      "Yes",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "✅ Yes",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 916,
    question: "What ar e static methods not?",
    options: [
      "Yes",
      "Polymorphic – they are resolved at compile time and can be hidden, not overridden",
      "Overridable",
      "Usable"
    ],
    correctAnswer: "B",
    explanation: "Note: static methods are not polymorphic – they are resolved at compile time and can be hidden, not overridden.",
    source: "Slide 31",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 917,
    question: "What is the topic on Slide 32?",
    options: [
      "Concrete Class for Polymorphism",
      "Abstract Class for Polymorphism",
      "Interface for Polymorphism",
      "Final Class"
    ],
    correctAnswer: "B",
    explanation: "Abstract Class for Polymorphism",
    source: "Slide 32",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 918,
    question: "What is an abstr act class?",
    options: [
      "A base class with complete implementation",
      "A base class with incomplete implementation",
      "A final class",
      "A static class"
    ],
    correctAnswer: "B",
    explanation: "Abase class with incomplete implementation",
    source: "Slide 33",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 919,
    question: "How is an abstr act class declar ed?",
    options: [
      "With final keyword",
      "With abstract keyword",
      "With static keyword",
      "With private keyword"
    ],
    correctAnswer: "B",
    explanation: "Declared with abstract keyword",
    source: "Slide 33",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 920,
    question: "Can an abstr act class be instantiated?",
    options: [
      "Yes",
      "Cannot be instantiated",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "Cannot be instantiated",
    source: "Slide 33",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 921,
    question: "What may an abstr act class include?",
    options: [
      "No abstract methods",
      "Abstract and non-abstract methods",
      "No non-abstract methods",
      "No methods"
    ],
    correctAnswer: "B",
    explanation: "May include abstract and non-abstract methods",
    source: "Slide 33",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 922,
    question: "What is an abstr act class used as?",
    options: [
      "A concrete superclass",
      "A polymorphic superclass",
      "A final class",
      "A standalone class"
    ],
    correctAnswer: "B",
    explanation: "Used as a polymorphic superclass",
    source: "Slide 33",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 923,
    question: "What must subclasses do with abstr act methods?",
    options: [
      "Ignore abstract methods",
      "Override abstract methods",
      "Delete them",
      "Hide them"
    ],
    correctAnswer: "B",
    explanation: "Subclasses must override abstract methods",
    source: "Slide 33",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 924,
    question: "According to the code example, what is declar ed in abstr act class Animal?",
    options: [
      "void speak()",
      "abstract void speak();",
      "static void speak();",
      "final void speak();"
    ],
    correctAnswer: "B",
    explanation: "abstract class Animal { abstract void speak(); }",
    source: "Slide 34",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 925,
    question: "According to the code example, what does void speak() in class Dog print?",
    options: [
      "\"Cat meows\"",
      "\"Dog barks\"",
      "\"Animal speaks\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "class Dog extends Animal { void speak() { System.out.println(\"Dog barks\"); } }",
    source: "Slide 34",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 926,
    question: "In the code example, what is Animal a = new Dog(); followed by?",
    options: [
      "a.eat();",
      "a.speak(); // Output: Dog barks",
      "a.makeSound();",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Animal a = new Dog(); a.speak(); // Output: Dog barks",
    source: "Slide 34",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 927,
    question: "What occurs in the abstract method example?",
    options: [
      "Concrete base type",
      "Animal is an abstract base type. Dog provides implementation → enables runtime polymorphism",
      "A final base type",
      "No type"
    ],
    correctAnswer: "B",
    explanation: "Explanation: Animal is an abstract base type. Dog provides implementation → enables runtime polymorphism.",
    source: "Slide 34",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 928,
    question: "What is the first r eason to use abstr act classes?",
    options: [
      "Allow incomplete behavior",
      "Enforce common behavior through contracts",
      "Prevent behavior",
      "Delete methods"
    ],
    correctAnswer: "B",
    explanation: "1. Enforce common behavior through contracts",
    source: "Slide 35",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 929,
    question: "What do abstr act methods define?",
    options: [
      "Optional behaviors",
      "Required behaviors. Subclasses must implement them",
      "No behaviors",
      "Hidden behaviors"
    ],
    correctAnswer: "B",
    explanation: "Abstract methods define required behaviors. Subclasses must implement them.",
    source: "Slide 35",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 930,
    question: "In the code example for r eason 1, what is declar ed in abstr act class Animal?",
    options: [
      "void speak();",
      "abstract void speak();",
      "static void speak();",
      "final void speak();"
    ],
    correctAnswer: "B",
    explanation: "abstract class Animal { abstract void speak(); }",
    source: "Slide 35",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 931,
    question: "In the subclass example for r eason 1, what does void speak() in class Cat print?",
    options: [
      "\"Dog barks\"",
      "\"Meow\"",
      "\"Animal speaks\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "class Cat extends Animal { void speak() { System.out.println(\"Meow\"); } }",
    source: "Slide 35",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 932,
    question: "What is the second r eason to use abstr act classes?",
    options: [
      "Prevent runtime polymorphism",
      "Enable runtime polymorphism",
      "Enable compile-time only",
      "Disable polymorphism"
    ],
    correctAnswer: "B",
    explanation: "2. Enable runtime polymorphism",
    source: "Slide 36",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 933,
    question: "How can abstr act classes be used?",
    options: [
      "As concrete base types",
      "As polymorphic base types",
      "As final types",
      "No use"
    ],
    correctAnswer: "B",
    explanation: "Abstract classes can be used as polymorphic base types.",
    source: "Slide 36",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 934,
    question: "In the code example for r eason 2, what is Animal a = new Cat(); followed by?",
    options: [
      "a.eat();",
      "a.speak(); // Output: Meow",
      "a.makeSound();",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Animal a = new Cat(); a.speak(); // Output: Meow",
    source: "Slide 36",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 935,
    question: "What can you write using super class r efer ences?",
    options: [
      "Specific-purpose code",
      "General-purpose code using superclass references for dynamic dispatch",
      "No code",
      "Error code"
    ],
    correctAnswer: "B",
    explanation: "Write general-purpose code using superclass references.",
    source: "Slide 36",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 936,
    question: "What is the third r eason to use abstr act classes?",
    options: [
      "Prevent partial implementation reuse",
      "Allow partial implementation reuse",
      "Delete concrete methods",
      "Ignore methods"
    ],
    correctAnswer: "B",
    explanation: "3. Allow partial implementation reuse",
    source: "Slide 37",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 937,
    question: "What can abstr act classes include?",
    options: [
      "No concrete methods",
      "Concrete methods",
      "No methods",
      "Only fields"
    ],
    correctAnswer: "B",
    explanation: "Abstract classes can include concrete methods.",
    source: "Slide 37",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 938,
    question: "In the code example, what does void eat() print?",
    options: [
      "\"Animal speaks\"",
      "\"Animal eats\"",
      "\"Dog barks\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "void eat() { System.out.println(\"Animal eats\"); }",
    source: "Slide 37",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 939,
    question: "What else is in the abstr act class in the example?",
    options: [
      "void speak();",
      "abstract void speak();",
      "static void speak();",
      "final void speak();"
    ],
    correctAnswer: "B",
    explanation: "abstract void speak();",
    source: "Slide 37",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 940,
    question: "What can subclasses do with non-abstr act methods?",
    options: [
      "Must override non-abstract methods",
      "Reuse non-abstract methods without overriding",
      "Delete them",
      "Hide them"
    ],
    correctAnswer: "B",
    explanation: "Important: Subclasses can reuse non-abstract methods without overriding.",
    source: "Slide 37",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 941,
    question: "What is the fourth r eason to use abstr act classes?",
    options: [
      "Prevent creation of incomplete types",
      "Prevent creation of incomplete types",
      "Enforce a constructor structure for all subclasses",
      "Enable code reuse during object creation"
    ],
    correctAnswer: "B",
    explanation: "4. Prevent creation of incomplete types",
    source: "Slide 38",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 942,
    question: "What cannot you do with abstr act classes?",
    options: [
      "No objects from abstract classes",
      "Create objects from abstract classes",
      "Create subclasses",
      "Override methods"
    ],
    correctAnswer: "B",
    explanation: "You cannot create objects from abstract classes.",
    source: "Slide 38",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 943,
    question: "What happens with Animal a = new Animal()?",
    options: [
      "Successful",
      "// ❌ Compile-time error",
      "Runtime error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Animal a = new Animal(); // ❌ Compile-time error",
    source: "Slide 38",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 944,
    question: "What does pr eventing instantiation ensur e?",
    options: [
      "Incomplete subclasses are instantiated",
      "Only fully implemented subclasses are instantiated",
      "No instantiation",
      "All classes are instantiated"
    ],
    correctAnswer: "B",
    explanation: "This ensures only fully implemented subclasses are instantiated.",
    source: "Slide 38",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 945,
    question: "What is the fifth r eason to use abstr act classes?",
    options: [
      "Enforce behavior",
      "Provide a consistent base for future extension",
      "Reuse logic",
      "Design consistency"
    ],
    correctAnswer: "B",
    explanation: "5. Provide a consistent base for future extension",
    source: "Slide 39",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 946,
    question: "What do abstr act classes define?",
    options: [
      "No structure",
      "A common structure. Useful for organizing code and maintaining hierarchy",
      "Random structure",
      "Deleted code"
    ],
    correctAnswer: "B",
    explanation: "Abstract classes define a common structure. Useful for organizing code and maintaining hierarchy.",
    source: "Slide 39",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 947,
    question: "In the code example for r eason 5, what is in abstr act class Shape?",
    options: [
      "void area();",
      "abstract double area();",
      "static double area();",
      "final double area();"
    ],
    correctAnswer: "B",
    explanation: "abstract class Shape { abstract double area(); }",
    source: "Slide 39",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 948,
    question: "What will futur e classes like Cir cle, Rectangle, etc., follow?",
    options: [
      "Different designs",
      "The same base design",
      "No design",
      "Deleted design"
    ],
    correctAnswer: "B",
    explanation: "Future classes like Circle, Rectangle, etc., will follow the same base design.",
    source: "Slide 39",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 949,
    question: "In the summary table, what is Reason 1?",
    options: [
      "Polymorphic base",
      "Enforce behavior",
      "Reuse logic",
      "Prevent incomplete instantiation"
    ],
    correctAnswer: "B",
    explanation: "1. Enforce behavior",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 950,
    question: "In the summary table, what must subclasses do for Reason 1?",
    options: [
      "Ignore methods",
      "Subclasses must implement required methods",
      "Delete methods",
      "Hide methods"
    ],
    correctAnswer: "B",
    explanation: "1. Enforce behavior Subclasses must implement required methods",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 951,
    question: "In the summary table, what is the example for Reason 1?",
    options: [
      "Animal a = new Dog();",
      "abstract void speak();",
      "void eat() { ... }",
      "new Animal(); // ❌"
    ],
    correctAnswer: "B",
    explanation: "abstract void speak();",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 952,
    question: "In the summary table, what is Reason 2?",
    options: [
      "Enforce behavior",
      "Polymorphic base",
      "Reuse logic",
      "Design consistency"
    ],
    correctAnswer: "B",
    explanation: "2. Polymorphic base",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 953,
    question: "In the summary table, how is Reason 2 used?",
    options: [
      "With subclass references",
      "Used with superclass references for dynamic dispatch",
      "No dispatch",
      "Static dispatch"
    ],
    correctAnswer: "B",
    explanation: "2. Polymorphic base Used with superclass references for dynamic dispatch",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 954,
    question: "In the summary table, what is the example for Reason 2?",
    options: [
      "abstract void speak();",
      "Animal a = new Dog();",
      "void eat() { ... }",
      "abstract class Shape { ... }"
    ],
    correctAnswer: "B",
    explanation: "Animal a = new Dog();",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 955,
    question: "In the summary table, what is Reason 3?",
    options: [
      "Prevent incomplete instantiation",
      "Reuse logic",
      "Enforce behavior",
      "Design consistency"
    ],
    correctAnswer: "B",
    explanation: "3. Reuse logic",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 956,
    question: "In the summary table, what does Reason 3 shar e?",
    options: [
      "No methods",
      "Share common methods across subclasses",
      "Abstract methods only",
      "Deleted methods"
    ],
    correctAnswer: "B",
    explanation: "3. Reuse logic Share common methods across subclasses",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 957,
    question: "In the summary table, what is the example for Reason 3?",
    options: [
      "Animal a = new Dog();",
      "void eat() { ... }",
      "new Animal(); // ❌",
      "abstract class Shape { ... }"
    ],
    correctAnswer: "B",
    explanation: "void eat() { ... }",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 958,
    question: "In the summary table, what is Reason 4?",
    options: [
      "Reuse logic",
      "Prevent incomplete instantiation",
      "Polymorphic base",
      "Design consistency"
    ],
    correctAnswer: "B",
    explanation: "4. Prevent incomplete instantiation",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 959,
    question: "In the summary table, what cannot be done for Reason 4?",
    options: [
      "Create objects from concrete types",
      "Cannot create objects from abstract types",
      "Create subclasses",
      "Override methods"
    ],
    correctAnswer: "B",
    explanation: "4. Prevent incomplete instantiation Cannot create objects from abstract types",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 960,
    question: "In the summary table, what is the example for Reason 4?",
    options: [
      "abstract void speak();",
      "Animal a = new Dog();",
      "new Animal(); // ❌",
      "abstract class Shape { ... }"
    ],
    correctAnswer: "C",
    explanation: "new Animal(); // ❌",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 961,
    question: "In the summary table, what is Reason 5?",
    options: [
      "Enforce behavior",
      "Design consistency",
      "Reuse logic",
      "Polymorphic base"
    ],
    correctAnswer: "B",
    explanation: "5. Design consistency",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 962,
    question: "In the summary table, what does Reason 5 define?",
    options: [
      "No structure",
      "Define structure for future extensions",
      "Delete structure",
      "Ignore extensions"
    ],
    correctAnswer: "B",
    explanation: "5. Design consistency Define structure for future extensions abstract class Shape { ... }",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 963,
    question: "In the summary table, what is the example for Reason 5?",
    options: [
      "void eat() { ... }",
      "abstract class Shape { ... }",
      "new Animal(); // ❌",
      "Animal a = new Dog();"
    ],
    correctAnswer: "B",
    explanation: "abstract class Shape { ... }",
    source: "Slide 40",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 964,
    question: "What is the topic on Slide 41?",
    options: [
      "Detailed Abstract Class Characteristics in Java",
      "Detailed Abstract Class Characteristics in Java",
      "Interface Characteristics",
      "Concrete Class"
    ],
    correctAnswer: "B",
    explanation: "Detailed Abstract Class Characteristics in Java",
    source: "Slide 41",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 965,
    question: "What is an abstr act class in J ava?",
    options: [
      "A class that can be instantiated",
      "A class that cannot be instantiated",
      "A final class",
      "A static class"
    ],
    correctAnswer: "B",
    explanation: "Aclass that cannot be instantiated",
    source: "Slide 42",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 966,
    question: "How is an abstr act class declar ed?",
    options: [
      "No keyword",
      "With the abstract keyword",
      "With the static keyword",
      "No keyword"
    ],
    correctAnswer: "B",
    explanation: "Declared with the abstract keyword",
    source: "Slide 42",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 967,
    question: "What may an abstr act class contain?",
    options: [
      "No methods",
      "Abstract and non-abstract methods",
      "No non-abstract methods",
      "No methods"
    ],
    correctAnswer: "B",
    explanation: "May contain abstract and non-abstract methods",
    source: "Slide 42",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 968,
    question: "Can an abstr act class be instantiated dir ectly?",
    options: [
      "Yes",
      "Cannot be instantiated directly",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "Cannot be instantiated directly",
    source: "Slide 42",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 969,
    question: "What is an abstr act class intended to be?",
    options: [
      "Standalone",
      "Subclassed",
      "Deleted",
      "Ignored"
    ],
    correctAnswer: "B",
    explanation: "Intended to be subclassed",
    source: "Slide 42",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 970,
    question: "In the code example, what is in abstr act class Animal?",
    options: [
      "void speak();",
      "abstract void speak();",
      "static void speak();",
      "final void speak();"
    ],
    correctAnswer: "B",
    explanation: "abstract class Animal { abstract void speak(); }",
    source: "Slide 42",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 971,
    question: "What is an abstr act method?",
    options: [
      "Method with implementation",
      "Method without implementation",
      "Static method",
      "Final method"
    ],
    correctAnswer: "B",
    explanation: "Definition: Method without implementation",
    source: "Slide 43",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 972,
    question: "How is an abstr act method declar ed?",
    options: [
      "Using final keyword",
      "Using abstract keyword",
      "Using static keyword",
      "No keyword"
    ],
    correctAnswer: "B",
    explanation: "Declared using abstract keyword",
    source: "Slide 43",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 973,
    question: "How does an abstr act method end?",
    options: [
      "With a body {}",
      "With ; instead of method body",
      "With return",
      "With throw"
    ],
    correctAnswer: "B",
    explanation: "Ends with ; instead of method body",
    source: "Slide 43",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 974,
    question: "Wher e must an abstr act method be implemented?",
    options: [
      "In the abstract class",
      "In concrete subclass",
      "Nowhere",
      "In interface"
    ],
    correctAnswer: "B",
    explanation: "Must be implemented in concrete subclass",
    source: "Slide 43",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 975,
    question: "In the code example, what is in abstr act class Animal?",
    options: [
      "void speak();",
      "abstract void speak();",
      "static void speak();",
      "final void speak();"
    ],
    correctAnswer: "B",
    explanation: "abstract class Animal { abstract void speak(); }",
    source: "Slide 43",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 976,
    question: "What is the rule for instantiating abstr act class?",
    options: [
      "You can create instances directly",
      "You can only create instances of concrete subclasses",
      "No instances",
      "Only abstract instances"
    ],
    correctAnswer: "B",
    explanation: "You can only create instances of concrete subclasses.",
    source: "Slide 44",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 977,
    question: "What happens with Animal a = new Animal()?",
    options: [
      "Successful",
      "// ❌ Compile-time error",
      "Runtime error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Animal a = new Animal(); // ❌ Compile-time error",
    source: "Slide 44",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 978,
    question: "What must a subclass do with abstr act methods?",
    options: [
      "Ignore abstract methods",
      "Implement abstract methods",
      "Delete them",
      "Hide them"
    ],
    correctAnswer: "B",
    explanation: "3. Subclass Must Implement Abstract Methods",
    source: "Slide 45",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 979,
    question: "In the implementation example, what does class Dog extend?",
    options: [
      "Object",
      "Animal",
      "Cat",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "class Dog extends Animal { void speak() { System.out.println(\"Dog barks\"); } }",
    source: "Slide 45",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 980,
    question: "If a subclass does not implement all abstr act methods, what must it be?",
    options: [
      "Concrete",
      "Declared abstract",
      "Final",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "Note: If a subclass does not implement all abstract methods, it must also be declared abstract",
    source: "Slide 45",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 981,
    question: "If a subclass does not implement all abstr act methods and is not abstr act, what happens?",
    options: [
      "Successful",
      "You get a compile-time error",
      "Runtime error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Otherwise, you get a compile-time error",
    source: "Slide 46",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 982,
    question: "In the code example, what is missing in class Dog?",
    options: [
      "extends Animal",
      "// Missing speak()",
      "Constructor",
      "Fields"
    ],
    correctAnswer: "B",
    explanation: "class Dog extends Animal { // Missing speak() }",
    source: "Slide 46",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 983,
    question: "What happens with Dog d = new Dog() when speak() is missing?",
    options: [
      "Successful",
      "// ❌ Compile-time error",
      "Runtime error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Dog d = new Dog(); // ❌ Compile-time error",
    source: "Slide 46",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 984,
    question: "What is Fix 1 when subclass doesn't implement all abstr act methods?",
    options: [
      "Declare subclass as abstract",
      "Implement the method",
      "Delete the class",
      "Add static"
    ],
    correctAnswer: "B",
    explanation: "Fix 1: Implement the method class Dog extends Animal { void speak() { System.out.println(\"Dog barks\"); } }",
    source: "Slide 46",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 985,
    question: "What is Fix 2 when subclass doesn't implement all abstr act methods?",
    options: [
      "Implement the method",
      "Declare subclass as abstract",
      "Add final",
      "Ignore"
    ],
    correctAnswer: "B",
    explanation: "Fix 2: Declare subclass as abstract abstract class Dog extends Animal { // Still valid }",
    source: "Slide 46",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 986,
    question: "What can abstr act classes contain?",
    options: [
      "No abstract and concrete methods",
      "Both abstract and concrete methods",
      "No concrete methods",
      "No methods"
    ],
    correctAnswer: "B",
    explanation: "Abstract classes can contain both abstract and concrete methods.",
    source: "Slide 47",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 987,
    question: "In the code example, what does void eat() print?",
    options: [
      "\"Animal speaks\"",
      "\"Animal eats\"",
      "\"Dog barks\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "void eat() { System.out.println(\"Animal eats\"); }",
    source: "Slide 47",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 988,
    question: "What else is in the abstr act class in the example?",
    options: [
      "void speak();",
      "abstract void speak();",
      "static void speak();",
      "final void speak();"
    ],
    correctAnswer: "B",
    explanation: "abstract void speak();",
    source: "Slide 47",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 989,
    question: "What can subclasses do with non-abstr act methods?",
    options: [
      "Must override non-abstract methods",
      "Reuse non-abstract methods without overriding",
      "Delete them",
      "Hide them"
    ],
    correctAnswer: "B",
    explanation: "Important: Subclasses can reuse non-abstract methods without overriding.",
    source: "Slide 47",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 990,
    question: "What can abstr act classes have?",
    options: [
      "No fields or constructors",
      "Fields and Constructors",
      "Only fields",
      "Only constructors"
    ],
    correctAnswer: "B",
    explanation: "5. Abstract Class Can Have Fields and Constructors",
    source: "Slide 48",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 991,
    question: "In the code example, what field is in abstr act class Animal?",
    options: [
      "int name;",
      "String name;",
      "double name;",
      "No field"
    ],
    correctAnswer: "B",
    explanation: "String name;",
    source: "Slide 48",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 992,
    question: "In the code example, what does Animal(String name) do?",
    options: [
      "this.name = \" Animal\" ;",
      "this.name = name;",
      "Nothing",
      "super(name);"
    ],
    correctAnswer: "B",
    explanation: "Animal(String name) { this.name = name; }",
    source: "Slide 48",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 993,
    question: "How ar e constructors used in abstr act classes?",
    options: [
      "Not used",
      "Constructors are used by subclasses during instantiation",
      "Only for abstract methods",
      "Deleted"
    ],
    correctAnswer: "B",
    explanation: "Note: Constructors are used by subclasses during instantiation.",
    source: "Slide 48",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 994,
    question: "Do abstr act classes have constructors?",
    options: [
      "No",
      "Yes. Abstract classes can and often should have constructors",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "Answer: Yes. Abstract classes can and often should have constructors.",
    source: "Slide 49",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 995,
    question: "What is the purpose of constructors in abstr act classes?",
    options: [
      "To delete fields",
      "Constructors are used to initialize fields and shared logic",
      "No purpose",
      "To override methods"
    ],
    correctAnswer: "B",
    explanation: "Constructors are used to initialize fields and shared logic",
    source: "Slide 49",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 996,
    question: "When ar e abstr act class constructors called?",
    options: [
      "Never",
      "They are called when a subclass is instantiated",
      "When abstract is instantiated",
      "At compile time"
    ],
    correctAnswer: "B",
    explanation: "They are called when a subclass is instantiated",
    source: "Slide 49",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 997,
    question: "In the code example, what field is in abstr act class Animal?",
    options: [
      "int name;",
      "String name;",
      "double name;",
      "No field"
    ],
    correctAnswer: "B",
    explanation: "String name;",
    source: "Slide 49",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 998,
    question: "What does the constructor in abstr act class Animal print?",
    options: [
      "\"Dog constructor\"",
      "\"Animal constructor\"",
      "\"Cat constructor\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Animal(String name) { this.name = name; System.out.println(\"Animal constructor\"); }",
    source: "Slide 49",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 999,
    question: "In the subclass implementation, what does Dog(String name) call?",
    options: [
      "this(name)",
      "super(name);",
      "Nothing",
      "print(\" Dog\" )"
    ],
    correctAnswer: "B",
    explanation: "Dog(String name) { super(name); System.out.println(\"Dog constructor\"); }",
    source: "Slide 50",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1000,
    question: "What is Dog d = new Dog(\"Max\" );?",
    options: [
      "No output",
      "Calls constructors with output",
      "Error",
      "Deletes object"
    ],
    correctAnswer: "B",
    explanation: "Dog d = new Dog(\"Max\");",
    source: "Slide 50",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1001,
    question: "What is the first output in the constructor flow example?",
    options: [
      "Dog constructor",
      "Animal constructor",
      "Max",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Output: Animal constructor Dog constructor",
    source: "Slide 50",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1002,
    question: "What is the second output in the constructor flow example?",
    options: [
      "Animal constructor",
      "Dog constructor",
      "Max",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Output: Animal constructor Dog constructor",
    source: "Slide 50",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1003,
    question: "When cr eating a subclass object, what is called first?",
    options: [
      "Subclass constructor",
      "Abstract class constructor is always called first",
      "No constructor",
      "Random"
    ],
    correctAnswer: "B",
    explanation: "Key Point: Abstract class constructor is always called first when creating a subclass object.",
    source: "Slide 50",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1004,
    question: "What is invalid for constructors?",
    options: [
      "Normal constructor",
      "Abstract constructor",
      "Static constructor",
      "Final constructor"
    ],
    correctAnswer: "B",
    explanation: "// abstract A(); ❌ Compile-time error",
    source: "Slide 51",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1005,
    question: "What cannot constructors be?",
    options: [
      "Inherited or overridden",
      "Called",
      "Initialized",
      "Used"
    ],
    correctAnswer: "A",
    explanation: "Rule: Constructors cannot be abstract —they are not inherited or overridden.",
    source: "Slide 51",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1006,
    question: "Even though abstr act classes cannot be instantiated dir ectly, why have constructors?",
    options: [
      "No, they are useless",
      "But their constructors are still useful",
      "To cause errors",
      "To delete fields"
    ],
    correctAnswer: "B",
    explanation: "But their constructors are still useful",
    source: "Slide 52",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1007,
    question: "What is Animal a = new Animal()?",
    options: [
      "Successful",
      "// ❌ Compile-time error",
      "Runtime",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Animal a = new Animal(); // ❌ Compile-time error",
    source: "Slide 52",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1008,
    question: "When ar e constructors called in abstr act classes?",
    options: [
      "Never",
      "Constructors are called when a subclass object is created",
      "When abstract is created",
      "At compile time"
    ],
    correctAnswer: "B",
    explanation: "Constructors are called when a subclass object is created",
    source: "Slide 52",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1009,
    question: "What do constructors ensur e in abstr act classes?",
    options: [
      "Nothing",
      "The abstract class can initialize shared fields or run common setup logic",
      "Errors",
      "Deletion"
    ],
    correctAnswer: "B",
    explanation: "This ensures that the abstract class can initialize shared fields or run common setup logic",
    source: "Slide 52",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1010,
    question: "What is the first main purpose of abstr act class constructors?",
    options: [
      "Delete inherited fields",
      "Provide initial values for inherited fields",
      "No purpose",
      "Override methods"
    ],
    correctAnswer: "B",
    explanation: "Provide initial values for inherited fields",
    source: "Slide 53",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1011,
    question: "What is the second main purpose of abstr act class constructors?",
    options: [
      "Allow flexible structure",
      "Enforce a constructor structure for all subclasses",
      "Prevent structure",
      "Ignore subclasses"
    ],
    correctAnswer: "B",
    explanation: "Enforce a constructor structure for all subclasses",
    source: "Slide 53",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1012,
    question: "What is the third main purpose of abstr act class constructors?",
    options: [
      "Prevent code reuse",
      "Enable code reuse during object creation",
      "Delete code",
      "No reuse"
    ],
    correctAnswer: "B",
    explanation: "Enable code reuse during object creation",
    source: "Slide 53",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1013,
    question: "In the example for purposes, what field is in abstr act class Animal?",
    options: [
      "int name;",
      "String name;",
      "double name;",
      "No field"
    ],
    correctAnswer: "B",
    explanation: "String name;",
    source: "Slide 53",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1014,
    question: "In the example, what does Animal(String name) do first?",
    options: [
      "System.out.println(\" Animal constructor \" );",
      "this.name = name;",
      "super(name);",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Animal(String name) { this.name = name; System.out.println(\"Animal constructor\"); }",
    source: "Slide 53",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1015,
    question: "In the subclass implementation, what does Dog(String name) call?",
    options: [
      "this(name)",
      "super(name);",
      "Nothing",
      "print(\" Dog\" )"
    ],
    correctAnswer: "B",
    explanation: "Dog(String name) { super(name); System.out.println(\"Dog constructor\"); }",
    source: "Slide 53",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1016,
    question: "What is Dog d = new Dog(\"Max\" );?",
    options: [
      "No output",
      "Calls constructors with output",
      "Error",
      "Deletes object"
    ],
    correctAnswer: "B",
    explanation: "Dog d = new Dog(\"Max\");",
    source: "Slide 53",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1017,
    question: "What is the first output in the purposes example?",
    options: [
      "Dog constructor",
      "Animal constructor",
      "Max",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "// Output: // Animal constructor // Dog constructor",
    source: "Slide 53",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1018,
    question: "What is the second output in the purposes example?",
    options: [
      "Animal constructor",
      "Dog constructor",
      "Max",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "// Output: // Animal constructor // Dog constructor",
    source: "Slide 53",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1019,
    question: "Can a r egular class have abstr act methods?",
    options: [
      "Yes",
      "No. Only abstract classes can declare abstract methods",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "Answer: No. Only abstract classes can declare abstract methods.",
    source: "Slide 54",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1020,
    question: "What must r egular classes provide?",
    options: [
      "Incomplete implementations",
      "Full method implementations",
      "No methods",
      "Abstract methods"
    ],
    correctAnswer: "B",
    explanation: "Regular (non-abstract) classes must provide full method implementations.",
    source: "Slide 54",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1021,
    question: "In the invalid example, what is in class Animal?",
    options: [
      "void speak();",
      "abstract void speak(); // ❌ Compile-time error",
      "static void speak();",
      "final void speak();"
    ],
    correctAnswer: "B",
    explanation: "abstract void speak(); // ❌ Compile-time error",
    source: "Slide 54",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1022,
    question: "What is the compiler error for r egular class with abstr act method?",
    options: [
      "No error",
      "modifier 'abstract' not allowed here",
      "Runtime error",
      "Syntax error"
    ],
    correctAnswer: "B",
    explanation: "Compiler error: modifier 'abstract' not allowed here",
    source: "Slide 54",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1023,
    question: "What is Option 1 to fix r egular class with abstr act method?",
    options: [
      "Provide method body",
      "Make the Class Abstract",
      "Delete the method",
      "Add static"
    ],
    correctAnswer: "B",
    explanation: "Option 1: Make the Class Abstract abstract class Animal { abstract void speak(); }",
    source: "Slide 54",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1024,
    question: "What is Option 2 to fix r egular class with abstr act method?",
    options: [
      "Make class abstract",
      "Provide Method Body",
      "Add final",
      "Ignore"
    ],
    correctAnswer: "B",
    explanation: "Option 2: Provide Method Body class Animal { void speak() { System.out.println(\"Animal speaks\"); } }",
    source: "Slide 54",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1025,
    question: "Why is a r egular class with abstr act method invalid?",
    options: [
      "A regular class must be fully implemented",
      "A regular class must be fully implemented",
      "Regular classes cannot have methods",
      "No reason"
    ],
    correctAnswer: "B",
    explanation: "Aregular class must be fully implemented",
    source: "Slide 54",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1026,
    question: "Why else is it invalid?",
    options: [
      "Abstract methods have body",
      "Abstract methods have no body",
      "Bodies are optional",
      "No body needed"
    ],
    correctAnswer: "B",
    explanation: "Abstract methods have no body",
    source: "Slide 54",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1027,
    question: "Who can contain abstr act methods?",
    options: [
      "Regular classes",
      "Only abstract classes are allowed to contain them",
      "Final classes",
      "Static classes"
    ],
    correctAnswer: "B",
    explanation: "Only abstract classes are allowed to contain them",
    source: "Slide 54",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1028,
    question: "In the r equir ed case, what field is in abstr act class Animal?",
    options: [
      "int name;",
      "String name;",
      "double name;",
      "No field"
    ],
    correctAnswer: "B",
    explanation: "String name;",
    source: "Slide 55",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1029,
    question: "In the r equir ed case, what does Animal(String name) print?",
    options: [
      "\"Dog: \" + name",
      "\"Animal: \" + name",
      "\"Cat: \" + name",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Animal(String name) { this.name = name; System.out.println(\"Animal: \" + name); }",
    source: "Slide 55",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1030,
    question: "In the r equir ed case, what does Dog() call?",
    options: [
      "super();",
      "super(\" Dog\" ); // ✅ Requir ed",
      "this(\" Dog\" );",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Dog() { super(\"Dog\"); // ✅ Required System.out.println(\"Dog created\"); }",
    source: "Slide 55",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1031,
    question: "Why is super r equir ed?",
    options: [
      "There is a default constructor in Animal",
      "No default constructor in Animal",
      "Always required",
      "Never required"
    ],
    correctAnswer: "B",
    explanation: "// ✅ Required: no default constructor in Animal",
    source: "Slide 55",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1032,
    question: "What is the output when cr eating Dog?",
    options: [
      "Dog created",
      "Animal: Dog",
      "Nothing",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "Output: Animal: Dog Dog created",
    source: "Slide 55",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1033,
    question: "What is the second output when cr eating Dog?",
    options: [
      "Animal: Dog",
      "Dog created",
      "Nothing",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "Output: Animal: Dog Dog created",
    source: "Slide 55",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1034,
    question: "In the optional case, what does Animal() print?",
    options: [
      "\"Cat created\"",
      "\"Animal created\"",
      "\"Dog created\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Animal() { System.out.println(\"Animal created\"); }",
    source: "Slide 56",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1035,
    question: "In the optional case, what is in Cat()?",
    options: [
      "super(); // ✅ Optional",
      "super(\"Cat\" );",
      "this();",
      "Nothing required"
    ],
    correctAnswer: "A",
    explanation: "Cat() { // super(); // ✅ Optional: compiler adds it automatically System.out.println(\"Cat created\"); }",
    source: "Slide 56",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1036,
    question: "What does the compiler do if super() is not written?",
    options: [
      "Error",
      "Compiler adds it automatically",
      "Ignores",
      "Deletes"
    ],
    correctAnswer: "B",
    explanation: "// ✅ Optional: compiler adds it automatically",
    source: "Slide 56",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1037,
    question: "What is the first output in optional case?",
    options: [
      "Cat created",
      "Animal created",
      "Nothing",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "Output: Animal created Cat created",
    source: "Slide 56",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1038,
    question: "What is the second output in optional case?",
    options: [
      "Animal created",
      "Cat created",
      "Nothing",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "Output: Animal created Cat created",
    source: "Slide 56",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1039,
    question: "In the error case, what does Animal(String name) print?",
    options: [
      "\"Dog\"",
      "\"Animal: \" + name",
      "\"Cat constructor\"",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Animal(String name) { System.out.println(\"Animal: \" + name); }",
    source: "Slide 57",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1040,
    question: "In the error case, what is missing in Dog()?",
    options: [
      "// No call to super(...)",
      "// No call to super(...)",
      "super(\" Dog\" );",
      "this();",
      "print(\" Animal\" )"
    ],
    correctAnswer: "A",
    explanation: "Dog() { // No call to super(...) System.out.println(\"Dog\"); }",
    source: "Slide 57",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1041,
    question: "What is the compiler error in the missing super case?",
    options: [
      "No error",
      "constructor Animal in class Animal cannot be applied to given types; required: String found: no arguments",
      "Runtime error",
      "Syntax error"
    ],
    correctAnswer: "B",
    explanation: "Compiler Error: constructor Animal in class Animal cannot be applied to given types; required: String found: no arguments",
    source: "Slide 57",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1042,
    question: "What does the compiler do if super() is not written?",
    options: [
      "Error",
      "Java automatically inserts super() if you don't write it",
      "No super needed",
      "Always error"
    ],
    correctAnswer: "B",
    explanation: "Java automatically inserts super() if you don't write it",
    source: "Slide 57",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1043,
    question: "Why does the error happen?",
    options: [
      "Animal has default constructor",
      "But Animal has no default (no-arg) constructor",
      "Animal has arg constructor",
      "No constructor"
    ],
    correctAnswer: "B",
    explanation: "But Animal has no default (no-arg) constructor",
    source: "Slide 57",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1044,
    question: "What cannot the compiler find?",
    options: [
      "No matching constructor",
      "A matching constructor",
      "The method",
      "The class"
    ],
    correctAnswer: "B",
    explanation: "So the compiler cannot find a matching constructor",
    source: "Slide 57",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1045,
    question: "How to fix the missing super error ?",
    options: [
      "Do nothing",
      "Explicitly call superclass constructor",
      "Delete subclass",
      "Make abstract"
    ],
    correctAnswer: "B",
    explanation: "Dog() { super(\"Dog\"); // ✅ explicitly call superclass constructor System.out.println(\"Dog\"); }",
    source: "Slide 57",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1046,
    question: "What is a common misconception about abstr act classes?",
    options: [
      "Abstract classes have constructors",
      "Abstract classes don't have constructors",
      "Constructors are called",
      "Can instantiate"
    ],
    correctAnswer: "B",
    explanation: "Abstract classes don't have constructors Abstract classes can have constructors to initialize shared fields",
    source: "Slide 58",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1047,
    question: "What is the clarification for the first misconception?",
    options: [
      "Abstract classes don't have constructors",
      "Abstract classes can have constructors to initialize shared fields",
      "No constructors",
      "Delete constructors"
    ],
    correctAnswer: "B",
    explanation: "Abstract classes don't have constructors Abstract classes can have constructors to initialize shared fields",
    source: "Slide 58",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1048,
    question: "What is the second common misconception?",
    options: [
      "Abstract class constructors are called",
      "Abstract class constructors are never called",
      "They are called",
      "Always called"
    ],
    correctAnswer: "B",
    explanation: "Abstract class constructors are never called Their constructors are called first when a subclass object is created",
    source: "Slide 58",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1049,
    question: "What is the clarification for the second misconception?",
    options: [
      "Never called",
      "Their constructors are called first when a subclass object is created",
      "Called last",
      "No call"
    ],
    correctAnswer: "B",
    explanation: "Abstract class constructors are never called Their constructors are called first when a subclass object is created",
    source: "Slide 58",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1050,
    question: "What is the third common misconception?",
    options: [
      "Cannot create object",
      "You can create an object from an abstract class",
      "Instantiate directly",
      "No object"
    ],
    correctAnswer: "B",
    explanation: "You can create an object from an abstract class You cannot instantiate an abstract class directly",
    source: "Slide 58",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1051,
    question: "What is the clarification for the third misconception?",
    options: [
      "You can instantiate directly",
      "You cannot instantiate an abstract class directly",
      "Always instantiate",
      "Sometimes"
    ],
    correctAnswer: "B",
    explanation: "You can create an object from an abstract class You cannot instantiate an abstract class directly",
    source: "Slide 58",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1052,
    question: "What is the fourth common misconception?",
    options: [
      "Constructors cannot be abstract",
      "Constructors can be declared abstract",
      "Can be final",
      "Can be static"
    ],
    correctAnswer: "B",
    explanation: "Constructors can be declared abstract Invalid —constructors cannot be abstract, final, or static",
    source: "Slide 58",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1053,
    question: "What is the clarification for the fourth misconception?",
    options: [
      "Can be abstract",
      "Invalid — constructors cannot be abstract, final, or static",
      "Always abstract",
      "Optional"
    ],
    correctAnswer: "B",
    explanation: "Constructors can be declared abstract Invalid —constructors cannot be abstract, final, or static",
    source: "Slide 58",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1054,
    question: "In the example, what is Animal a = new Dog(); followed by?",
    options: [
      "a.eat();",
      "a.speak(); // Output: Dog barks",
      "a.makeSound();",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "Animal a = new Dog(); a.speak(); // Output: Dog barks",
    source: "Slide 59",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1055,
    question: "What does using abstr act base type enable?",
    options: [
      "Compile-time polymorphism",
      "Runtime polymorphism using abstract base type",
      "No polymorphism",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "Key Point: Enables runtime polymorphism using abstract base type.",
    source: "Slide 59",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1056,
    question: "What are some modifiers not allowed with?",
    options: [
      "Concrete methods",
      "Abstract methods",
      "Fields",
      "Classes"
    ],
    correctAnswer: "B",
    explanation: "Some modifiers are not allowed with abstract methods.",
    source: "Slide 60",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1057,
    question: "Why are abstract methods meant to be overridden?",
    options: [
      "They are final",
      "They must be inheritable and non-final",
      "Not inheritable",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "• Abstract methods are meant to be overridden in subclasses • Therefore, they must be inheritable and non-final",
    source: "Slide 60",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1058,
    question: "What do some modifiers do with abstract purpose?",
    options: [
      "Support it",
      "Conflict with this purpose",
      "No effect",
      "Delete it"
    ],
    correctAnswer: "B",
    explanation: "• Some modifiers conflict with this purpose",
    source: "Slide 60",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1059,
    question: "Is private allowed with abstract?",
    options: [
      "Yes",
      "// abstract private void f(); ❌",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "// abstract private void f(); ❌",
    source: "Slide 61",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1060,
    question: "Why is private not allowed with abstract?",
    options: [
      "Private methods are inherited",
      "Private methods are not inherited • So they cannot be overridden",
      "Can be overridden",
      "No reason"
    ],
    correctAnswer: "B",
    explanation: "• private methods are not inherited • So they cannot be overridden • → Cannot be declared abstract",
    source: "Slide 61",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1061,
    question: "Is static allowed with abstract?",
    options: [
      "Yes",
      "// abstract static void g(); ❌",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "// abstract static void g(); ❌",
    source: "Slide 62",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1062,
    question: "Why is static not allowed with abstract?",
    options: [
      "Static methods belong to object",
      "Static methods belong to the class, not the object • They are not inherited polymorphically",
      "Inherited polymorphically",
      "No reason"
    ],
    correctAnswer: "B",
    explanation: "• static methods belong to the class, not the object • They are not inherited polymorphically • → Cannot be abstract",
    source: "Slide 62",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1063,
    question: "Is final allowed with abstract?",
    options: [
      "Yes",
      "// abstract final void h(); ❌",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "// abstract final void h(); ❌",
    source: "Slide 63",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1064,
    question: "Why is final not allowed with abstract?",
    options: [
      "Final methods can be overridden",
      "Final methods cannot be overridden • Abstract methods must be overridden",
      "No contradiction",
      "They are the same"
    ],
    correctAnswer: "B",
    explanation: "• final methods cannot be overridden • abstract methods must be overridden • → The two are contradictory",
    source: "Slide 63",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1065,
    question: "What is a valid abstract method declaration?",
    options: [
      "abstract private void draw();",
      "abstract void draw();",
      "abstract static void draw();",
      "abstract final void draw();"
    ],
    correctAnswer: "B",
    explanation: "abstract void draw();",
    source: "Slide 64",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1066,
    question: "Why is the valid example valid?",
    options: [
      "Method is: private, final, static",
      "Method is: public (or protected), non-final, non-static",
      "Invalid",
      "No reason"
    ],
    correctAnswer: "B",
    explanation: "• This is valid • Method is: public (or protected), non-final, non-static",
    source: "Slide 64",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1067,
    question: "In the rule summary, is private allowed with abstract?",
    options: [
      "✅ Yes",
      "❌ No",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "private ❌ No Not inherited → can't override",
    source: "Slide 65",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1068,
    question: "Why private not?",
    options: [
      "Inherited",
      "Not inherited → can't override",
      "Can override",
      "No why"
    ],
    correctAnswer: "B",
    explanation: "private ❌ No Not inherited → can't override",
    source: "Slide 65",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1069,
    question: "In the rule summary, is static allowed with abstract?",
    options: [
      "✅ Yes",
      "❌ No",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "static ❌ No Belongs to class, not instance",
    source: "Slide 65",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1070,
    question: "Why static not?",
    options: [
      "Belongs to instance",
      "Belongs to class, not instance",
      "Instance method",
      "No why"
    ],
    correctAnswer: "B",
    explanation: "static ❌ No Belongs to class, not instance",
    source: "Slide 65",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1071,
    question: "In the rule summary, is final allowed with abstract?",
    options: [
      "✅ Yes",
      "❌ No",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "final ❌ No Can't override final methods",
    source: "Slide 65",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1072,
    question: "Why final not?",
    options: [
      "Can override final",
      "Can't override final methods",
      "Must override final",
      "No why"
    ],
    correctAnswer: "B",
    explanation: "final ❌ No Can't override final methods",
    source: "Slide 65",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1073,
    question: "In the rule summary, is native allowed with abstract?",
    options: [
      "✅ Yes",
      "❌ No",
      "Sometimes",
      "Always"
    ],
    correctAnswer: "B",
    explanation: "native ❌ No Requires body; abstract has none",
    source: "Slide 65",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1074,
    question: "Why native not?",
    options: [
      "No body required",
      "Requires body; abstract has none",
      "Has body",
      "No why"
    ],
    correctAnswer: "B",
    explanation: "native ❌ No Requires body; abstract has none",
    source: "Slide 65",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1075,
    question: "In the rule summary, is public allowed with abstract?",
    options: [
      "❌ No",
      "✅ Yes",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "public ✅ Yes Common for API-level override",
    source: "Slide 65",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1076,
    question: "Why public yes?",
    options: [
      "Rare for override",
      "Common for API-level override",
      "No override",
      "No why"
    ],
    correctAnswer: "B",
    explanation: "public ✅ Yes Common for API-level override",
    source: "Slide 65",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1077,
    question: "In the rule summary, is protected allowed with abstract?",
    options: [
      "❌ No",
      "✅ Yes",
      "Sometimes",
      "Never"
    ],
    correctAnswer: "B",
    explanation: "protected ✅ Yes Inherited within hierarchy",
    source: "Slide 65",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1078,
    question: "Why protected yes?",
    options: [
      "Not inherited",
      "Inherited within hierarchy",
      "No hierarchy",
      "No why"
    ],
    correctAnswer: "B",
    explanation: "protected ✅ Yes Inherited within hierarchy",
    source: "Slide 65",
    topic: "Polymorphism & Abstract Classes"
  },
  {
    id: 1079,
    question: "What is an interface in object-oriented programming?",
    options: [
      "A complete class with full method implementations.",
      "A contract that specifies a set of methods (and optionally constants) that a class must implement.",
      "A way to define object state with instance variables.",
      "A mechanism to restrict access to class members."
    ],
    correctAnswer: "B",
    explanation: "B is correct as it matches the exact definition of an interface as a contract for methods and constants. Ais incorrect because interfaces generally do not provide method bodies (except for default methods in Java 8+). C is wrong because interfaces do not model object state with instance fields. D is misleading as interfaces promote public contracts, not restrictions.",
    source: "Page 2",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1080,
    question: "What does an interface define for an object?",
    options: [
      "How the object performs its actions in detail.",
      "What an object can do, without specifying how it does it.",
      "The memory allocation for the object's fields.",
      "The constructors required to create the object."
    ],
    correctAnswer: "B",
    explanation: "B is correct because interfaces focus on the \"what\" (capabilities) rather than the \"how\" (implementation). Ais wrong as that would be the role of concrete classes. C is incorrect since interfaces do not deal with memory or instance fields. D is false because interfaces have no constructors.",
    source: "Page 2",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1081,
    question: "What do interfaces promote in object-oriented programming?",
    options: [
      "Tight coupling and direct inheritance.",
      "Abstraction and polymorphism.",
      "Static memory management.",
      "Single-threaded execution."
    ],
    correctAnswer: "B",
    explanation: "B is correct as interfaces enable abstraction (hiding details) and polymorphism (multiple implementations). Ais wrong because interfaces promote loose coupling. C is unrelated to interfaces. D is incorrect as interfaces do not address threading.",
    source: "Page 2",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1082,
    question: "What do interfaces allow in languages like Java regarding inheritance?",
    options: [
      "Multiple inheritance of implementation.",
      "Multiple inheritance of type.",
      "Single inheritance of constants only.",
      "No inheritance at all."
    ],
    correctAnswer: "B",
    explanation: "B is correct because classes can implement multiple interfaces, inheriting types but not implementations. A is wrong as Java does not allow multiple class inheritance. C is misleading as constants are part of it but not the only aspect. D is false since interfaces support type inheritance.",
    source: "Page 2",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1083,
    question: "According to the example in the slide, what is the syntax for declaring a PaymentMethod interface?",
    options: [
      "public class PaymentMethod { void pay(double amount); }",
      "public interface PaymentMethod { void pay(double amount); }",
      "abstract class PaymentMethod { void pay(double amount); }",
      "public PaymentMethod { void pay(double amount); }"
    ],
    correctAnswer: "B",
    explanation: "B is correct as it matches the example syntax for an interface declaration. Ais wrong because it uses \"class\" instead of \"interface\". C is incorrect as it uses \"abstract class\". D lacks the \"interface\" keyword.",
    source: "Page 2",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1084,
    question: "In terms of method implementation, what is allowed in interfaces compared to abstract classes?",
    options: [
      "Interfaces can have concrete methods; abstract classes cannot.",
      "No method body (Java < 8); default/static methods allowed (Java ≥ 8) in interfaces, while abstract classes can have both abstract and concrete methods.",
      "Interfaces always have full method bodies; abstract classes do not.",
      "Both only allow abstract methods without bodies."
    ],
    correctAnswer: "B",
    explanation: "B is correct as it directly compares the feature from the table. Ais wrong because abstract classes can have concrete methods. C is incorrect as interfaces primarily have abstract methods. D is false for both.",
    source: "Page 3",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1085,
    question: "What types of fields are allowed in interfaces compared to abstract classes?",
    options: [
      "Interfaces allow instance variables; abstract classes only constants.",
      "Public static final constants only in interfaces, while abstract classes allow instance variables and constants.",
      "Both allow only instance variables.",
      "Neither allows any fields."
    ],
    correctAnswer: "B",
    explanation: "B is correct based on the table comparison. Ais reversed. C is wrong as interfaces do not allow instance variables. D is false.",
    source: "Page 3",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1086,
    question: "How does inheritance differ between interfaces and abstract classes?",
    options: [
      "A class can extend multiple abstract classes but implement only one interface.",
      "A class can implement multiple interfaces, but extend only one abstract class.",
      "Both allow multiple extension.",
      "Neither allows any inheritance."
    ],
    correctAnswer: "B",
    explanation: "B is correct as per the table, addressing Java's single class inheritance limit. A is reversed. C is wrong for abstract classes. D is false.",
    source: "Page 3",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1087,
    question: "What is the primary purpose of an interface compared to an abstract class?",
    options: [
      "Provide a partial implementation in interfaces; define a capability in abstract classes.",
      "Define a capability or role in interfaces; provide a partial implementation in abstract classes.",
      "Both are used only for full implementations.",
      "Interfaces for shared code; abstract classes for contracts."
    ],
    correctAnswer: "B",
    explanation: "B is correct from the table. Ais reversed. C is wrong as neither is for full implementation. D is also reversed.",
    source: "Page 3",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1088,
    question: "According to the tip, when should you use an interface over an abstract class?",
    options: [
      "When you need shared code.",
      "When you only need a contract.",
      "When you require multiple inheritance of implementation.",
      "When defining instance variables."
    ],
    correctAnswer: "B",
    explanation: "B is correct as the tip emphasizes contracts for interfaces. Ais for abstract classes. C is not possible in Java. D is for abstract classes.",
    source: "Page 3",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1089,
    question: "According to the design tip, when should you use an interface?",
    options: [
      "When you need shared code like common fields or method implementations.",
      "When you only need a contract (what the class must do, without implementation details).",
      "When you want to restrict multiple inheritance.",
      "For defining concrete classes directly."
    ],
    correctAnswer: "B",
    explanation: "B is correct as it matches the tip for interfaces. Ais for abstract classes. C is wrong as interfaces allow multiple. D is unrelated.",
    source: "Page 4",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1090,
    question: "According to the design tip, when should you use an abstract class?",
    options: [
      "When you only need a contract without any shared elements.",
      "When you need shared code (common fields or method implementations).",
      "For defining capabilities without any state.",
      "To allow multiple extension by classes."
    ],
    correctAnswer: "B",
    explanation: "B is correct as the tip highlights shared code for abstract classes. Ais for interfaces. C is more for interfaces. D is wrong as abstract classes limit to single extension.",
    source: "Page 4",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1091,
    question: "According to the example, what does the Drawable interface represent?",
    options: [
      "A specific shape with color and position.",
      "Any object that can be drawn.",
      "A class with shared methods like move().",
      "An abstract class for storing attributes."
    ],
    correctAnswer: "B",
    explanation: "B is correct as the example uses it for a capability. Aand D are for abstract classes like Shape. C is partial, but the example is for interface.",
    source: "Page 4",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1092,
    question: "According to the example, what does the abstract class Shape provide?",
    options: [
      "Only a contract for drawing without any attributes.",
      "Stores common attributes like color, position and provides shared methods such as move().",
      "Multiple inheritance capabilities.",
      "Static constants only."
    ],
    correctAnswer: "B",
    explanation: "B is correct matching the example for shared elements in abstract class. Ais for interfaces. C is for interfaces. D is incomplete.",
    source: "Page 4",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1093,
    question: "What keyword do classes use to implement an interface?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Classes use implements keyword to implement an interface.",
    source: "Page 5",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1094,
    question: "What must a class provide when implementing an interface?",
    options: [
      "Only the constants defined in the interface.",
      "Concrete definitions for all abstract methods.",
      "Constructors for the interface.",
      "Private fields matching the interface."
    ],
    correctAnswer: "B",
    explanation: "Must provide concrete definitions for all abstract methods.",
    source: "Page 5",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1095,
    question: "Can a class implement multiple interfaces?",
    options: [
      "No, only one interface per class.",
      "Yes, a class can implement multiple interfaces.",
      "Only if the interfaces extend each other.",
      "Only in abstract classes."
    ],
    correctAnswer: "B",
    explanation: "Can implement multiple interfaces.",
    source: "Page 5",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1096,
    question: "In the MediaDevice class example, what does the play method print?",
    options: [
      "Recording media...",
      "Playing media...",
      "Stopping media...",
      "Pausing media..."
    ],
    correctAnswer: "B",
    explanation: "@Override public void play() { System.out.println(\"Playing media...\"); }",
    source: "Page 6",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1097,
    question: "What can a class do regarding multiple interfaces?",
    options: [
      "Extend multiple interfaces but not implement them.",
      "Implement more than one interface.",
      "Only implement one if they have conflicting methods.",
      "Ignore abstract methods from additional interfaces."
    ],
    correctAnswer: "B",
    explanation: "Aclass can implement more than one interface.",
    source: "Page 6",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1098,
    question: "What must a class do when implementing multiple interfaces?",
    options: [
      "Implement only the methods from the first interface.",
      "Implement all abstract methods from all interfaces.",
      "Declare itself abstract if methods conflict.",
      "Use extends for additional interfaces."
    ],
    correctAnswer: "B",
    explanation: "Must implement all abstract methods from all interfaces.",
    source: "Page 6",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1099,
    question: "According to the example, what methods are defined in Playable and Recordable interfaces?",
    options: [
      "Playable: void record(); Recordable: void play();",
      "Playable: void play(); Recordable: void record();",
      "Playable: void stop(); Recordable: void pause();",
      "Playable: void load(); Recordable: void save();"
    ],
    correctAnswer: "B",
    explanation: "public interface Playable { void play(); } public interface Recordable { void record(); }",
    source: "Page 6",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1100,
    question: "What do multiple interfaces promote?",
    options: [
      "Rigidity and code duplication.",
      "Flexibility and code reusability.",
      "Tight coupling between classes.",
      "Limitation to single inheritance."
    ],
    correctAnswer: "B",
    explanation: "Promotes flexibility and code reusability.",
    source: "Page 7",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1101,
    question: "How do multiple interfaces support inheritance in Java?",
    options: [
      "They allow multiple inheritance of implementation.",
      "They support multiple inheritance of type (overcomes single inheritance limitation).",
      "They restrict to single type inheritance.",
      "They prevent any type of inheritance."
    ],
    correctAnswer: "B",
    explanation: "Supports multiple inheritance of type (overcomes single inheritance limitation).",
    source: "Page 7",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1102,
    question: "What should be done with method name conflicts in multiple interfaces?",
    options: [
      "Ignore them as they resolve automatically.",
      "Resolve explicitly in implementation.",
      "Declare the class abstract to avoid.",
      "Remove one of the interfaces."
    ],
    correctAnswer: "B",
    explanation: "Beware of method name conflicts —must resolve explicitly in implementation.",
    source: "Page 7",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1103,
    question: "Where are multiple interfaces commonly used in Java?",
    options: [
      "In primitive type definitions.",
      "In Java event handling and framework design.",
      "For static field management.",
      "In constructor overloading."
    ],
    correctAnswer: "B",
    explanation: "Common in Java event handling and framework design.",
    source: "Page 7",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1104,
    question: "What is the basic syntax for declaring an interface in Java?",
    options: [
      "public class PaymentMethod { void pay(double amount); }",
      "[public] interface InterfaceName [extends OtherInterface1, OtherInterface2] { }",
      "abstract class PaymentMethod { void pay(double amount); }",
      "public PaymentMethod { void pay(double amount); }"
    ],
    correctAnswer: "B",
    explanation: "[public] interface InterfaceName [extends OtherInterface1, OtherInterface2] { // constants (implicit public static final) // abstract methods (implicit public abstract) // (Java ≥ 8) default & static methods // (Java ≥ 9) private methods }",
    source: "Page 8",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1105,
    question: "What access levels can top-level interfaces have?",
    options: [
      "Private or protected.",
      "Public or package-private (no keyword).",
      "Protected only.",
      "Private only."
    ],
    correctAnswer: "B",
    explanation: "Top-level interfaces can be public or package-private (no keyword).",
    source: "Page 8",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1106,
    question: "Can an interface extend multiple other interfaces?",
    options: [
      "No, only one.",
      "Yes, an interface can extend multiple interfaces (type inheritance between interfaces).",
      "Only if they are abstract classes.",
      "Interfaces cannot extend anything."
    ],
    correctAnswer: "B",
    explanation: "An interface can extend multiple interfaces (type inheritance between interfaces).",
    source: "Page 8",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1107,
    question: "Are interfaces implicitly abstract?",
    options: [
      "No, they are concrete.",
      "Yes, interfaces are implicitly abstract; they define contracts, not construction.",
      "Only if marked with abstract keyword.",
      "They are instantiable."
    ],
    correctAnswer: "B",
    explanation: "Interfaces are implicitly abstract; they define contracts, not construction.",
    source: "Page 8",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1108,
    question: "What are the characteristics of fields in an interface?",
    options: [
      "They can be instance variables without initialization.",
      "All fields are implicitly public static final and must be initialized.",
      "They are private by default.",
      "No fields are allowed."
    ],
    correctAnswer: "B",
    explanation: "Constants: all fields are implicitly public static final and must be initialized.",
    source: "Page 9",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1109,
    question: "What is the implicit modifier for abstract methods in an interface?",
    options: [
      "Private abstract.",
      "Public abstract; no body.",
      "Protected.",
      "Static."
    ],
    correctAnswer: "B",
    explanation: "Abstract methods: implicitly public abstract; no body.",
    source: "Page 9",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1110,
    question: "When were default methods introduced and what do they provide?",
    options: [
      "Java < 8; mandatory behavior.",
      "Java ≥ 8; have a body; provide optional behavior.",
      "Java ≥ 9; hidden from implementers.",
      "Always; for static utilities."
    ],
    correctAnswer: "B",
    explanation: "Default methods (Java ≥ 8): have a body; provide optional behavior.",
    source: "Page 9",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1111,
    question: "What are static methods in interfaces used for?",
    options: [
      "Instance-specific behavior.",
      "Utility methods on the interface type itself.",
      "Overridable in classes.",
      "Private helpers."
    ],
    correctAnswer: "B",
    explanation: "Static methods (Java ≥ 8): utility methods on the interface type itself.",
    source: "Page 9",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1112,
    question: "What are private methods in interfaces and when introduced?",
    options: [
      "Public helpers; Java ≥ 8.",
      "Helpers used by default methods; not visible to implementers; Java ≥ 9.",
      "Overridable; Java < 8.",
      "For constants; always."
    ],
    correctAnswer: "B",
    explanation: "Private methods (Java ≥ 9): helpers used by default methods; not visible to implementers.",
    source: "Page 9",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1113,
    question: "What is not allowed in interfaces regarding constructors and fields?",
    options: [
      "Abstract methods.",
      "No constructors, no instance fields (interfaces don't model object state).",
      "Default methods.",
      "Static methods."
    ],
    correctAnswer: "B",
    explanation: "No constructors, no instance fields (interfaces don't model object state).",
    source: "Page 9",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1114,
    question: "In the Logger interface example, what is the declaration of DEFAULT_LEVEL?",
    options: [
      "private int DEFAULT_LEVEL = 1000;",
      "int DEFAULT_LEVEL = 1000; // public static final",
      "static int DEFAULT_LEVEL;",
      "final int DEFAULT_LEVEL;"
    ],
    correctAnswer: "B",
    explanation: "int DEFAULT_LEVEL = 1000; // public static final",
    source: "Page 9",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1115,
    question: "In the Logger interface example, what is the declaration of log method?",
    options: [
      "default void log(String msg);",
      "void log(String msg); // public abstract",
      "static void log(String msg);",
      "private void log(String msg);"
    ],
    correctAnswer: "B",
    explanation: "void log(String msg); // public abstract",
    source: "Page 9",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1116,
    question: "According to the Logger example, what does the info method do?",
    options: [
      "log(\"[ERROR] \" + msg);",
      "log(\"[INFO] \" + msg);",
      "log(msg + \"[INFO]\");",
      "log(msg);"
    ],
    correctAnswer: "B",
    explanation: "default void info(String msg) { log(\"[INFO] \" + msg); } // Java ≥ 8",
    source: "Page 9",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1117,
    question: "In the Logger example, what does the static join method return?",
    options: [
      "a - b",
      "a + b",
      "b + a",
      "a * b"
    ],
    correctAnswer: "B",
    explanation: "static String join(String a, String b) { return a + b; } // Java ≥ 8",
    source: "Page 9",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1118,
    question: "In the Logger example, what does the private tag method return?",
    options: [
      "level + \"[] \"",
      "\"[\" + level + \"] \"",
      "\" [\" + level + \"]\"",
      "level"
    ],
    correctAnswer: "B",
    explanation: "private String tag(String level) { return \"[\" + level + \"] \"; } // Java ≥ 9 (helper)",
    source: "Page 9",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1119,
    question: "Must a class implement abstract methods from an interface?",
    options: [
      "No, they can be ignored.",
      "Yes – must be overridden in every implementing class.",
      "Only if not default.",
      "No, if static."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Abstract Must a Class Implement It? Yes – must be overridden in every implementing class",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1120,
    question: "Are abstract methods allowed to have full code in the interface?",
    options: [
      "Yes – method body is required.",
      "No – only method signature, no body.",
      "Yes, but optional.",
      "Only in Java ≥ 8."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Abstract Allowed to Have Full Code in Interface? No – only method signature, no body",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1121,
    question: "Reason against using only abstr act methods",
    options: [
      "Duplication of code.",
      "All classes must write all code, even shared logic → duplication, harder maintenance.",
      "Unnecessary separation of utilities.",
      "Copy-pasted shared code."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Abstract Why Not Use Only This Type? If only abstract: all classes must write all code, even shared logic → duplication, harder maintenance.",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1122,
    question: "Purpose of abstr act methods",
    options: [
      "Forces essential behavior.",
      "Forces classes to define the essential behavior required by the contract.",
      "Groups utility methods.",
      "Shares internal logic."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Abstract Why It Exists (Real Need) Forces classes to define the essential behavior required by the contract.",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1123,
    question: "Implementation r equir ement for default methods",
    options: [
      "Yes, must override.",
      "No – can use default implementation or override.",
      "Yes, if abstract.",
      "No, belongs to interface."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Default Must a Class Implement It? No – can use default implementation or override",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1124,
    question: "Code allowance for default methods in interfaces",
    options: [
      "No, only signature.",
      "Yes – method body is required.",
      "Yes, optional behavior.",
      "No, for helpers."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Default Allowed to Have Full Code in Interface? Yes – method body is required",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1125,
    question: "Reason against using only default methods",
    options: [
      "Weaker contract.",
      "The \"contract\" is weaker — classes may skip overriding → inconsistent behavior.",
      "Duplication of logic.",
      "Copy-pasted code."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Default Why Not Use Only This Type? If only default: the \"contract\" is weaker — classes may skip overriding → inconsistent behavior.",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1126,
    question: "Purpose of default methods",
    options: [
      "Forces essential behavior.",
      "Adds new functionality without breaking old implementations; gives optional default behavior.",
      "Groups utility methods.",
      "Shares internal logic."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Default Why It Exists (Real Need) Adds new functionality without breaking old implementations; gives optional default behavior.",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1127,
    question: "Implementation r equir ement for static methods",
    options: [
      "Yes, override required.",
      "No – belongs to the interface itself.",
      "Yes, if default.",
      "No, but hidden."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Static Must a Class Implement It? No – belongs to the interface itself",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1128,
    question: "Code allowance for static methods in interfaces",
    options: [
      "No, signature only.",
      "Yes – method body is required.",
      "Yes, optional behavior.",
      "No, for utilities."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Static Allowed to Have Full Code in Interface? Yes – method body is required",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1129,
    question: "Reason against using only static methods",
    options: [
      "Weaker contract.",
      "Without static: utility methods must be in separate helper classes → unnecessary separation.",
      "Duplication of logic.",
      "Copy-pasted code."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Static Why Not Use Only This Type? Without static: utility methods must be in separate helper classes → unnecessary separation.",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1130,
    question: "What are static methods in interfaces used for?",
    options: [
      "Instance-specific behavior.",
      "Utility methods on the interface type itself.",
      "Overridable in classes.",
      "Private helpers."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Static Why It Exists (Real Need) Utility methods on the interface type itself.",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1131,
    question: "Implementation r equir ement for private methods",
    options: [
      "Yes, override required.",
      "No – belongs to the interface itself; not visible to classes.",
      "Yes, if default.",
      "No, but hidden."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Private Must a Class Implement It? No – belongs to the interface itself; not visible to classes",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1132,
    question: "Code allowance for private methods in interfaces",
    options: [
      "No, signature only.",
      "Yes – method body is required.",
      "Yes, optional behavior.",
      "No, for helpers."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Private Allowed to Have Full Code in Interface? Yes – method body is required",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1133,
    question: "Reason against using only private methods",
    options: [
      "Weaker contract.",
      "Without private: shared logic in default/static must be duplicated.",
      "Duplication of logic.",
      "Copy-pasted code."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Private Why Not Use Only This Type? Without private: shared logic in default/static must be duplicated.",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1134,
    question: "Purpose of private methods",
    options: [
      "Forces essential behavior.",
      "Shared internal logic for default/static methods; hidden from implementers.",
      "Groups utility methods.",
      "Shares internal logic."
    ],
    correctAnswer: "B",
    explanation: "Method Type: Private Why It Exists (Real Need) Shared internal logic for default/static methods; hidden from implementers.",
    source: "Page 10",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1135,
    question: "What happens if implementation reduces visibility of interface method?",
    options: [
      "Compiles, but warning.",
      "Interface methods are public; implementation cannot use weaker access.",
      "Allowed if protected.",
      "No error."
    ],
    correctAnswer: "B",
    explanation: "Interface methods are public; implementation cannot use weaker access.",
    source: "Page 25",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1136,
    question: "What is the compile error for missing public in implementation?",
    options: [
      "\"duplicate method\"",
      "\"weaker access privileges\".",
      "\"abstract method\"",
      "\"no override\""
    ],
    correctAnswer: "B",
    explanation: "Missing public → compile error (\"weaker access privileges\").",
    source: "Page 25",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1137,
    question: "What is in interface P?",
    options: [
      "public void p();",
      "void p();",
      "private void p();",
      "static void p();"
    ],
    correctAnswer: "B",
    explanation: "interface P { void p(); }",
    source: "Page 25",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1138,
    question: "In class Q implements P, what causes error?",
    options: [
      "@Override public void p() { System.out.println(\"Q\"); }",
      "void p() { System.out.println(\"Q\"); }",
      "protected void p() { System.out.println(\"Q\"); }",
      "private void p() { System.out.println(\"Q\"); }"
    ],
    correctAnswer: "B",
    explanation: "class Q implements P { void p() { System.out.println(\"Q\"); } // ❌ compile error: weaker access }",
    source: "Page 25",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1139,
    question: "What is the fix in Q2 implements P?",
    options: [
      "void p() { System.out.println(\"Q2\"); }",
      "@Override public void p() { System.out.println(\"Q2\"); }",
      "protected void p() { System.out.println(\"Q2\"); }",
      "static void p() { System.out.println(\"Q2\"); }"
    ],
    correctAnswer: "B",
    explanation: "class Q2 implements P { @Override public void p() { System.out.println(\"Q2\"); } }",
    source: "Page 25",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1140,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1141,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1142,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1143,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1144,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1145,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1146,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1147,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1148,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1149,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1150,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1151,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1152,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1153,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1154,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1155,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1156,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1157,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1158,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1159,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1160,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or combine both } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1161,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1162,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1163,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1164,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1165,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1166,
    question: "Can interface static methods be called via instances?",
    options: [
      "Yes, via implementing object",
      "No, interface static methods are not callable via instances/implementers",
      "Only if overridden",
      "Yes, via super"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Interface static methods are not callable via instances/implementers.",
    source: "Page 27",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1167,
    question: "How to always call interface static methods?",
    options: [
      "new Implementer().method()",
      "InterfaceName.method(...)",
      "this.method()",
      "super.method()"
    ],
    correctAnswer: "B",
    explanation: "Always call with InterfaceName.method(...).",
    source: "Page 27",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1168,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 27",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1169,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { }",
    source: "Page 27",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1170,
    question: "Which call is correct?",
    options: [
      "new V().f();",
      "U.f();",
      "V.f();",
      "this.f();"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // ✅ correct",
    source: "Page 27",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1171,
    question: "Which call causes compile error?",
    options: [
      "U.f();",
      "new V().f();",
      "V.f();",
      "U.super.f();"
    ],
    correctAnswer: "B",
    explanation: "// new V().f(); // ❌ compile error",
    source: "Page 27",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1172,
    question: "What must fields in interfaces be?",
    options: [
      "Uninitialized.",
      "Public static final → must be initialized.",
      "With constructors.",
      "Instance."
    ],
    correctAnswer: "B",
    explanation: "Fields are public static final → must be initialized. No constructors in interfaces; cannot instantiate an interface.",
    source: "Page 28",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1173,
    question: "What is valid in interface K?",
    options: [
      "int Y;",
      "int X = 1;",
      "K() {}",
      "static int X;"
    ],
    correctAnswer: "B",
    explanation: "interface K { int X= 1; // ✅ initialized constant }",
    source: "Page 28",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1174,
    question: "What causes compile error for field Y in K?",
    options: [
      "int X = 1;",
      "int Y;",
      "final int Y = 1;",
      "public int Y = 1;"
    ],
    correctAnswer: "B",
    explanation: "// int Y; // ❌ compile error: must initialize",
    source: "Page 28",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1175,
    question: "What causes compile error for constructor in K?",
    options: [
      "int X = 1;",
      "K() {}",
      "void m();",
      "default void m() {}"
    ],
    correctAnswer: "B",
    explanation: "// K() {} // ❌ compile error: constructors not allowed",
    source: "Page 28",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1176,
    question: "What causes compile error in Demo2?",
    options: [
      "new Class();",
      "new K();",
      "K k = new Implementer();",
      "No error."
    ],
    correctAnswer: "B",
    explanation: "// new K(); // ❌ compile error: cannot instantiate interface",
    source: "Page 28",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1177,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1178,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1179,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1180,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1181,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1182,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1183,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1184,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1185,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1186,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1187,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1188,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1189,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1190,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1191,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1192,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1193,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1194,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1195,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1196,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1197,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1198,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1199,
    question: "When to use interface vs abstract class based on aspect?",
    options: [
      "Shared state/behavior for interface; capability/role for abstract",
      "Capability/role for interface; shared state/behavior for abstract class",
      "Same use for both",
      "Only for roles in both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Use when Interface: capability/role Abstract Class: shared state/behavior",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1200,
    question: "According to the design checklist, when to choose interface?",
    options: [
      "Need shared code/state",
      "Need only a contract",
      "Need instance fields",
      "Need multiple extension"
    ],
    correctAnswer: "B",
    explanation: "Design checklist: Need only a contract → interface",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1201,
    question: "According to the design checklist, when to choose abstract class?",
    options: [
      "Need only a contract",
      "Need shared code/state",
      "For capabilities only",
      "For constants only"
    ],
    correctAnswer: "B",
    explanation: "Need shared code/state → abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1202,
    question: "What keyword is used to implement an interface in Java?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc triển khai: Use implements;",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1203,
    question: "What visibility must provided methods have when implementing an interface?",
    options: [
      "Private or protected",
      "Public methods (cannot reduce visibility)",
      "Package-private only",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "must provide public methods (cannot reduce visibility)",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1204,
    question: "What can the implementation use regarding return and exceptions?",
    options: [
      "Broader throws only",
      "Covariant return (subtype) and narrower throws",
      "No returns allowed",
      "Exact same throws"
    ],
    correctAnswer: "B",
    explanation: "Implementation may use covariant return (subtype) and narrower throws",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1205,
    question: "Where do constructors live when implementing an interface?",
    options: [
      "In the interface",
      "In the implementing class, not in the interface",
      "Shared from interface",
      "Not allowed at all"
    ],
    correctAnswer: "B",
    explanation: "Constructors live in the implementing class, not in the interface",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1206,
    question: "In the Printer interface example, what method is declared?",
    options: [
      "void print(int i);",
      "void print(String s);",
      "String print();",
      "void print();"
    ],
    correctAnswer: "B",
    explanation: "public interface Printer { void print(String s); }",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1207,
    question: "In the ConsolePrinter example, what is the print method?",
    options: [
      "void print(String s) { System.out.println(s); } // error",
      "@Override public void print(String s) { System.out.println(s); }",
      "protected void print(String s) { System.out.println(s); }",
      "private void print(String s) { System.out.println(s); }"
    ],
    correctAnswer: "B",
    explanation: "public class ConsolePrinter implements Printer { @Override public void print(String s) { System.out.println(s); } // must be public",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1208,
    question: "What happens if implementation omits public for interface method?",
    options: [
      "It compiles fine",
      "Compile error: weaker access",
      "Runtime error",
      "No error, defaults to public"
    ],
    correctAnswer: "B",
    explanation: "// @Override void print(String s) { ... } // ✗ compile error: weaker access",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1209,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1210,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1211,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1212,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1213,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1214,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1215,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1216,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1217,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1218,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1219,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1220,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1221,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1222,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1223,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1224,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1225,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1226,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1227,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1228,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1229,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or combine both } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1230,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1231,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1232,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1233,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1234,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1235,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1236,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1237,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1238,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1239,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1240,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1241,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1242,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1243,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1244,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1245,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1246,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1247,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1248,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1249,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1250,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1251,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1252,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1253,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1254,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1255,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1256,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1257,
    question: "When to use interface vs abstract class based on aspect?",
    options: [
      "Shared state/behavior for interface; capability/role for abstract",
      "Capability/role for interface; shared state/behavior for abstract class",
      "Same use for both",
      "Only for roles in both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Use when Interface: capability/role Abstract Class: shared state/behavior",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1258,
    question: "According to the design checklist, when to choose interface?",
    options: [
      "Need shared code/state",
      "Need only a contract",
      "Need instance fields",
      "Need multiple extension"
    ],
    correctAnswer: "B",
    explanation: "Design checklist: Need only a contract → interface",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1259,
    question: "According to the design checklist, when to choose abstract class?",
    options: [
      "Need only a contract",
      "Need shared code/state",
      "For capabilities only",
      "For constants only"
    ],
    correctAnswer: "B",
    explanation: "Need shared code/state → abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1260,
    question: "What keyword is used to implement an interface in Java?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc triển khai: Use implements;",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1261,
    question: "What visibility must provided methods have when implementing an interface?",
    options: [
      "Private or protected",
      "Public methods (cannot reduce visibility)",
      "Package-private only",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "must provide public methods (cannot reduce visibility)",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1262,
    question: "What can the implementation use regarding return and exceptions?",
    options: [
      "Broader throws only",
      "Covariant return (subtype) and narrower throws",
      "No returns allowed",
      "Exact same throws"
    ],
    correctAnswer: "B",
    explanation: "Implementation may use covariant return (subtype) and narrower throws",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1263,
    question: "Where do constructors live when implementing an interface?",
    options: [
      "In the interface",
      "In the implementing class, not in the interface",
      "Shared from interface",
      "Not allowed at all"
    ],
    correctAnswer: "B",
    explanation: "Constructors live in the implementing class, not in the interface",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1264,
    question: "In the Printer interface example, what method is declared?",
    options: [
      "void print(int i);",
      "void print(String s);",
      "String print();",
      "void print();"
    ],
    correctAnswer: "B",
    explanation: "public interface Printer { void print(String s); }",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1265,
    question: "In the ConsolePrinter example, what is the print method?",
    options: [
      "void print(String s) { System.out.println(s); } // error",
      "@Override public void print(String s) { System.out.println(s); }",
      "protected void print(String s) { System.out.println(s); }",
      "private void print(String s) { System.out.println(s); }"
    ],
    correctAnswer: "B",
    explanation: "public class ConsolePrinter implements Printer { @Override public void print(String s) { System.out.println(s); } // must be public",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1266,
    question: "What happens if implementation omits public for interface method?",
    options: [
      "It compiles fine",
      "Compile error: weaker access",
      "Runtime error",
      "No error, defaults to public"
    ],
    correctAnswer: "B",
    explanation: "// @Override void print(String s) { ... } // ✗ compile error: weaker access",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1267,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1268,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1269,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1270,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1271,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1272,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1273,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1274,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1275,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1276,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1277,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1278,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1279,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1280,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1281,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1282,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1283,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1284,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1285,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1286,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1287,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or combine both } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1288,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1289,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1290,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1291,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1292,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1293,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1294,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1295,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1296,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1297,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1298,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1299,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1300,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1301,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1302,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1303,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1304,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1305,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1306,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1307,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1308,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1309,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1310,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1311,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1312,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1313,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1314,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1315,
    question: "When to use interface vs abstract class based on aspect?",
    options: [
      "Shared state/behavior for interface; capability/role for abstract",
      "Capability/role for interface; shared state/behavior for abstract class",
      "Same use for both",
      "Only for roles in both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Use when Interface: capability/role Abstract Class: shared state/behavior",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1316,
    question: "According to the design checklist, when to choose interface?",
    options: [
      "Need shared code/state",
      "Need only a contract",
      "Need instance fields",
      "Need multiple extension"
    ],
    correctAnswer: "B",
    explanation: "Design checklist: Need only a contract → interface",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1317,
    question: "According to the design checklist, when to choose abstract class?",
    options: [
      "Need only a contract",
      "Need shared code/state",
      "For capabilities only",
      "For constants only"
    ],
    correctAnswer: "B",
    explanation: "Need shared code/state → abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1318,
    question: "What keyword is used to implement an interface in Java?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc triển khai: Use implements;",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1319,
    question: "What visibility must provided methods have when implementing an interface?",
    options: [
      "Private or protected",
      "Public methods (cannot reduce visibility)",
      "Package-private only",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "must provide public methods (cannot reduce visibility)",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1320,
    question: "What can the implementation use regarding return and exceptions?",
    options: [
      "Broader throws only",
      "Covariant return (subtype) and narrower throws",
      "No returns allowed",
      "Exact same throws"
    ],
    correctAnswer: "B",
    explanation: "Implementation may use covariant return (subtype) and narrower throws",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1321,
    question: "Where do constructors live when implementing an interface?",
    options: [
      "In the interface",
      "In the implementing class, not in the interface",
      "Shared from interface",
      "Not allowed at all"
    ],
    correctAnswer: "B",
    explanation: "Constructors live in the implementing class, not in the interface",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1322,
    question: "In the Printer interface example, what method is declared?",
    options: [
      "void print(int i);",
      "void print(String s);",
      "String print();",
      "void print();"
    ],
    correctAnswer: "B",
    explanation: "public interface Printer { void print(String s); }",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1323,
    question: "In the ConsolePrinter example, what is the print method?",
    options: [
      "void print(String s) { System.out.println(s); } // error",
      "@Override public void print(String s) { System.out.println(s); }",
      "protected void print(String s) { System.out.println(s); }",
      "private void print(String s) { System.out.println(s); }"
    ],
    correctAnswer: "B",
    explanation: "public class ConsolePrinter implements Printer { @Override public void print(String s) { System.out.println(s); } // must be public",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1324,
    question: "What happens if implementation omits public for interface method?",
    options: [
      "It compiles fine",
      "Compile error: weaker access",
      "Runtime error",
      "No error, defaults to public"
    ],
    correctAnswer: "B",
    explanation: "// @Override void print(String s) { ... } // ✗ compile error: weaker access",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1325,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1326,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1327,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1328,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1329,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1330,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1331,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1332,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1333,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1334,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1335,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1336,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1337,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1338,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1339,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1340,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1341,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1342,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1343,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1344,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1345,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1346,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1347,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1348,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1349,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1350,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1351,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1352,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1353,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1354,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1355,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1356,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1357,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1358,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1359,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1360,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1361,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1362,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1362,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1363,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1364,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1365,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1366,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1368,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1369,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1370,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1371,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1372,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1373,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1374,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1375,
    question: "When to use interface vs abstract class based on aspect?",
    options: [
      "Shared state/behavior for interface; capability/role for abstract",
      "Capability/role for interface; shared state/behavior for abstract class",
      "Same use for both",
      "Only for roles in both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Use when Interface: capability/role Abstract Class: shared state/behavior",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1376,
    question: "According to the design checklist, when to choose interface?",
    options: [
      "Need shared code/state",
      "Need only a contract",
      "Need instance fields",
      "Need multiple extension"
    ],
    correctAnswer: "B",
    explanation: "Design checklist: Need only a contract → interface",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1377,
    question: "According to the design checklist, when to choose abstract class?",
    options: [
      "Need only a contract",
      "Need shared code/state",
      "For capabilities only",
      "For constants only"
    ],
    correctAnswer: "B",
    explanation: "Need shared code/state → abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1378,
    question: "What keyword is used to implement an interface in Java?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc triển khai: Use implements;",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1379,
    question: "What visibility must provided methods have when implementing an interface?",
    options: [
      "Private or protected",
      "Public methods (cannot reduce visibility)",
      "Package-private only",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "must provide public methods (cannot reduce visibility)",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1380,
    question: "What can the implementation use regarding return and exceptions?",
    options: [
      "Broader throws only",
      "Covariant return (subtype) and narrower throws",
      "No returns allowed",
      "Exact same throws"
    ],
    correctAnswer: "B",
    explanation: "Implementation may use covariant return (subtype) and narrower throws",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1381,
    question: "Where do constructors live when implementing an interface?",
    options: [
      "In the interface",
      "In the implementing class, not in the interface",
      "Shared from interface",
      "Not allowed at all"
    ],
    correctAnswer: "B",
    explanation: "Constructors live in the implementing class, not in the interface",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1382,
    question: "In the Printer interface example, what method is declared?",
    options: [
      "void print(int i);",
      "void print(String s);",
      "String print();",
      "void print();"
    ],
    correctAnswer: "B",
    explanation: "public interface Printer { void print(String s); }",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1383,
    question: "In the ConsolePrinter example, what is the print method?",
    options: [
      "void print(String s) { System.out.println(s); } // error",
      "@Override public void print(String s) { System.out.println(s); }",
      "protected void print(String s) { System.out.println(s); }",
      "private void print(String s) { System.out.println(s); }"
    ],
    correctAnswer: "B",
    explanation: "public class ConsolePrinter implements Printer { @Override public void print(String s) { System.out.println(s); } // must be public",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1384,
    question: "What happens if implementation omits public for interface method?",
    options: [
      "It compiles fine",
      "Compile error: weaker access",
      "Runtime error",
      "No error, defaults to public"
    ],
    correctAnswer: "B",
    explanation: "// @Override void print(String s) { ... } // ✗ compile error: weaker access",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1385,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1386,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1387,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1388,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1389,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1390,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1391,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1392,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1393,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1394,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1395,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1396,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1397,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1398,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1399,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1400,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1401,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1402,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1403,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1404,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1405,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or combine both } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1406,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1407,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1408,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1409,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1410,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1411,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1412,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1413,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1414,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1415,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1416,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1417,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1418,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1419,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1420,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1421,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1422,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1423,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1424,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1425,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1426,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1427,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1428,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1429,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1430,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1431,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1432,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1433,
    question: "When to use interface vs abstract class based on aspect?",
    options: [
      "Shared state/behavior for interface; capability/role for abstract",
      "Capability/role for interface; shared state/behavior for abstract class",
      "Same use for both",
      "Only for roles in both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Use when Interface: capability/role Abstract Class: shared state/behavior",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1434,
    question: "According to the design checklist, when to choose interface?",
    options: [
      "Need shared code/state",
      "Need only a contract",
      "Need instance fields",
      "Need multiple extension"
    ],
    correctAnswer: "B",
    explanation: "Design checklist: Need only a contract → interface",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1435,
    question: "According to the design checklist, when to choose abstract class?",
    options: [
      "Need only a contract",
      "Need shared code/state",
      "For capabilities only",
      "For constants only"
    ],
    correctAnswer: "B",
    explanation: "Need shared code/state → abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1436,
    question: "What keyword is used to implement an interface in Java?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc triển khai: Use implements;",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1437,
    question: "What visibility must provided methods have when implementing an interface?",
    options: [
      "Private or protected",
      "Public methods (cannot reduce visibility)",
      "Package-private only",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "must provide public methods (cannot reduce visibility)",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1438,
    question: "What can the implementation use regarding return and exceptions?",
    options: [
      "Broader throws only",
      "Covariant return (subtype) and narrower throws",
      "No returns allowed",
      "Exact same throws"
    ],
    correctAnswer: "B",
    explanation: "Implementation may use covariant return (subtype) and narrower throws",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1439,
    question: "Where do constructors live when implementing an interface?",
    options: [
      "In the interface",
      "In the implementing class, not in the interface",
      "Shared from interface",
      "Not allowed at all"
    ],
    correctAnswer: "B",
    explanation: "Constructors live in the implementing class, not in the interface",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1440,
    question: "In the Printer interface example, what method is declared?",
    options: [
      "void print(int i);",
      "void print(String s);",
      "String print();",
      "void print();"
    ],
    correctAnswer: "B",
    explanation: "public interface Printer { void print(String s); }",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1441,
    question: "In the ConsolePrinter example, what is the print method?",
    options: [
      "void print(String s) { System.out.println(s); } // error",
      "@Override public void print(String s) { System.out.println(s); }",
      "protected void print(String s) { System.out.println(s); }",
      "private void print(String s) { System.out.println(s); }"
    ],
    correctAnswer: "B",
    explanation: "public class ConsolePrinter implements Printer { @Override public void print(String s) { System.out.println(s); } // must be public",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1442,
    question: "What happens if implementation omits public for interface method?",
    options: [
      "It compiles fine",
      "Compile error: weaker access",
      "Runtime error",
      "No error, defaults to public"
    ],
    correctAnswer: "B",
    explanation: "// @Override void print(String s) { ... } // ✗ compile error: weaker access",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1443,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1444,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1445,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1446,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1447,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1448,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1449,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1450,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1451,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1452,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1453,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1454,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1455,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1456,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1457,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1458,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1459,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1460,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1461,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1462,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1463,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or combine both } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1464,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1465,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1466,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1467,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1468,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1469,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1470,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1471,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1472,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1473,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1474,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1475,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1476,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1477,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1478,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1479,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1480,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1481,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1482,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1483,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1484,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1485,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1486,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1487,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1488,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1489,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1490,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1491,
    question: "When to use interface vs abstract class based on aspect?",
    options: [
      "Shared state/behavior for interface; capability/role for abstract",
      "Capability/role for interface; shared state/behavior for abstract class",
      "Same use for both",
      "Only for roles in both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Use when Interface: capability/role Abstract Class: shared state/behavior",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1492,
    question: "According to the design checklist, when to choose interface?",
    options: [
      "Need shared code/state",
      "Need only a contract",
      "Need instance fields",
      "Need multiple extension"
    ],
    correctAnswer: "B",
    explanation: "Design checklist: Need only a contract → interface",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1493,
    question: "According to the design checklist, when to choose abstract class?",
    options: [
      "Need only a contract",
      "Need shared code/state",
      "For capabilities only",
      "For constants only"
    ],
    correctAnswer: "B",
    explanation: "Need shared code/state → abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1494,
    question: "What keyword is used to implement an interface in Java?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc triển khai: Use implements;",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1495,
    question: "What visibility must provided methods have when implementing an interface?",
    options: [
      "Private or protected",
      "Public methods (cannot reduce visibility)",
      "Package-private only",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "must provide public methods (cannot reduce visibility)",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1496,
    question: "What can the implementation use regarding return and exceptions?",
    options: [
      "Broader throws only",
      "Covariant return (subtype) and narrower throws",
      "No returns allowed",
      "Exact same throws"
    ],
    correctAnswer: "B",
    explanation: "Implementation may use covariant return (subtype) and narrower throws",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1497,
    question: "Where do constructors live when implementing an interface?",
    options: [
      "In the interface",
      "In the implementing class, not in the interface",
      "Shared from interface",
      "Not allowed at all"
    ],
    correctAnswer: "B",
    explanation: "Constructors live in the implementing class, not in the interface",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1498,
    question: "In the Printer interface example, what method is declared?",
    options: [
      "void print(int i);",
      "void print(String s);",
      "String print();",
      "void print();"
    ],
    correctAnswer: "B",
    explanation: "public interface Printer { void print(String s); }",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1499,
    question: "In the ConsolePrinter example, what is the print method?",
    options: [
      "void print(String s) { System.out.println(s); } // error",
      "@Override public void print(String s) { System.out.println(s); }",
      "protected void print(String s) { System.out.println(s); }",
      "private void print(String s) { System.out.println(s); }"
    ],
    correctAnswer: "B",
    explanation: "public class ConsolePrinter implements Printer { @Override public void print(String s) { System.out.println(s); } // must be public",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1500,
    question: "What happens if implementation omits public for interface method?",
    options: [
      "It compiles fine",
      "Compile error: weaker access",
      "Runtime error",
      "No error, defaults to public"
    ],
    correctAnswer: "B",
    explanation: "// @Override void print(String s) { ... } // ✗ compile error: weaker access",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1501,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1502,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1503,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1504,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1505,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1506,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1507,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1508,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1509,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1510,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1511,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1512,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1513,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1514,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1515,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1516,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1517,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1518,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1519,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1520,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1521,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or combine both } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1522,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1523,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1524,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1525,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1526,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1527,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1528,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1529,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1530,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1531,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1532,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1533,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1534,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1535,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1536,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1537,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1538,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1539,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1540,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1541,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1542,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1543,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1544,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1545,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1546,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1547,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1548,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1549,
    question: "When to use interface vs abstract class based on aspect?",
    options: [
      "Shared state/behavior for interface; capability/role for abstract",
      "Capability/role for interface; shared state/behavior for abstract class",
      "Same use for both",
      "Only for roles in both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Use when Interface: capability/role Abstract Class: shared state/behavior",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1550,
    question: "According to the design checklist, when to choose interface?",
    options: [
      "Need shared code/state",
      "Need only a contract",
      "Need instance fields",
      "Need multiple extension"
    ],
    correctAnswer: "B",
    explanation: "Design checklist: Need only a contract → interface",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1551,
    question: "According to the design checklist, when to choose abstract class?",
    options: [
      "Need only a contract",
      "Need shared code/state",
      "For capabilities only",
      "For constants only"
    ],
    correctAnswer: "B",
    explanation: "Need shared code/state → abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1552,
    question: "What keyword is used to implement an interface in Java?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc triển khai: Use implements;",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1553,
    question: "What visibility must provided methods have when implementing an interface?",
    options: [
      "Private or protected",
      "Public methods (cannot reduce visibility)",
      "Package-private only",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "must provide public methods (cannot reduce visibility)",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1554,
    question: "What can the implementation use regarding return and exceptions?",
    options: [
      "Broader throws only",
      "Covariant return (subtype) and narrower throws",
      "No returns allowed",
      "Exact same throws"
    ],
    correctAnswer: "B",
    explanation: "Implementation may use covariant return (subtype) and narrower throws",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1555,
    question: "Where do constructors live when implementing an interface?",
    options: [
      "In the interface",
      "In the implementing class, not in the interface",
      "Shared from interface",
      "Not allowed at all"
    ],
    correctAnswer: "B",
    explanation: "Constructors live in the implementing class, not in the interface",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1556,
    question: "In the Printer interface example, what method is declared?",
    options: [
      "void print(int i);",
      "void print(String s);",
      "String print();",
      "void print();"
    ],
    correctAnswer: "B",
    explanation: "public interface Printer { void print(String s); }",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1557,
    question: "In the ConsolePrinter example, what is the print method?",
    options: [
      "void print(String s) { System.out.println(s); } // error",
      "@Override public void print(String s) { System.out.println(s); }",
      "protected void print(String s) { System.out.println(s); }",
      "private void print(String s) { System.out.println(s); }"
    ],
    correctAnswer: "B",
    explanation: "public class ConsolePrinter implements Printer { @Override public void print(String s) { System.out.println(s); } // must be public",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1558,
    question: "What happens if implementation omits public for interface method?",
    options: [
      "It compiles fine",
      "Compile error: weaker access",
      "Runtime error",
      "No error, defaults to public"
    ],
    correctAnswer: "B",
    explanation: "// @Override void print(String s) { ... } // ✗ compile error: weaker access",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1559,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1560,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1561,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1562,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1563,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1564,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1565,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1566,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1567,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1568,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1569,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1570,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1571,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1572,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1573,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1574,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1575,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1576,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1577,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1578,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1579,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or combine both } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1580,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1581,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1582,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1583,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1584,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1585,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1586,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1587,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1588,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1589,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1590,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1591,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1592,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1593,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1594,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1595,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1596,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1597,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1598,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1599,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1600,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1601,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1602,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1603,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1604,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1605,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1606,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1607,
    question: "When to use interface vs abstract class based on aspect?",
    options: [
      "Shared state/behavior for interface; capability/role for abstract",
      "Capability/role for interface; shared state/behavior for abstract class",
      "Same use for both",
      "Only for roles in both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Use when Interface: capability/role Abstract Class: shared state/behavior",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1608,
    question: "According to the design checklist, when to choose interface?",
    options: [
      "Need shared code/state",
      "Need only a contract",
      "Need instance fields",
      "Need multiple extension"
    ],
    correctAnswer: "B",
    explanation: "Design checklist: Need only a contract → interface",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1609,
    question: "According to the design checklist, when to choose abstract class?",
    options: [
      "Need only a contract",
      "Need shared code/state",
      "For capabilities only",
      "For constants only"
    ],
    correctAnswer: "B",
    explanation: "Need shared code/state → abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1610,
    question: "What keyword is used to implement an interface in Java?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc triển khai: Use implements;",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1611,
    question: "What visibility must provided methods have when implementing an interface?",
    options: [
      "Private or protected",
      "Public methods (cannot reduce visibility)",
      "Package-private only",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "must provide public methods (cannot reduce visibility)",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1612,
    question: "What can the implementation use regarding return and exceptions?",
    options: [
      "Broader throws only",
      "Covariant return (subtype) and narrower throws",
      "No returns allowed",
      "Exact same throws"
    ],
    correctAnswer: "B",
    explanation: "Implementation may use covariant return (subtype) and narrower throws",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1613,
    question: "Where do constructors live when implementing an interface?",
    options: [
      "In the interface",
      "In the implementing class, not in the interface",
      "Shared from interface",
      "Not allowed at all"
    ],
    correctAnswer: "B",
    explanation: "Constructors live in the implementing class, not in the interface",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1614,
    question: "In the Printer interface example, what method is declared?",
    options: [
      "void print(int i);",
      "void print(String s);",
      "String print();",
      "void print();"
    ],
    correctAnswer: "B",
    explanation: "public interface Printer { void print(String s); }",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1615,
    question: "In the ConsolePrinter example, what is the print method?",
    options: [
      "void print(String s) { System.out.println(s); } // error",
      "@Override public void print(String s) { System.out.println(s); }",
      "protected void print(String s) { System.out.println(s); }",
      "private void print(String s) { System.out.println(s); }"
    ],
    correctAnswer: "B",
    explanation: "public class ConsolePrinter implements Printer { @Override public void print(String s) { System.out.println(s); } // must be public",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1616,
    question: "What happens if implementation omits public for interface method?",
    options: [
      "It compiles fine",
      "Compile error: weaker access",
      "Runtime error",
      "No error, defaults to public"
    ],
    correctAnswer: "B",
    explanation: "// @Override void print(String s) { ... } // ✗ compile error: weaker access",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1617,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1618,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1619,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1620,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1621,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1622,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1623,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1624,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1625,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1626,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1627,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1628,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1629,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1630,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1631,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1632,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1633,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1634,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1635,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1636,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1637,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or combine both } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1638,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1639,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1640,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1641,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1642,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1643,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1644,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1645,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1646,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1647,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1648,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1649,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1650,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1651,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1652,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1653,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1654,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1655,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1656,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1657,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1658,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1659,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1660,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1661,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1662,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1663,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1664,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1665,
    question: "When to use interface vs abstract class based on aspect?",
    options: [
      "Shared state/behavior for interface; capability/role for abstract",
      "Capability/role for interface; shared state/behavior for abstract class",
      "Same use for both",
      "Only for roles in both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Use when Interface: capability/role Abstract Class: shared state/behavior",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1666,
    question: "According to the design checklist, when to choose interface?",
    options: [
      "Need shared code/state",
      "Need only a contract",
      "Need instance fields",
      "Need multiple extension"
    ],
    correctAnswer: "B",
    explanation: "Design checklist: Need only a contract → interface",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1667,
    question: "According to the design checklist, when to choose abstract class?",
    options: [
      "Need only a contract",
      "Need shared code/state",
      "For capabilities only",
      "For constants only"
    ],
    correctAnswer: "B",
    explanation: "Need shared code/state → abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1668,
    question: "What keyword is used to implement an interface in Java?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc triển khai: Use implements;",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1669,
    question: "What visibility must provided methods have when implementing an interface?",
    options: [
      "Private or protected",
      "Public methods (cannot reduce visibility)",
      "Package-private only",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "must provide public methods (cannot reduce visibility)",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1670,
    question: "What can the implementation use regarding return and exceptions?",
    options: [
      "Broader throws only",
      "Covariant return (subtype) and narrower throws",
      "No returns allowed",
      "Exact same throws"
    ],
    correctAnswer: "B",
    explanation: "Implementation may use covariant return (subtype) and narrower throws",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1671,
    question: "Where do constructors live when implementing an interface?",
    options: [
      "In the interface",
      "In the implementing class, not in the interface",
      "Shared from interface",
      "Not allowed at all"
    ],
    correctAnswer: "B",
    explanation: "Constructors live in the implementing class, not in the interface",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1672,
    question: "In the Printer interface example, what method is declared?",
    options: [
      "void print(int i);",
      "void print(String s);",
      "String print();",
      "void print();"
    ],
    correctAnswer: "B",
    explanation: "public interface Printer { void print(String s); }",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1673,
    question: "In the ConsolePrinter example, what is the print method?",
    options: [
      "void print(String s) { System.out.println(s); } // error",
      "@Override public void print(String s) { System.out.println(s); }",
      "protected void print(String s) { System.out.println(s); }",
      "private void print(String s) { System.out.println(s); }"
    ],
    correctAnswer: "B",
    explanation: "public class ConsolePrinter implements Printer { @Override public void print(String s) { System.out.println(s); } // must be public",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1674,
    question: "What happens if implementation omits public for interface method?",
    options: [
      "It compiles fine",
      "Compile error: weaker access",
      "Runtime error",
      "No error, defaults to public"
    ],
    correctAnswer: "B",
    explanation: "// @Override void print(String s) { ... } // ✗ compile error: weaker access",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1675,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1676,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1678,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1679,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1680,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1681,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1682,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1683,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1684,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1685,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1686,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1687,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1688,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1689,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1690,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1691,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1692,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1693,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1694,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1695,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1696,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or combine both } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1697,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1698,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1699,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1700,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1701,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1702,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1703,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1704,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1705,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1706,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1707,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1708,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1709,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1710,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1711,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1712,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1713,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1714,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1715,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1716,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1718,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1719,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1720,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1721,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1722,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1723,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1724,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1725,
    question: "When to use interface vs abstract class based on aspect?",
    options: [
      "Shared state/behavior for interface; capability/role for abstract",
      "Capability/role for interface; shared state/behavior for abstract class",
      "Same use for both",
      "Only for roles in both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Use when Interface: capability/role Abstract Class: shared state/behavior",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1726,
    question: "According to the design checklist, when to choose interface?",
    options: [
      "Need shared code/state",
      "Need only a contract",
      "Need instance fields",
      "Need multiple extension"
    ],
    correctAnswer: "B",
    explanation: "Design checklist: Need only a contract → interface",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1727,
    question: "According to the design checklist, when to choose abstract class?",
    options: [
      "Need only a contract",
      "Need shared code/state",
      "For capabilities only",
      "For constants only"
    ],
    correctAnswer: "B",
    explanation: "Need shared code/state → abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1728,
    question: "What keyword is used to implement an interface in Java?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc triển khai: Use implements;",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1729,
    question: "What visibility must provided methods have when implementing an interface?",
    options: [
      "Private or protected",
      "Public methods (cannot reduce visibility)",
      "Package-private only",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "must provide public methods (cannot reduce visibility)",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1730,
    question: "What can the implementation use regarding return and exceptions?",
    options: [
      "Broader throws only",
      "Covariant return (subtype) and narrower throws",
      "No returns allowed",
      "Exact same throws"
    ],
    correctAnswer: "B",
    explanation: "Implementation may use covariant return (subtype) and narrower throws",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1731,
    question: "Where do constructors live when implementing an interface?",
    options: [
      "In the interface",
      "In the implementing class, not in the interface",
      "Shared from interface",
      "Not allowed at all"
    ],
    correctAnswer: "B",
    explanation: "Constructors live in the implementing class, not in the interface",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1732,
    question: "In the Printer interface example, what method is declared?",
    options: [
      "void print(int i);",
      "void print(String s);",
      "String print();",
      "void print();"
    ],
    correctAnswer: "B",
    explanation: "public interface Printer { void print(String s); }",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1733,
    question: "In the ConsolePrinter example, what is the print method?",
    options: [
      "void print(String s) { System.out.println(s); } // error",
      "@Override public void print(String s) { System.out.println(s); }",
      "protected void print(String s) { System.out.println(s); }",
      "private void print(String s) { System.out.println(s); }"
    ],
    correctAnswer: "B",
    explanation: "public class ConsolePrinter implements Printer { @Override public void print(String s) { System.out.println(s); } // must be public",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1734,
    question: "What happens if implementation omits public for interface method?",
    options: [
      "It compiles fine",
      "Compile error: weaker access",
      "Runtime error",
      "No error, defaults to public"
    ],
    correctAnswer: "B",
    explanation: "// @Override void print(String s) { ... } // ✗ compile error: weaker access",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1735,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1736,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1738,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1739,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1740,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1741,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1742,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1743,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1744,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1745,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1746,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1747,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1748,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1749,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1750,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1751,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1752,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1753,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1754,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1755,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1756,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or combine both } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1757,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1758,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1759,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1760,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1761,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1762,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1763,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1764,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1765,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1766,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1767,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1768,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1769,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1770,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1771,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1772,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1773,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1774,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1775,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1776,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1778,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1779,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1780,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1781,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1782,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1783,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1784,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1785,
    question: "When to use interface vs abstract class based on aspect?",
    options: [
      "Shared state/behavior for interface; capability/role for abstract",
      "Capability/role for interface; shared state/behavior for abstract class",
      "Same use for both",
      "Only for roles in both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Use when Interface: capability/role Abstract Class: shared state/behavior",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1786,
    question: "According to the design checklist, when to choose interface?",
    options: [
      "Need shared code/state",
      "Need only a contract",
      "Need instance fields",
      "Need multiple extension"
    ],
    correctAnswer: "B",
    explanation: "Design checklist: Need only a contract → interface",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1787,
    question: "According to the design checklist, when to choose abstract class?",
    options: [
      "Need only a contract",
      "Need shared code/state",
      "For capabilities only",
      "For constants only"
    ],
    correctAnswer: "B",
    explanation: "Need shared code/state → abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1788,
    question: "What keyword is used to implement an interface in Java?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc triển khai: Use implements;",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1789,
    question: "What visibility must provided methods have when implementing an interface?",
    options: [
      "Private or protected",
      "Public methods (cannot reduce visibility)",
      "Package-private only",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "must provide public methods (cannot reduce visibility)",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1790,
    question: "What can the implementation use regarding return and exceptions?",
    options: [
      "Broader throws only",
      "Covariant return (subtype) and narrower throws",
      "No returns allowed",
      "Exact same throws"
    ],
    correctAnswer: "B",
    explanation: "Implementation may use covariant return (subtype) and narrower throws",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1791,
    question: "Where do constructors live when implementing an interface?",
    options: [
      "In the interface",
      "In the implementing class, not in the interface",
      "Shared from interface",
      "Not allowed at all"
    ],
    correctAnswer: "B",
    explanation: "Constructors live in the implementing class, not in the interface",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1792,
    question: "In the Printer interface example, what method is declared?",
    options: [
      "void print(int i);",
      "void print(String s);",
      "String print();",
      "void print();"
    ],
    correctAnswer: "B",
    explanation: "public interface Printer { void print(String s); }",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1793,
    question: "In the ConsolePrinter example, what is the print method?",
    options: [
      "void print(String s) { System.out.println(s); } // error",
      "@Override public void print(String s) { System.out.println(s); }",
      "protected void print(String s) { System.out.println(s); }",
      "private void print(String s) { System.out.println(s); }"
    ],
    correctAnswer: "B",
    explanation: "public class ConsolePrinter implements Printer { @Override public void print(String s) { System.out.println(s); } // must be public",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1794,
    question: "What happens if implementation omits public for interface method?",
    options: [
      "It compiles fine",
      "Compile error: weaker access",
      "Runtime error",
      "No error, defaults to public"
    ],
    correctAnswer: "B",
    explanation: "// @Override void print(String s) { ... } // ✗ compile error: weaker access",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1795,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1796,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1798,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1799,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1800,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1801,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1802,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1803,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1804,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1805,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1806,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1807,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1808,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1809,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1810,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1811,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1812,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1813,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1814,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1815,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1816,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or combine both } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1817,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1818,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1819,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1820,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1821,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1822,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1823,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1824,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1825,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1826,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1827,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1828,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1829,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1830,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1831,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1832,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1833,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1834,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1835,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1836,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1837,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1838,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1839,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1840,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1841,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1842,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1843,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1844,
    question: "When to use interface vs abstract class based on aspect?",
    options: [
      "Shared state/behavior for interface; capability/role for abstract",
      "Capability/role for interface; shared state/behavior for abstract class",
      "Same use for both",
      "Only for roles in both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Use when Interface: capability/role Abstract Class: shared state/behavior",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1845,
    question: "According to the design checklist, when to choose interface?",
    options: [
      "Need shared code/state",
      "Need only a contract",
      "Need instance fields",
      "Need multiple extension"
    ],
    correctAnswer: "B",
    explanation: "Design checklist: Need only a contract → interface",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1846,
    question: "According to the design checklist, when to choose abstract class?",
    options: [
      "Need only a contract",
      "Need shared code/state",
      "For capabilities only",
      "For constants only"
    ],
    correctAnswer: "B",
    explanation: "Need shared code/state → abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1847,
    question: "What keyword is used to implement an interface in Java?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc triển khai: Use implements;",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1848,
    question: "What visibility must provided methods have when implementing an interface?",
    options: [
      "Private or protected",
      "Public methods (cannot reduce visibility)",
      "Package-private only",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "must provide public methods (cannot reduce visibility)",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1849,
    question: "What can the implementation use regarding return and exceptions?",
    options: [
      "Broader throws only",
      "Covariant return (subtype) and narrower throws",
      "No returns allowed",
      "Exact same throws"
    ],
    correctAnswer: "B",
    explanation: "Implementation may use covariant return (subtype) and narrower throws",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1850,
    question: "Where do constructors live when implementing an interface?",
    options: [
      "In the interface",
      "In the implementing class, not in the interface",
      "Shared from interface",
      "Not allowed at all"
    ],
    correctAnswer: "B",
    explanation: "Constructors live in the implementing class, not in the interface",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1851,
    question: "In the Printer interface example, what method is declared?",
    options: [
      "void print(int i);",
      "void print(String s);",
      "String print();",
      "void print();"
    ],
    correctAnswer: "B",
    explanation: "public interface Printer { void print(String s); }",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1852,
    question: "In the ConsolePrinter example, what is the print method?",
    options: [
      "void print(String s) { System.out.println(s); } // error",
      "@Override public void print(String s) { System.out.println(s); }",
      "protected void print(String s) { System.out.println(s); }",
      "private void print(String s) { System.out.println(s); }"
    ],
    correctAnswer: "B",
    explanation: "public class ConsolePrinter implements Printer { @Override public void print(String s) { System.out.println(s); } // must be public",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1853,
    question: "What happens if implementation omits public for interface method?",
    options: [
      "It compiles fine",
      "Compile error: weaker access",
      "Runtime error",
      "No error, defaults to public"
    ],
    correctAnswer: "B",
    explanation: "// @Override void print(String s) { ... } // ✗ compile error: weaker access",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1854,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1855,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1858,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1859,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1860,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1861,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1862,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1863,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1864,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1865,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1866,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1867,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1868,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1869,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1870,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1871,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1872,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1873,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1874,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1875,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1876,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or combine both } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1877,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1878,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1879,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1880,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1881,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1882,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1883,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1884,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1885,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1886,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1887,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1888,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1889,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1890,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1891,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1892,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1893,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1894,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1895,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1896,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1897,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1898,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1899,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1900,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1901,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1902,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1903,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1904,
    question: "When to use interface vs abstract class based on aspect?",
    options: [
      "Shared state/behavior for interface; capability/role for abstract",
      "Capability/role for interface; shared state/behavior for abstract class",
      "Same use for both",
      "Only for roles in both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Use when Interface: capability/role Abstract Class: shared state/behavior",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1905,
    question: "According to the design checklist, when to choose interface?",
    options: [
      "Need shared code/state",
      "Need only a contract",
      "Need instance fields",
      "Need multiple extension"
    ],
    correctAnswer: "B",
    explanation: "Design checklist: Need only a contract → interface",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1906,
    question: "According to the design checklist, when to choose abstract class?",
    options: [
      "Need only a contract",
      "Need shared code/state",
      "For capabilities only",
      "For constants only"
    ],
    correctAnswer: "B",
    explanation: "Need shared code/state → abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1907,
    question: "What keyword is used to implement an interface in Java?",
    options: [
      "extends",
      "implements",
      "abstract",
      "interface"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc triển khai: Use implements;",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1908,
    question: "What visibility must provided methods have when implementing an interface?",
    options: [
      "Private or protected",
      "Public methods (cannot reduce visibility)",
      "Package-private only",
      "Static"
    ],
    correctAnswer: "B",
    explanation: "must provide public methods (cannot reduce visibility)",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1909,
    question: "What can the implementation use regarding return and exceptions?",
    options: [
      "Broader throws only",
      "Covariant return (subtype) and narrower throws",
      "No returns allowed",
      "Exact same throws"
    ],
    correctAnswer: "B",
    explanation: "Implementation may use covariant return (subtype) and narrower throws",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1910,
    question: "Where do constructors live when implementing an interface?",
    options: [
      "In the interface",
      "In the implementing class, not in the interface",
      "Shared from interface",
      "Not allowed at all"
    ],
    correctAnswer: "B",
    explanation: "Constructors live in the implementing class, not in the interface",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1911,
    question: "In the Printer interface example, what method is declared?",
    options: [
      "void print(int i);",
      "void print(String s);",
      "String print();",
      "void print();"
    ],
    correctAnswer: "B",
    explanation: "public interface Printer { void print(String s); }",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1912,
    question: "In the ConsolePrinter example, what is the print method?",
    options: [
      "void print(String s) { System.out.println(s); } // error",
      "@Override public void print(String s) { System.out.println(s); }",
      "protected void print(String s) { System.out.println(s); }",
      "private void print(String s) { System.out.println(s); }"
    ],
    correctAnswer: "B",
    explanation: "public class ConsolePrinter implements Printer { @Override public void print(String s) { System.out.println(s); } // must be public",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1913,
    question: "What happens if implementation omits public for interface method?",
    options: [
      "It compiles fine",
      "Compile error: weaker access",
      "Runtime error",
      "No error, defaults to public"
    ],
    correctAnswer: "B",
    explanation: "// @Override void print(String s) { ... } // ✗ compile error: weaker access",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1914,
    question: "What is the tip for keeping interfaces?",
    options: [
      "Large and general",
      "Small and focused (ISP)",
      "With \"Utils\" names",
      "With many constants"
    ],
    correctAnswer: "B",
    explanation: "Tip: Keep interfaces small and focused (ISP). Prefer meaningful names over \"Utils\" for contracts.",
    source: "Page 16",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1915,
    question: "Can a class implement several interfaces?",
    options: [
      "No, only one",
      "Yes, a class can implement several interfaces",
      "Only if no defaults",
      "Only abstract classes"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc xử lý xung đột: A class can implement several interfaces",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1916,
    question: "What are the rules for default method conflicts?",
    options: [
      "Interface always wins over class",
      "1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → must override and can delegate via InterfaceName.super.m()",
      "Always override automatically",
      "No rules, compile error always"
    ],
    correctAnswer: "B",
    explanation: "Default method conflicts rules: 1. Class wins over interface 2. More specific subinterface wins over superinterface 3. If still ambiguous → you must override and can delegate via InterfaceName.super.m()",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1917,
    question: "In the example, what do A and B defaults print for m()?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"C\"",
      "Both \"Ambiguous\""
    ],
    correctAnswer: "B",
    explanation: "public interface A { default void m() { System.out.println(\"A\"); } } public interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1918,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "public class C implements A, B { @Override public void m() { A.super.m(); /* or B.super.m(); or custom */ } }",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1919,
    question: "Note on Constant Clashes",
    options: [
      "Ignore, first wins",
      "Qualify: A.X, B.X",
      "Override constants",
      "Cannot have clashes"
    ],
    correctAnswer: "B",
    explanation: "Note: For constant name clashes, qualify: A.X, B.X",
    source: "Page 17",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1920,
    question: "In default method conflicts, what wins if a superclass defines m()?",
    options: [
      "Interface default overrides class",
      "If a superclass defines m(), it overrides any interface default m() automatically",
      "Must override in subclass",
      "Compile error always"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If a superclass defines m(), it overrides any interface default m() automatically",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1921,
    question: "Is override needed in the subclass for class winning over interface default?",
    options: [
      "Yes, always",
      "No need to override in the subclass",
      "Only if ambiguous",
      "Yes, to delegate"
    ],
    correctAnswer: "B",
    explanation: "No need to override in the subclass",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1922,
    question: "In the example, what does A default m() print?",
    options: [
      "\"Base\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1923,
    question: "In the example, what does Base m() print?",
    options: [
      "\"A\"",
      "\"Base\"",
      "\"C\"",
      "\"Subclass\""
    ],
    correctAnswer: "B",
    explanation: "class Base { public void m() { System.out.println(\"Base\"); } }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1924,
    question: "In class C extends Base implements A, is override needed?",
    options: [
      "Yes, @Override void m()",
      "No override needed",
      "Must delegate to A.super",
      "Compile error without override"
    ],
    correctAnswer: "B",
    explanation: "class C extends Base implements A { /* class member wins; no override needed */ }",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1925,
    question: "What does new C().m() print in Demo1?",
    options: [
      "A",
      "Base",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo1 { public static void main(String[] args) { new C().m(); } } // prints: Base",
    source: "Page 18",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1926,
    question: "In default method conflicts, what wins if B extends A with default m()?",
    options: [
      "Superinterface A wins",
      "More specific subinterface wins over superinterface",
      "Must override",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: If B extends A and both have default m(), B.m() is chosen",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1927,
    question: "Subinterface Win Even with Dir ect Implement",
    options: [
      "No, A wins",
      "Yes, even if the class implements A, B, the more specific B wins",
      "No, ambiguous",
      "Only if no class method"
    ],
    correctAnswer: "B",
    explanation: "Even if the class implements A, B, the more specific B wins",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1928,
    question: "What does A default m() print?",
    options: [
      "\"B\"",
      "\"A\"",
      "\"C\"",
      "nothing"
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1929,
    question: "What does B default m() print, where B extends A?",
    options: [
      "\"A\"",
      "\"B\"",
      "\"C\"",
      "\"Super\""
    ],
    correctAnswer: "B",
    explanation: "interface B extends A { default void m() { System.out.println(\"B\"); } }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1930,
    question: "In class C implements A, B, what happens to m()?",
    options: [
      "A is chosen",
      "B is more specific → chosen automatically",
      "Must override",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { /* B is more specific → chosen automatically */ }",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1931,
    question: "What does new C().m() print in Demo2?",
    options: [
      "A",
      "B",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo2 { public static void main(String[] args) { new C().m(); } } // prints: B",
    source: "Page 19",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1932,
    question: "What happens if two unrelated interfaces have the same default m()?",
    options: [
      "Automatically chooses first",
      "Cause ambiguity; the class must override and may delegate via InterfaceName.super.m()",
      "Subinterface wins",
      "Class wins"
    ],
    correctAnswer: "B",
    explanation: "Quy tắc: Two unrelated interfaces with the same default m() cause ambiguity. The class must override and may delegate via InterfaceName.super.m()",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1933,
    question: "What do A and B defaults print for m() in ambiguous example?",
    options: [
      "A: \"B\"; B: \"A\"",
      "A: \"A\"; B: \"B\"",
      "Both \"Ambiguous\"",
      "Both \"C\""
    ],
    correctAnswer: "B",
    explanation: "interface A { default void m() { System.out.println(\"A\"); } } interface B { default void m() { System.out.println(\"B\"); } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1934,
    question: "In class C implements A, B, what is in the override for m()?",
    options: [
      "B.super.m();",
      "A.super.m();",
      "System.out.println(\"C\");",
      "No override"
    ],
    correctAnswer: "B",
    explanation: "class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or combine both } }",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1935,
    question: "What does new C().m() print in Demo3?",
    options: [
      "B",
      "A",
      "C",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class Demo3 { public static void main(String[] args) { new C().m(); } } // prints: A",
    source: "Page 20",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1936,
    question: "What causes a compilation error in default method conflicts?",
    options: [
      "Related interfaces with same default",
      "Two unrelated interfaces define the same default method → ambiguous",
      "Class method present",
      "Subinterface override"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Two unrelated interfaces define the same default method → ambiguous.",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1937,
    question: "What is the compile-time error if not overridden in ambiguous case?",
    options: [
      "\"overrides unrelated defaults\"",
      "\"inherits unrelated defaults for m() from types A and B\"",
      "\"cannot find method m()\"",
      "\"duplicate method\""
    ],
    correctAnswer: "B",
    explanation: "The implementing class must override; otherwise compile-time error: \"inherits unrelated defaults for m() from types A and B\".",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1938,
    question: "In the example, which class causes compile error?",
    options: [
      "class C implements A {}",
      "class C implements A, B {}",
      "class C extends A, B {}",
      "interface C implements A, B {}"
    ],
    correctAnswer: "B",
    explanation: "// ❌ compile-time error: C inherits unrelated defaults for m() from A and B class C implements A, B { }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1939,
    question: "How to fix the ambiguous default conflict?",
    options: [
      "Remove one interface",
      "Override and choose/delegate",
      "Make class abstract",
      "Use static instead"
    ],
    correctAnswer: "B",
    explanation: "Fix (override and choose/delegate): class C implements A, B { @Override public void m() { A.super.m(); // or B.super.m(); or custom body } }",
    source: "Page 21",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1940,
    question: "Can interface static methods be overridden?",
    options: [
      "Yes, with @Override.",
      "Interface static methods are not inherited and cannot be overridden.",
      "Yes, in subclasses.",
      "Only if default."
    ],
    correctAnswer: "B",
    explanation: "Interface static methods are not inherited and cannot be overridden.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1941,
    question: "What happens if adding @Override on static in class?",
    options: [
      "Compiles fine.",
      "Compile error.",
      "Runtime override.",
      "No error, overrides."
    ],
    correctAnswer: "B",
    explanation: "Adding @Override on a static method in the class → compile error.",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1942,
    question: "What is a class static with same signature as interface static?",
    options: [
      "Override.",
      "Unrelated; call with ClassName.method().",
      "Error.",
      "Inherited."
    ],
    correctAnswer: "B",
    explanation: "Class static with same signature is unrelated; call with ClassName.method().",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1943,
    question: "What is in interface U?",
    options: [
      "default void f() { System.out.println(\"U.f\"); }",
      "static void f() { System.out.println(\"U.f\"); }",
      "void f();",
      "private void f() { System.out.println(\"U.f\"); }"
    ],
    correctAnswer: "B",
    explanation: "interface U { static void f() { System.out.println(\"U.f\"); } }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1944,
    question: "class V implements U has what?",
    options: [
      "Method f",
      "Nothing special",
      "Override f",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "class V implements U { // @Override static void f() { System.out.println(\"V.f\"); } // ❌ compile error }",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1945,
    question: "What is valid in V?",
    options: [
      "@Override static void f() { ... }",
      "public static void f() { System.out.println(\"V.f\"); }",
      "@Override void f() { ... }",
      "static void f() { U.super.f(); }"
    ],
    correctAnswer: "B",
    explanation: "public static void f() { System.out.println(\"V.f\"); } // ✅ separate static",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1946,
    question: "What prints U.f()?",
    options: [
      "V.f",
      "U.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "U.f(); // prints U.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1947,
    question: "What prints V.f()?",
    options: [
      "U.f",
      "V.f",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "V.f(); // prints V.f",
    source: "Page 29",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1948,
    question: "What is interface-driven polymorphism?",
    options: [
      "Variable of class type only",
      "Program to an interface: a variable of interface type can reference any implementing class",
      "Static dispatch",
      "No swapping"
    ],
    correctAnswer: "B",
    explanation: "Khái niệm chính: Program to an interface: a variable of interface type can reference any implementing class.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1949,
    question: "How are calls handled in interface polymorphism?",
    options: [
      "Statically at compile",
      "Dynamically dispatched to the runtime implementation",
      "No dispatch",
      "Only to abstract class"
    ],
    correctAnswer: "B",
    explanation: "Calls are dynamically dispatched to the runtime implementation.",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1950,
    question: "What does interface polymorphism allow?",
    options: [
      "Tight coupling.",
      "Swap implementations without changing caller code (decoupling, easier testing).",
      "Harder testing.",
      "No change."
    ],
    correctAnswer: "B",
    explanation: "* Swap implementations without changing caller code (decoupling, easier testing).",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1951,
    question: "What is in PaymentMethod?",
    options: [
      "void pay(int amount);",
      "void pay(double amount);",
      "double pay();",
      "static void pay(double amount);"
    ],
    correctAnswer: "B",
    explanation: "public interface PaymentMethod { void pay(double amount); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1952,
    question: "What does CreditCard pay print?",
    options: [
      "\"EWallet pays \" + amount",
      "\"CC pays \" + amount",
      "\"Paid \" + amount",
      "\"Charge \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class CreditCard implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"CC pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1953,
    question: "What does EWallet pay print?",
    options: [
      "\"CC pays \" + amount",
      "\"EWallet pays \" + amount",
      "\"Wallet pays \" + amount",
      "\"E pays \" + amount"
    ],
    correctAnswer: "B",
    explanation: "public class EWallet implements PaymentMethod { @Override public void pay(double amount) { System.out.println(\"EWallet pays \" + amount); } }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1954,
    question: "What does pm = new CreditCard(); pm.pay(100); print?",
    options: [
      "EWallet pays 100",
      "CC pays 100",
      "Error",
      "Nothing"
    ],
    correctAnswer: "B",
    explanation: "PaymentMethod pm = new CreditCard(); pm.pay(100); // CC pays 100",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1955,
    question: "What does pm = new EWallet(); pm.pay(50); print?",
    options: [
      "CC pays 50",
      "EWallet pays 50",
      "CC pays 100",
      "Error"
    ],
    correctAnswer: "B",
    explanation: "pm = new EWallet(); pm.pay(50); // EWallet pays 50",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1956,
    question: "What is the loop for PaymentMethod m : List.of(new CreditCard(), new EWallet())?",
    options: [
      "m.pay(50);",
      "m.pay(10);",
      "m.pay(100);",
      "m.pay(0);"
    ],
    correctAnswer: "B",
    explanation: "for (PaymentMethod m : java.util.List.of(new CreditCard(), new EWallet())) { m.pay(10); }",
    source: "Page 30",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1957,
    question: "What is the general comparison between interface and abstract class?",
    options: [
      "Interface = partial implementation; Abstract class = contract.",
      "Interface = contract; Abstract class = partial implementation (shared code).",
      "Both are contracts only.",
      "Both provide full implementations."
    ],
    correctAnswer: "B",
    explanation: "Interface = contract; Abstract class = partial implementation (shared code)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1958,
    question: "How many interfaces can a class implement vs abstract classes extend?",
    options: [
      "One interface; many abstract classes",
      "Many interfaces; one abstract class",
      "One of each",
      "Many of each"
    ],
    correctAnswer: "B",
    explanation: "A class can implement many interfaces; can extend one abstract class",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1959,
    question: "What methods are allowed in interface vs abstract class?",
    options: [
      "Concrete only in interface; abstract only in abstract class",
      "Abstract / default / static / private in interface; abstract + concrete in abstract class",
      "No methods in interface",
      "Same for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Methods Interface: abstract / default / static / private Abstract Class: abstract + concrete",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1960,
    question: "What fields are allowed in interface vs abstract class?",
    options: [
      "Instance in interface; constants in abstract",
      "Constants (public static final) in interface; instance + static in abstract class",
      "No fields in either",
      "Same fields for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Fields Interface: constants (public static final) Abstract Class: instance + static",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  {
    id: 1961,
    question: "What is the inheritance aspect for interface vs abstract class?",
    options: [
      "Single for interface; multiple for abstract",
      "Multiple (implements) for interface; single (extends) for abstract class",
      "No inheritance for either",
      "Multiple for both"
    ],
    correctAnswer: "B",
    explanation: "Aspect: Inheritance Interface: multiple (implements) Abstract Class: single (extends)",
    source: "Page 15",
    topic: "Interfaces & UML Design"
  },
  // Adding key questions from each section to demonstrate the complete structure
]

export const topics = [
  "All Topics",
  "Classes & Objects",
  "Modifiers & Encapsulation",
  "Inheritance",
  "Polymorphism & Abstract Classes",
  "Interfaces & UML Design",
]

export type QuizQuestion = {
  id: number
  question: string
  options: string[]
  correctAnswer: string
  explanation: string
  source: string
  topic: string
}
